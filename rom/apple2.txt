; ==============================================================================
; Disassembly of the Apple II Plus Emulator APPLE2.ROM image file: 
; RAM ($B000-$BFFF), I/O & Slot-RAM/ROM ($C000-$CFFF), & ROM Space ($D000-$FFFF)
; ==============================================================================
; Thanks to Andy McFadden for his 6502bench SourceGen Disassembler which greatly
; helped in the creation of this document.  And, for his pertinent disassemblies
; (made with it), which also helped.  And, for CiderPress, too!
; ==============================================================================
; Project by James P. Davis                              Last updated 2020/04/21
; ------------------------------------------------------------------------------
; This APPLE2.ROM image file (3/27/1995) was obtained from AppleWin v.1.11.2.1.
; [It is identical to the APPLE2.ROM image (3/26/1995) from ApplePC v2.52 by
; David Ellsworth (based on Randy Spurlock's Apl2Emu)].  It has errors in it! 
; (Especially at the very end, using an Old Monitor Reset Vector.)  All errors
; detected will be Noted.
; ==============================================================================
; My analysis of this ROM is complete, but I may have made mistakes, so I will
; fix them as others, such as you, find them and let me know about them.  Fixes
; will be in future releases as/if we continue on.
; ------------------------------------------------------------------------------
; The Polynomial LOG & ATN Coeficiaents are Still a Mystery to me!
; ==============================================================================
; Notes: I made this verbose for future newbies & amateur 6502 programmers.
; ------------------------------------------------------------------------------
; All symbols, labels, & comments, are adapted from works by Apple Computer
; Inc., David T Craig, William F. Luebbert, Jim Sather, Bob Sander-Cederlof,
; Michael Pohoreski, Andy McFadden, (& most likely) many more other persons, 
; and by me, the Editor of this document.  Actually, I've changed a lot of them!
; ------------------------------------------------------------------------------
; Some Applesoft comments are by David T Craig, originally; some are by Bob
; Sander-Cederlof; most of those have been edited by me; others are just by me
; (for my verbose analysis)!  Again, I've changed a lot of them!
; ==============================================================================
; Sources:
; ------------------------------------------------------------------------------
; 1. "Apple II+ Memory Equates for Assembly Programmers" by me (Unpublished)
; 2. Various "DIS65" & "SYM65" files & disassembly listings by Andy McFadden
;    (faddenSoft).
; 3. Various AppleWin "SYM" files by Michael Pohoreski & Tom Charlesworth.
; 4. "Understanding the Apple II" and "Understanding the Apple IIe" (both) by
;    Jim Sather.
; 5. "What's Where in the Apple" by William F. Luebbert.
; 6. "S-C DocuMentor: Applesoft" by Bob Sander-Cederlof.
; 7. "AppleSoft BASIC Source (DTCA2DOC-007)" by David T Craig.
; 8. "AppleSoft", Rev. 4/27/1984, Assembly Listing from diskette accompanying
;    "Call-A.P.P.L.E. In Depth #1: All About Applesoft" (IIRC).
; 9. "Apple II Monitors Peeled" (c) 1981 by Apple Computer Inc.
; A. Other Apple II ROMs {Known FTP Sources}:
;    = ftp://ftp.apple.asimov.net/pub/apple_II/emulators/rom_images/
;    = ftp://public.asimov.net/pub/apple_II/emulators/rom_images/
; ==============================================================================
; 
; 
; ==============================================================================
; Equate Table:
; ==============================================================================
; 
ERR_NOFOR       EQU   $00             ;"?Next Without For" Error Index
CTRLCL          EQU   $03             ;Low ASCII Ctrl+C Character
RTNL            EQU   $0D             ;Low ASCII Ctrl-M: Carriage Return
ERR_SYNTAX      EQU   $10             ;"?Syntax" Error Index
ERR_NOGOSUB     EQU   $16             ;"?Return Without Gosub" Error Index
BIT_ZP          EQU   $24             ;BIT OpCode for a Zero-Page Address
ERR_NODATA      EQU   $2A             ;"?Out Of Data" Error Index
BIT_ABS         EQU   $2C             ;BIT OpCode for an Absolute Address
SIZE            EQU   $30             ;Maximum Size of Lo-Res Screen (48 x 48)
ERR_ILLQTY      EQU   $35             ;"?Illegal Quantity" Error Index
ERR_OVERFLOW    EQU   $45             ;"?Overflow" Error Index
P_OR            EQU   $46             ;Math Operator: "OR"  Precedence Code
ERR_MEMFULL     EQU   $4D             ;"?Out Of Memory" Error Index
P_AND           EQU   $50             ;Math Operator: "AND" Precedence Code
ERR_UNDEFSTAT   EQU   $5A             ;"?Undef'd Statement" Error Index
P_REL           EQU   $64             ;Math Operator: "REL" Precedence Code
ERR_BADSUBS     EQU   $6B             ;"?Bad Subscript" Error Index
ERR_REDIMD      EQU   $78             ;"?Redim'd Array" Error Index
P_ADD           EQU   $79             ;Math Operator: "ADD" Precedence Code
P_MUL           EQU   $7B             ;Math Operator: "MUL" Precedence Code
P_PWR           EQU   $7D             ;Math Operator: "PWR" Precedence Code
P_NEQ           EQU   $7F             ;Math Operator: "NEQ" Precedence Code
TOK_FOR         EQU   $81             ;Token: "FOR" Program Control Statement
CTRLCH          EQU   $83             ;High ASCII Ctrl+C Character
TOK_DATA        EQU   $83             ;Token: "DATA" Data Assignment Statement
ERR_ZERODIV     EQU   $85             ;"?Division By Zero" Error Index
BELL_H          EQU   $87             ;High ASCII Ctrl-G: Sound Bell Character
BSH             EQU   $88             ;High ASCII Ctrl-H: Backspace
LFH             EQU   $8A             ;High ASCII Ctrl-J: Line Feed
RTNH            EQU   $8D             ;High ASCII Ctrl-M: Carriage Return
BCC             EQU   $90             ;Branch if Carry is Clear OpCode
CTRLSH          EQU   $93             ;High ASCII Ctrl+S Character
ERR_ILLDIR      EQU   $95             ;"?Illegal Direct" Error Index
PICK            EQU   $95             ;Right-Arrow Key Code: Ctrl-U (NAK)
CTRLXH          EQU   $98             ;High ASCII Cancel Character (Ctrl+X)
ESCH            EQU   $9B             ;High ASCII Escape Character (Ctrl+[)
ERR_BADTYPE     EQU   $A3             ;"?Type Mismatch" Error Index
TOK_GOTO        EQU   $AB             ;Token: "GOTO" Program Control Statement
ERR_STRLONG     EQU   $B0             ;"?String Too Long" Error Index
TOK_GOSUB       EQU   $B0             ;Token: "GOSUB" Program Control Statement
TOK_REM         EQU   $B2             ;Token: "REM" Prgrm-Documentation Statement
TOK_PRINT       EQU   $BA             ;Token: "PRINT" Output Statement
ERR_FRMCPX      EQU   $BF             ;"?Formula Too Complex" Error Index
HGRHIGH         EQU   $C0             ;Hi-Res Graphics Screens Height: 192 Pixels
TOK_TAB         EQU   $C0             ;Token: "TAB(" Cursor Position Statement
TOK_TO          EQU   $C1             ;Token: "TO" Program Control Statement
TOK_FN          EQU   $C2             ;Token: "FN" Function Assignment Statement
TOK_SPC         EQU   $C3             ;Token: "SPC(" Cursor Position Statement
TOK_THEN        EQU   $C4             ;Token: "THEN" Conditional Statement
TOK_AT          EQU   $C5             ;Token: "AT" Graphics Drawing Statement
TOK_NOT         EQU   $C6             ;Token: "NOT" Conditional Statement
TOK_STEP        EQU   $C7             ;Token: "STEP" Conditional Statement
TOK_PLUS        EQU   $C8             ;Token: "+" (Plus) Math Function
TOK_MINUS       EQU   $C9             ;Token: "-" (Minus) Math Function
TOK_GREATER     EQU   $CF             ;Token: ">" (Greater Than) Cond. Statement
TOK_EQUAL       EQU   $D0             ;Token: "=" (Equal To) Cond. Statement
ERR_CANTCONT    EQU   $D2             ;"?Can't Continue" Error Index
TOK_SGN         EQU   $D2             ;Token: "SGN" Math Function
TOK_SCRN        EQU   $D7             ;Token: "SCRN(" LoRes (X,Y) Color Statement
ERR_UNDEFFUNC   EQU   $E0             ;"?Undef'd Function" Error Index
CIOPG           EQU   $FD             ;Monitor Char I/O S/R Vectors Page Address
ERR_BADRESP     EQU   $FE             ;'Bad Response to Input' Error Code
CTRLCIRQ        EQU   $FF             ;"CTRL C INTERUPT ATTEMPTED" ONERR Code
DELETE          EQU   $FF             ;High ASCII "DELETE" character
HGRWIDE         EQU   $0118           ;Hi-Res Graphics Screens Width: 280 Pixels
IOADR           EQU   $C000           ;Hardware I/O Addresses & Soft Switches
LOC0            EQU   $00             ;Preset to JMP OpCode [$4C] (3B) ;AKA: GOWARM
LOC1            EQU   $01             ;Preset to BASIC Soft/Warm/Ctrl-C Entry (2B)
LOC2            EQU   $02             ;Used in Shifting Right (ROR) LOC1-4,X  (1B)
LOC3            EQU   $03             ;=GOSTROUT; Preset to JMP OpCode ($4C)
LOC4            EQU   $04             ;=GOSTROUT+1
BAS_USRVEC      EQU   $0A             ;Applesoft USR() Command Vector (JMP)   (3B)
BAS_USRPTR      EQU   $0B             ;Applesoft USR() Command Pointer        (2B)
CHARAC          EQU   $0D             ;Applesoft String Terminator, Alternate
ENDCHR          EQU   $0E             ;Applesoft String Terminator, Primary
NUMDIM          EQU   $0F             ;Number of Applesoft Array Dimensions
TKNCNTR         EQU   $0F             ;Holds Current Token - $80
DIMFLG          EQU   $10             ;Array Dimension Flag (DIM Call <> 0)
VALTYP          EQU   $11             ;Applesoft Variable Type ($00=Num, $FF=Str)
INTFLG          EQU   $12             ;Negative for Integer Variable (%)
DATAFLG         EQU   $13             ;Applesoft DATA Statement Flag
GARFLG          EQU   $13             ;Applesoft Garbage Collection Flag
SUBFLG          EQU   $14             ;Subscript Flag ($00=Allowed, $80=NOT)
INPUTFLG        EQU   $15             ;Input Flag ($00=INPUT, $40=GET, $98=READ)
CPRMASK         EQU   $16             ;Applesoft Compare Mask [(CPRTYP)<-FRMEVL]
SIGNFLG         EQU   $16             ;Applesoft Trig Functions Sign Flag    (1B)
HSHAPE          EQU   $1A             ;Applesoft Hi-Res Screen Byte Pointer
HCOLOR1         EQU   $1C             ;Applesoft Hi-Res Color Mask
HCOUNT          EQU   $1D             ;Applesoft Hi-Res Line Step            (2B)
WNDLFT          EQU   $20             ;Left Column of Scroll Window
WNDWDTH         EQU   $21             ;Width of Scroll Window
WNDTOP          EQU   $22             ;Top of Scroll Window
WNDBTM          EQU   $23             ;Bottom of Scroll Window
CH              EQU   $24             ;Cursor Horizontal Displacement
CV              EQU   $25             ;Cursor Vertical Displacement
GBASL           EQU   $26             ;Graphics Base Address, Low
IWMDATAPTR      EQU   $26             ;IWM: Pointer to Boot1 Data Buffer
GBASH           EQU   $27             ;Graphics Base Address, High
BASL            EQU   $28             ;Text Base Address, Low
BASH            EQU   $29             ;Text Base Address, High
BAS2L           EQU   $2A             ;Scrolling Destination Line Pointer, Low
BAS2H           EQU   $2B             ;Scrolling Destination Line Pointer, High
IWMSLTNDX       EQU   $2B             ;IWM: Slot Number << 4
H2              EQU   $2C             ;Right End of Horizontal Line (HLINE)
LMNEM           EQU   $2C             ;Instruction Display Mnemonic Left Byte
RMNEM           EQU   $2D             ;Instruction Display Mnemonic Right Byte
V2              EQU   $2D             ;Bottom End of Vertical Line (VLINE)
CHKSUM          EQU   $2E             ;Cassette Tape Input Accumulated Checksum
FORMAT          EQU   $2E             ;Disassembler Instruction Display Format
MASK            EQU   $2E             ;Lo-Res Graphics Color Mask (Apple IIc)
LASTIN          EQU   $2F             ;Cassette Input Voltage Change Detector
LENGTH          EQU   $2F             ;Disassembler Instruction Display Length
HMASK           EQU   $30             ;Graphics On-the-Fly Color Bit Mask Safe
MODE            EQU   $31             ;Monitor Mode Flag
INVFLG          EQU   $32             ;Text Mask (Normal=$FF, Flash=$7F, Inv=$3F)
PROMPT          EQU   $33             ;Command Prompt Character
YSAV            EQU   $34             ;Y-Reg Safe For Monitor Command Processing
YSAV1           EQU   $35             ;Y-Reg Safe; Save across JSR VIDOUT/VIDWAIT
CSWL            EQU   $36             ;Character Output Hook, Low
KSWL            EQU   $38             ;Character Input Hook, Low
PCL             EQU   $3A             ;Program Counter Safe, Low
PCH             EQU   $3B             ;Program Counter Safe, High
A1L             EQU   $3C             ;Monitor General Purpose A1-Reg, Low
IWMBITS         EQU   $3C             ;IWM: Temp Storage for Bit Manipulation
A1H             EQU   $3D             ;Monitor General Purpose A1-Reg, High
IWMSECTOR       EQU   $3D             ;IWM: Sector to Read
A2L             EQU   $3E             ;Monitor General Purpose A2-Reg, Low
A2H             EQU   $3F             ;Monitor General Purpose A2-Reg, High
A3L             EQU   $40             ;Monitor General Purpose A3-Reg, Low
IWMTRKFND       EQU   $40             ;IWM: Track Found
A3H             EQU   $41             ;Monitor General Purpose A3-Reg, High
IWMTRACK        EQU   $41             ;IWM: Track to Read
A4L             EQU   $42             ;Monitor General Purpose A4-Reg, Low
A4H             EQU   $43             ;Monitor General Purpose A4-Reg, High
A5L             EQU   $44             ;Monitor General Purpose A5-Reg, Low
ACC             EQU   $45             ;A-Reg Safe (Accumulator) [Destroys A5H!]
XREG            EQU   $46             ;X-Reg Safe (Index Register X)
YREG            EQU   $47             ;Y-Reg Safe (Index Register Y)
STATUS          EQU   $48             ;P-Reg Safe (Status Register)
SPNT            EQU   $49             ;S-Reg Safe (Stack Pointer)
SAVE6502        EQU   $4A             ;6502 Registers Safe (Save Locations)+5
RNDL            EQU   $4E             ;Keyin Random Counter Value, Low
RNDH            EQU   $4F             ;Keyin Random Counter Value, High
LINNUM          EQU   $50             ;Applesoft Line Number                 (2B)
TEMPPT          EQU   $52             ;SD Stack: Next Temp Descriptor Ptr    (1B)
LASTPT          EQU   $53             ;SD Stack: Last Temp Descriptor Ptr    (1B)
TEMPST          EQU   $55             ;~$5D: Holds up to 3 Descriptors       (9B)
INDEX           EQU   $5E             ;Move Strings Index Pointer            (2B)
LINPTR          EQU   $5E             ;Move Strings Line Pointer             (2B)
SRCPTR          EQU   $5E             ;Move Strings Source Pointer           (2B)
STKPTR          EQU   $5E             ;Move Strings Stack Pointer            (2B)
DSTPTR          EQU   $60             ;Move Strings Destination Pointer      (2B)
RESULT          EQU   $62             ;~$66: FP Result of Last Mult* or Div/ (5B)
TXTTAB          EQU   $67             ;Applesoft Start of Program Pointer    (2B)
VARTAB          EQU   $69             ;Applesoft Start of Variables Pointer  (2B)
ARYTAB          EQU   $6B             ;Applesoft Start of Arrays Pointer     (2B)
STREND          EQU   $6D             ;End of Variables & Pointers Storage   (2B)
FRETOP          EQU   $6F             ;FreSpcEnd & StringStorageStart Ptr    (2B)
FRESPC          EQU   $71             ;Applesoft String Routines' Temp Ptr   (2B)
MEMSIZ          EQU   $73             ;Applesoft End of String Space (HIMEM) (2B)
CURLIN          EQU   $75             ;Current Applesoft Line Number         (2B)
OLDLIN          EQU   $77             ;Last Applesoft Line Executed, Address (2B)
OLDTEXT         EQU   $79             ;Applesoft Old Text Pointer            (2B)
DATLIN          EQU   $7B             ;Line Number of Current DATA Statement (2B)
DATPTR          EQU   $7D             ;Address of Current DATA Statement     (2B)
INPTR           EQU   $7F             ;Applesoft Input Pointer               (2B)
VARNAM          EQU   $81             ;Last-Used Variable Name Pointer       (2B)
VARPTR          EQU   $83             ;Last-Used Variable Value Pointer      (2B)
FORPTR          EQU   $85             ;Applesoft General Purpose Pointer     (2B)
LASTOP          EQU   $87             ;Applesoft FRMEVL Scratch Flag         (1B)
TXPSV           EQU   $87             ;TXTPTR Safe: Used in INPUT routine    (2B)
CPRTYP          EQU   $89             ;Applesoft FRMEVL Compare Flag (>,=,<) (1B)
FNCNAM          EQU   $8A             ;Applesoft Function Name Pointer       (2B)
TEMP3           EQU   $8A             ;~$8E: Applesoft Temporary FAC #3      (5B)
DSCPTR          EQU   $8C             ;Applesoft String Descriptor Pointer   (2B)
DSCLEN          EQU   $8F             ;Applesoft String Descriptor Length    (1B)
JMPADRS         EQU   $90             ;Applesoft Jump (from ZP) to <Address> (3B)
GARLEN          EQU   $91             ;Applesoft Garbage Collection Length   (1B)
ARGEXT          EQU   $92             ;ARG Extra Precision Byte for FP Op's  (1B)
TEMP1           EQU   $93             ;Applesoft FP Math Register            (1B)
ARYPTR          EQU   $94             ;Applesoft Array Pointer               (2B)
HIGHDS          EQU   $94             ;Copy Ptr: Highest Destination Adrs +1 (2B)
HIGHTR          EQU   $96             ;Copy Ptr: Highest Source Address +1   (2B)
TEMP2           EQU   $98             ;Applesoft FP Math Register            (2B)
INDX            EQU   $99             ;Used by Applesoft Array Returns       (1B)
TMPEXP          EQU   $99             ;Used in Applesoft FIN (Eval) Routine  (1B)
EXPON           EQU   $9A             ;Applesoft Exponent Safe               (1B)
DPFLG           EQU   $9B             ;Applesoft Decimal Point Flag          (1B)
LOWTR           EQU   $9B             ;Copy Ptr: Lowest Source Address       (2B)
EXPSGN          EQU   $9C             ;Applesoft Exponent Sign Safe          (1B)
DSCTMP          EQU   $9D             ;Temp Descriptor, String Length        (1B)
FAC             EQU   $9D             ;Primary Floating Point Accumulator    (6B)
DSCTMPL         EQU   $9E             ;Temp Descriptor, String Addr, Low     (1B)
DSCTMPH         EQU   $9F             ;Temp Descriptor, String Addr, High    (1B)
TMPVPTR         EQU   $A0             ;Temporary Variable Pointer (FAC+3,4)  (2B)
FACSIGN         EQU   $A2             ;Primary FAC Unpacked Sign (msb)       (1B)
SERLEN          EQU   $A3             ;Holds Length of Series-1              (1B)
SHFTSGNX        EQU   $A4             ;FAC Right Shift Sign Extension        (1B)
ARG             EQU   $A5             ;Secondary Floating Point Accumulator  (6B)
ARGVPTR         EQU   $A8             ;Applesoft Temporary Variable Pointer  (2B)
ARGSIGN         EQU   $AA             ;Secondary FAC Unpacked Sign (msb)     (1B)
SGNCPR          EQU   $AB             ;Applesoft Sign Flag for Comparing     (1B)
STRNG1          EQU   $AB             ;Applesoft String Pointer #1           (2B)
FACEXT          EQU   $AC             ;FAC Extra Precision Byte for FP Op's  (1B)
SERPTR          EQU   $AD             ;Pointer to Series Data in FP Op's     (2B)
STRNG2          EQU   $AD             ;Applesoft String Pointer #2           (2B)
PRGEND          EQU   $AF             ;Applesoft End of Program Pointer      (2B)
CHRGET          EQU   $B1             ;~$C8: Get Next Char/Token ZP-Routine (24B)
CHRGOT          EQU   $B7             ;~$C8: CHRGET w/o advancing TXTPTR    (18B)
TXTPTR          EQU   $B8             ;CHRGET's Next Char/Token Pointer      (2B)
RNDSEED         EQU   $C9             ;~$CD: Applesoft FP Random Number Seed (5B)
HGRDX           EQU   $D0             ;Hi-Res Drawing Horizontal X-Position  (2B)
HGRDY           EQU   $D2             ;Hi-Res Drawing  Vertical  Y-Position  (1B)
HGRQUAD         EQU   $D3             ;Hi-Res Graphics Drawing Quadrant      (1B)
HGRE            EQU   $D4             ;Used in Hi-Res Graphics Drawing       (2B)
AUTORUN         EQU   $D6             ;AutoRun/Lock: No User Access If >=$80 (1B)
ERRFLG          EQU   $D8             ;ONERR GOTO is Active If = #$80        (1B)
ERRLIN          EQU   $DA             ;Applesoft Line# Where ERROR Occurred  (2B)
ERRPOS          EQU   $DC             ;Applesoft Error Handler TXTPTR Safe   (2B)
ERRNUM          EQU   $DE             ;Current Applesoft Error Number Safe   (1B)
ERRSTK          EQU   $DF             ;Applesoft Stack Ptr before Error Safe (1B)
HGRX            EQU   $E0             ;Hi-Res Graphics X-Coordinate (H-POSN) (2B)
HGRY            EQU   $E2             ;Hi-Res Graphics Y-Coordinate (V-POSN) (2B)
HGRCOLOR        EQU   $E4             ;Hi-Res Graphics Color Flag/Safe       (1B)
HGRHORIZ        EQU   $E5             ;Hi-Res Byte Horiz. Index from GBASL,H (1B)
HGRPAGE         EQU   $E6             ;Hi-Res Base Page (HPg1=$20, HPg2=$40) (1B)
HGRSCALE        EQU   $E7             ;Hi-Res Graphics Drawing Scale Factor  (1B)
HGRSHPTR        EQU   $E8             ;Hi-Res Graphics Shape Pointer         (2B)
HGRCLSN         EQU   $EA             ;Hi-Res Graphics Collision Counter     (2B)
FIRST           EQU   $F0             ;Lo-Res Plot Coordinates               (1B)
SPDBYT          EQU   $F1             ;Text Output Speed Limiter             (1B)
TRCFLG          EQU   $F2             ;Trace OFF/ON Flag (<128/>127)~(bit-7) (1B)
FLASHBIT        EQU   $F3             ;Flash Text? (Flash=$40, Else=$00)     (1B)
TXTPSV          EQU   $F4             ;Applesoft Char/Token Pointer Safe     (2B)
CURLSV          EQU   $F6             ;Applesoft Current Line Safe           (2B)
REMSTK          EQU   $F8             ;Stack Ptr Before Each Statement Safe  (1B)
HGRROT          EQU   $F9             ;Hi-Res Graphics Rotation Value        (1B)
FOUTBUFF        EQU   $FF             ;Start String at STACK-1 ($FF)         (1B)
STACK           EQU   $0100           ;Apple-II 6502 Microprocessor Stack
LINEIMAGE       EQU   $01FB           ;Program's New Line Image (should be zero)
IMGNXLNPTR      EQU   $01FC           ;New Line Image's Next Line Pointer
IMGLINNUM       EQU   $01FE           ;New Line Image's Line Number
INBUFF          EQU   $0200           ;Input Buffer [Range:(512~767)=($200~$2FF)]
TWOSBUFF        EQU   $0300           ;Holds the 6+2 2-bit Chunks of Data
CNVTBL          EQU   $0356           ;6+2 Conversion Table (128 Bytes of Memory)
GOBRKV          EQU   $03EF           ;Set by DOS to JMP for User BRK Vector
BRKV            EQU   $03F0           ;User BRK Vector (Address of Break Handler)
SOFTEV          EQU   $03F2           ;Soft Entry (Warm Start) Vector
PWREDUP         EQU   $03F4           ;Power-Up Reset CHKSUM [(SOFTEV+1)EOR #$A5]
AMPERV          EQU   $03F5           ;Ampersand (&) Command Vector (JMP)
USRADDR         EQU   $03F8           ;Monitor User Command (Ctrl-Y) Vector
NMI             EQU   $03FB           ;Non-Maskable Interrupt (NMI) Vector
IRQADDR         EQU   $03FE           ;Address of IRQ Handler
LINE1           EQU   $0400           ;Text Screen Start Address
MSLOT           EQU   $07F8           ;Slot Number ($CS) of Peripheral Card
BOOT1           EQU   $0800           ;DOS Buffer for Next Stage of Loader
PRGMEM          EQU   $0800           ;Initial Start of Program Memory
HGR1SCRN        EQU   $2000           ;~$3FFF: Hi-Res Screen Pg.1 (Base-Address)
HGR2SCRN        EQU   $4000           ;~$5FFF: Hi-Res Screen Pg.2 (Base-Address)
TKADTBL         EQU   $D000           ;Applesoft Tokens Branch Address Table
UNFNC           EQU   $D080           ;Unary Functions Branch Address Table
MATHTBL         EQU   $D0B2           ;Math Operator Branch Address Table
TKNMTBL         EQU   $D0D0           ;Token Names Branch Address Table
ERR_MSGS        EQU   $D260           ;Applesoft Error Messages Table
XLTBASE         EQU   $FA48           ;XLTBL Base Address [XLTBL-("I"=$C9=201)]

                ORG   $B000
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; RAM [ROM Image file] Space ($B000-$BFFF): This is RAM on a real Apple II Plus.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
; ==============================================================================
; Empty Address Space (MTSPC1)=($B000-$B5FF)
; ==============================================================================
; 
MTSPC1          DS    1536,$00        ;6 empty pgs of RAM/ROM-Image ($B000-$B5FF)
; 
; ==============================================================================
; The following Address Space ($B600-$B6FF) is a copy (or vice-versa) of the
; Slot 6 Address Space (SLOT6)=($C600-$C6FF).            [See below to read it.]
; ------------------------------------------------------------------------------
; This code does not need to analyzed twice, so it is densely packed here.
; ==============================================================================
; 
DISK2RAM        HEX   A220A000A203863C8A0A243CF010053C49FF297EB0084AD0FB989D5603C8E810
                 +    E52058FFBABD00010A0A0A0A852BAABD8EC0BD8CC0BD8AC0BD89C0A050BD80C0
                 +    9829030A052BAABD81C0A95620A8FC8810EB8526853D8541A90885271808BD8C
                 +    C010FB49D5D0F7BD8CC010FBC9AAD0F3EABD8CC010FBC996F0092890DF49ADF0
                 +    25D0D9A0038540BD8CC010FB2A853CBD8CC010FB253C88D0EC28C53DD0BEA540
                 +    C541D0B8B0B7A056843CBC8CC010FB59D602A43C88990003D0EE843CBC8CC010
                 +    FB59D602A43C9126C8D0EFBC8CC010FB59D602D087A000A256CA30FBB1265E00
                 +    032A5E00032A9126C8D0EEE627E63DA53DCD0008A62B90DB4C01080000000000
; 
; ==============================================================================
; Empty Address Space (MTSPC2)=($B700-$BFFF)
; ==============================================================================
; 
MTSPC2          DS    2304,$00        ;9 empty pgs of RAM/ROM-Image ($B700-$BFFF)
; 
; ==============================================================================
; Hardware Input/Output Address Space (IOADR)=($C000-$C0FF) & (CLRROM)=($CFFF)
; ==============================================================================
; SLOT0      EQU $C000 ;I/O or Slot ROM Space (Only in ROM image), Empty!
; ------------------------------------------------------------------------------
; IOADR      EQU $C000 ;Hardware I/O Addresses & Soft Switches:
;                      ;Range [(49152~49183)=($C000~$C01F)];
;                      ;#IOADR/256=$C0 is used to Set RAM I/O Vectors.
; ==============================================================================
; KBD        EQU $C000 ;=($C00X); Keyboard Input Register: Gets set to a Key's 
;                      ;High-ASCII Value when a Key is pressed (e.g., KBD > 127 
;                      ;if any Key has been pressed since last cleared via 
;                      ;KBDSTRB).
; KBDSTRB    EQU $C010 ;=($C01X); Clear Keyboard Strobe: Resets Keyboard Input 
;                      ;Register's high bit (from 1 to 0) so that the next 
;                      ;keypress can set KBD again.
; TAPEOUT    EQU $C020 ;=($C02X); Cassette Data Out: Digital to Analog Audio 
;                      ;Output Toggle; Read Only!--Do NOT Write to these 
;                      ;addresses [(49184~49199)= ($C020~$C02F)] (which are 
;                      ;decoded {hard-wired} as the same single bit location); 
;                      ;Toggles Audio Output  
;                      ;(creates a 'click' on Cassette-Tape recordings).
; SPKR       EQU $C030 ;=($C03X); Speaker Data Out: Digital to Analog Audio
;                      ;Output Toggle; Read Only!--Do NOT Write to these
;                      ;addresses [(49200~49215)=($C030~ $C03F)] (which are
;                      ;decoded {hard-wired} as the same single bitlocation); 
;                      ;Toggles Audio Output  
;                      ;(Your Apple's speaker' clicks' once).
; STROBE     EQU $C040 ; =($C04X); Outputs Strobe Pulse to Game I/O Connector; 
;                      ;Any one of these 16 locations
;                      ;[(49216~49231)=($C040~$C04F)] has the same effect
; ==============================================================================
; TXTCLR     EQU $C050 ;Sets Graphics Mode without Clearing Screen;
;                      ;Resets from Text Mode.
; TXTSET     EQU $C051 ;Sets Text Mode without Resetting Scrolling Window;
;                      ;Resets from Graphics Mode.
; MIXCLR     EQU $C052 ;Sets Full-Screen Graphics Mode;
;                      ;Resets from Mixed Graphics Mode
;                      ;(with 4 lines of text at the bottom of the screen).
; MIXSET     EQU $C053 ;Sets Mixed Text & Graphics Mode
;                      ;(with 4 lines of text at the bottom of the screen).
; LOWSCR     EQU $C054 ;Displays Page 1 without Clearing the Screen.
; HISCR      EQU $C055 ;Displays Page 2 without Clearing the Screen.
; LORES      EQU $C056 ;Resets Page from Hi-Res to Lo-Res/Text Mode.
; HIRES      EQU $C057 ;Resets Page from Lo-Res/Text to Hi-Res Mode.
; ==============================================================================
; Uncorrected Annunciator Labels [1st. of 3 Choices]
; [See: Tech Info Library Article No. 1062: Apple II Hardware:
;       Errata in Apple II Reference Manual (Part 2 of 2)]
; ------------------------------------------------------------------------------
; ;SETAN0    EQU $C058 ;[R/W] * Set AN0: Toggle OFF (0VDC): WRONG!
; ;CLRAN0    EQU $C059 ;[R/W] Reset AN0: Toggle ON (+5VDC): WRONG!
; ;SETAN1    EQU $C05A ;[R/W] * Set AN1: Toggle OFF (0VDC): WRONG!
; ;CLRAN1    EQU $C05B ;[R/W] Reset AN1: Toggle ON (+5VDC): WRONG!
; ;SETAN2    EQU $C05C ;[R/W] * Set AN2: Toggle OFF (0VDC): WRONG!
; ;CLRAN2    EQU $C05D ;[R/W] Reset AN2: Toggle ON (+5VDC): WRONG!
; ;SETAN3    EQU $C05E ;[R/W] * Set AN3: Toggle OFF (0VDC): WRONG!
; ;CLRAN3    EQU $C05F ;[R/W] Reset AN3: Toggle ON (+5VDC): WRONG!
; ==============================================================================
; Corrected Annunciator Labels [2nd. of 3 Choices]
; [See: Tech Info Library Article No. 1062: Apple II Hardware: 
;       Errata in Apple II Reference Manual (Part 2 of 2)]
; ------------------------------------------------------------------------------
; ;CLRAN0    EQU $C058 ;[R/W] Reset AN0: Toggle OFF (0VDC)
; ;SETAN0    EQU $C059 ;[R/W] * Set AN0: Toggle ON (+5VDC)
; ;CLRAN1    EQU $C05A ;[R/W] Reset AN1: Toggle OFF (0VDC)
; ;SETAN1    EQU $C05B ;[R/W] * Set AN1: Toggle ON (+5VDC)
; ;CLRAN2    EQU $C05C ;[R/W] Reset AN2: Toggle OFF (0VDC)
; ;SETAN2    EQU $C05D ;[R/W] * Set AN2: Toggle ON (+5VDC)
; ;CLRAN3    EQU $C05E ;[R/W] Reset AN3: Toggle OFF (0VDC)
; ;SETAN3    EQU $C05F ;[R/W] * Set AN3: Toggle ON (+5VDC)
; ==============================================================================
; Renamed Corrected Annunciator Labels [3rd. of 3 Choices]
; [See: Tech Info Library Article No. 1062: Apple II Hardware: 
;       Errata in Apple II Reference Manual (Part 2 of 2)]
; ------------------------------------------------------------------------------
; AN0OFF     EQU $C058 ;[R/W] CLRAN0: Reset AN0: Toggle OFF (0VDC)
; AN0ON      EQU $C059 ;[R/W] SETAN0: * Set AN0: Toggle ON (+5VDC)
; AN1OFF     EQU $C05A ;[R/W] CLRAN1: Reset AN1: Toggle OFF (0VDC)
; AN1ON      EQU $C05B ;[R/W] SETAN1: * Set AN1: Toggle ON (+5VDC)
; AN2OFF     EQU $C05C ;[R/W] CLRAN2: Reset AN2: Toggle OFF (0VDC)
; AN2ON      EQU $C05D ;[R/W] SETAN2: * Set AN2: Toggle ON (+5VDC)
; AN3OFF     EQU $C05E ;[R/W] CLRAN3: Reset AN3: Toggle OFF (0VDC)
; AN3ON      EQU $C05F ;[R/W] SETAN3: * Set AN3: Toggle ON (+5VDC)
; ==============================================================================
; TAPEIN     EQU $C060 ;=($C068); Cassette Data In:
;                      ;Digital State of Analog Audio Input Signal: 
;                      ;HIGH/ON IF >127, LOW/OFF IF <128.
; ==============================================================================
; PB0        EQU $C061 ;=($C069); Paddle 0 PushButton Switch; 
;                      ;Digital Input 0; HIGH/ON IF >127, LOW/OFF IF <128.
; PB1        EQU $C062 ;=($C06A); Paddle 1 PushButton Switch; 
;                      ;Digital Input 1; HIGH/ON IF >127, LOW/OFF IF <128.
; PB2        EQU $C063 ;=($C06B); Paddle 2 PushButton Switch; 
;                      ;Digital Input 2; HIGH/ON IF >127, LOW/OFF IF <128.
; ------------------------------------------------------------------------------
; PADDL0     EQU $C064 ;=($C06C); Paddle 0 Timer Digital Output State: 
;                      ;Set >127 until Timer expires; 
;                      ;Used To Set Paddl#,X ($C064+X).
; PADDL1     EQU $C065 ;=($C06D); Paddle 1 Timer Digital Output State: 
;                      ;Set >127 until Timer expires.
; PADDL2     EQU $C066 ;=($C06E); Paddle 2 Timer Digital Output State: 
;                      ;Set >127 until Timer expires.
; PADDL3     EQU $C067 ;=($C06F); Paddle 3 Timer Digital Output STATE: 
;                      ;Set >127 until Timer expires.
; ------------------------------------------------------------------------------
; PTRIG      EQU $C070 ;=($C07X); ALL Paddles Trigger; 
;                      ;Restarts ALL Paddle Timers: Sets ALL >127.
; ==============================================================================
; Integrated WOZ Machine (IWM) I/O Locations & Soft Switches
; ------------------------------------------------------------------------------
; IWMPH0OFF  EQU $C080 ;Stepper Motor Control
; IWMPH0ON   EQU $C081 ;Stepper Motor Control
; IWMMOTORON EQU $C089 ;Starts Drive Motor Spinning
; IWMSELDRV1 EQU $C08A ;Selects Drive 1
; IWMQ6OFF   EQU $C08C ;Read
; IWMQ7OFF   EQU $C08E ;Write Protect Sense/Read
; ==============================================================================
; CLRROM     EQU $CFFF ;Signals Peripheral Cards in ALL Slots 
;                      ;to Disable their $C800-$CFFF Extension ROM.
; ==============================================================================
; 
; I wonder (by JPD):
; 
; What if these Slot ROM Address Spaces (Slot-0 to Slot-7 below) were NOT Empty?
; Like the Disk II (5.25" Floppy Disk Drive) Controller Card ROM image in Slot
; 6!  Could we put our own Peripheral Card ROM images in these spaces?  And,
; would they be used by emulators, or ignored by them?  I'm sure that other
; software running on an emulator could use them.
; 
; For example: A Parallel Printer interface card ROM image in Slot 1?  Or, a
; Super Serial Card ROM image in Slot 2?  Or, both?  And, a 3.5" Floppy Disk
; Drive Controller Card ROM image in Slot 5?  [Would an Integer BASIC Language
; or Slot 0 RAM/ROM Card image work?--Or, would Emulator Hardware I/O implemen-
; tations interfere with it?]
; 
; Also: Do Apple II Plus emulators (like the Agat Emulator or AppleWin) put ROM
; images corresponding to the user's configuation choices in these spaces while
; they are running?
; 
; Another idea: What if the Apple II RAM/ROM image was for the full 64K of
; Memory?--Filled with eveything you want your emulated Apple II to start with? 
; The image in the memory of your modern computer running your Apple II Emulator
; of choice would then just need to be manipulated.--Your emulator would be
; manipulating the bits and bytes in this Apple II RAM/ROM image in memory like
; a real Apple II 6502 microprocessor does with its RAM space (48K of Main RAM
; +16K of Aux RAM/ROM {SW/HW/FW}).--[Is this how emulators really work?]
; 
; ==============================================================================
; Input/Output Address Space (IOADR)=($C000-$C0FF)  [See also: APPLE2.ROM.sym65]
; OR--> Slot 0 Address Space (SLOT0)=($C000-$C0FF)    [Only in APPLE2.ROM image]
; ==============================================================================
KBD             DS    16,$00          ;~($C00X)[R] Keyboard Input Register
KBDSTRB         DS    16,$00          ;~($C01X)[W] Clear KBD Strobe (KBD<128)
TAPEOUT         DS    16,$00          ;~($C02X)[R] Toggle Cassette Data Output
SPKR            DS    16,$00          ;~($C03X)[R/W] Toggle Speaker Data Output
STROBE          DS    16,$00          ;~($C04X) Output Game Socket Strobe Pulse
; ==============================================================================
; $C05X I/O Space:
; ==============================================================================
TXTCLR          DFB   $00             ;[R/W] Set Graphics Display Mode
TXTSET          DFB   $00             ;[R/W] Set Text Only Display Mode
MIXCLR          DFB   $00             ;[R/W] Set Full Screen Graphics/Text Mode
MIXSET          DFB   $00             ;[R/W] Set Mixed Graphics & Text Mode
TXTPAGE1        DFB   $00             ;[R/W] Display Text Page1 (R/W Main V-RAM)
TXTPAGE2        DFB   $00             ;[R/W] Display Text Page2 (R/W Aux V-RAM)
LORES           DFB   $00             ;[R/W] Reset HiRes Mode to LoRes/Text Mode
HIRES           DFB   $00             ;[R/W] Reset LoRes/Text Mode to HiRes Mode
; ==============================================================================
; Renamed Corrected Annunciator Labels [3rd. of 3 Choices]--[See Above]
; [See: Tech Info Library Article No. 1062: Apple II Hardware:
;       Errata in Apple II Reference Manual (Part 2 of 2)]
; ------------------------------------------------------------------------------
AN0OFF          DFB   $00             ;[R/W] CLRAN0: Reset AN0: Toggle OFF (0VDC)
AN0ON           DFB   $00             ;[R/W] SETAN0: * Set AN0: Toggle ON (+5VDC)
AN1OFF          DFB   $00             ;[R/W] CLRAN1: Reset AN1: Toggle OFF (0VDC)
AN1ON           DFB   $00             ;[R/W] SETAN1: * Set AN1: Toggle ON (+5VDC)
AN2OFF          DFB   $00             ;[R/W] CLRAN2: Reset AN2: Toggle OFF (0VDC)
AN2ON           DFB   $00             ;[R/W] SETAN2: * Set AN2: Toggle ON (+5VDC)
AN3OFF          DFB   $00             ;[R/W] CLRAN3: Reset AN3: Toggle OFF (0VDC)
AN3ON           DFB   $00             ;[R/W] SETAN3: * Set AN3: Toggle ON (+5VDC)
; ==============================================================================
; $C06X I/O Space:
; ==============================================================================
TAPEIN          DFB   $00             ;+($C068)[R] Cassette Data Input
PB0             DFB   $00             ;+($C069)[R] Paddle 0 Pushbutton Switch
PB1             DFB   $00             ;+($C06A)[R] Paddle 1 Pushbutton Switch
PB2             DFB   $00             ;+($C06B)[R] Paddle 2 Pushbutton Switch
PADDL0          DFB   $00             ;+($C06C)[R] Paddle 0 Analog Input
PADDL1          DFB   $00             ;+($C06D)[R] Paddle 1 Analog Input
PADDL2          DFB   $00             ;+($C06E)[R] Paddle 2 Analog Input
PADDL3          DFB   $00             ;+($C06F)[R] Paddle 3 Analog Input
; ------------------------------------------------------------------------------
TAPEIN_X        DFB   $00             ;+($C060)[R] Cassette Data Input
PB0_X           DFB   $00             ;+($C061)[R] Paddle 0 Pushbutton Switch
PB1_X           DFB   $00             ;+($C062)[R] Paddle 1 Pushbutton Switch
PB2_X           DFB   $00             ;+($C063)[R] Paddle 2 Pushbutton Switch
PADDL0_X        DFB   $00             ;+($C064)[R] Paddle 0 Analog Input
PADDL1_X        DFB   $00             ;+($C065)[R] Paddle 1 Analog Input
PADDL2_X        DFB   $00             ;+($C066)[R] Paddle 2 Analog Input
PADDL3_X        DFB   $00             ;+($C067)[R] Paddle 3 Analog Input
; ==============================================================================
; 
PTRIG           DS    16,$00          ;~($C07X)[R/W] Reset All Paddles Trigger
; 
; ==============================================================================
; Integrated WOZ Machine (IWM) I/O Locations & Soft Switches
; ==============================================================================
; 
IWMPH0OFF       DFB   $00             ;Stepper Motor Control
IWMPH0ON        DFB   $00             ;Stepper Motor Control
MTSPC3          DS    7,$00           ;ROM Image Empty Space (MTSPC3)!
IWMMOTORON      DFB   $00             ;Starts Drive Motor Spinning
IWMSELDRV1      DFB   $00             ;Selects Drive 1
MTSPC4          DFB   $00             ;ROM Image Empty Space (MTSPC4)!
IWMQ6OFF        DFB   $00             ;Read
MTSPC5          DFB   $00             ;ROM Image Empty Space (MTSPC5)!
IWMQ7OFF        DFB   $00             ;Write Protect Sense/Read  
MTSPC6          DS    113,$00         ;ROM Image Empty Space (MTSPC6)!
; 
; ==============================================================================
; Slot 1 Address Space (SLOT1)=($C100-$C1FF)
; ==============================================================================
; 
SLOT1           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; Slot 2 Address Space (SLOT2)=($C200-$C2FF)
; ==============================================================================
; 
SLOT2           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; Slot 3 Address Space (SLOT3)=($C300-$C3FF)
; ==============================================================================
; 
SLOT3           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; Slot 4 Address Space (SLOT4)=($C400-$C4FF)
; ==============================================================================
; 
SLOT4           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; Slot 5 Address Space (SLOT5)=($C500-$C5FF)
; ==============================================================================
; 
SLOT5           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; Slot 6 Address Space (SLOT6)=($C600-$C6FF)
; ==============================================================================
; Disk II (5.25" Floppy Disk Drive) Controller Card ROM (BOOT0 Code)
; Reads the BOOT1 code from track 0, sector 0, and jumps to it.
; ------------------------------------------------------------------------------
; This code is a copy (or vice-versa) of the $B600-$B6FF Address Space.  It does
; not need to be analyzed twice, so it is densely packed there (above).
; ------------------------------------------------------------------------------
; [Comments in this section were mostly by Andy McFadden (appended by me: JPD)]
; ==============================================================================
; 
; SLOT6        EQU    $C600          ;Slot 6 Address Space (SLOT6)=($C600-$C6FF)
; 
; ==============================================================================
; 
DISK2ROM        LDX   #$20            ;AKA: SLOT6; SLOT6ROM; & DISK2ROM
                LDY   #$00            ;"$20 $00 $03" is the controller signature
                LDX   #$03
; 
; ==============================================================================
; Generate a decoder table for 6+2 encoded data.
; 
; This stores the values $00-$3F in a table on page 3.  The byte values that
; will be decoded are non-consecutive, so the decoder entries occupy various
; locations from $36C to $3D5.  Nearby bytes are left unchanged.
; 
; We want 64 values that have the high bit set and don't have two consecutive 0
; bits.  This is required by the disk hardware.  There are 70 possible values,
; so we also mandate that there are two adjacent 1 bits, excluding bit 7.  (Note
; that $D5 and $AA, used to identify sector headers, do not meet these criteria,
; which means they never appear in the encoded data.)
; 
; In the code below, a ASL+BIT+BCS test checks for adjacent 1 bits: if no two
; are adjacent, the BIT test will be zero.  If the high bit is set, ASL will set
; the carry.
; 
; When we ORA the original and shifted values together, if there were three 
; adjacent 0 bits, there will still be at least two adjacent 0 bits.  We EOR to
; invert the bits, and then look for two adjacent 1 bits.  We do this by just
; shifting right until a 1 bit shifts into the carry, and if the A-Reg is
; nonzero we know there were at least two 1 bits.  We need to ignore the bits on
; the ends: the nonzero MSB (high bit) was handled earlier, and the LSB (low
; bit) can false-positive because ASL always shifts a 0 in (making it look like
; a 0 in the low bit is adjacent to another 0), so we just mask those off with
; the AND.
; 
; For example, we want to decode $A6 to $07.  Y=$07 when X=$26...
; 
;   TXA --> 0010 0110
;   ASL --> 0100 1100 C=0 (high bit is clear)
;   BIT -->           Z=0 (only possible with adjacent bits)
;   ORA --> 0110 1110     (adjacent 0 bits become visible)
;   EOR --> 1001 0001     (turn them into 1 bits)
;   AND --> 0001 0000     (ignore the hi/lo)
;   LSR --> 0000 1000     (repeat until A=0 C=1)
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; Make Decoder/Conversion Table
; ------------------------------------------------------------------------------
; 
MKDCTBL         STX   IWMBITS         ;Save Bits for Bit Comparison
                TXA                   ;Gets incremented (but it started at #3)
                ASL   A               ;Shift High-Bit Left into Carry Flag
                BIT   IWMBITS         ;Does shifted version overlap?
                BEQ   REJECT          ;NO: Doesn't have two adjacent 1 bits
                ORA   IWMBITS         ;YES, continue on: Merge
                EOR   #%11111111      ;Invert Bits
                AND   #%01111110      ;Clear High & Low Bits
; 
; ------------------------------------------------------------------------------
; Check for Double Zeroes
; ------------------------------------------------------------------------------
; 
CHKDBL0S        BCS   REJECT          ;Initial High- or Adjacent 0-Bits were Set
                LSR   A               ;Shift Low-Bit Right into Carry Flag
                BNE   CHKDBL0S        ;Loop If more 1 Bits are in the Byte
; ------------------------------------------------------------------------------
; Loops while Z-Flag=0 (or while resultant A-Reg<>0), or [logically equivalent]
; Loops until Z-Flag=1 (or until resultant A-Reg=0).    
; ------------------------------------------------------------------------------
; Shouldn't this branch be based on the Carry flag, too?  Yes & No! ... 
; BCS starts the loop, so is effectively tested next, after BNE.  The loop is
; done (exited) when BNE drops through or BCS branches out of (or over) it.
; ------------------------------------------------------------------------------
                TYA                   ;We have a winner!  Store Y-Reg in memory.
                STA   CNVTBL,X        ;Actual lookup will be on Hi-Bit Set Bytes,
                INY                   ; so they will be read from CNVTBL-128
REJECT          INX                   ;Try next candidate!?
                BPL   MKDCTBL         ;Loop If [0=<(X-Reg)<128]; it started at #3
; 
; ------------------------------------------------------------------------------
; Prepare the Hardware
; ------------------------------------------------------------------------------
; 
                JSR   IORTS           ;JSR to RTS: Puts Our Address on the STACK
                TSX                   ;Get STACK Pointer
                LDA   STACK,X         ;Get Our Address (High Byte) from STACK
                ASL   A               ;(Assuming no interrupts have happened)
                ASL   A               ;Multiply by 16
                ASL   A               ;(Puts Low Nibble into High Nibble)
                ASL   A               ;[(%nnnn0000)<-(%XXXXnnnn)]~[($60)<-($C6)]
                STA   IWMSLTNDX       ;Keep it [(%SLOT0000)~($60)] Safe!
                TAX                   ;Put 16*SLOT# ($60) into X-Reg
                LDA   IWMQ7OFF,X      ;Set to Read Mode (Write Protect Sense/Read)
                LDA   IWMQ6OFF,X      ;Set to Read Mode (Read)
                LDA   IWMSELDRV1,X    ;Select Drive 1
                LDA   IWMMOTORON,X    ;Start Motor & Spin it Up to Speed
; 
; ------------------------------------------------------------------------------
; Blind-Seek to Track Zero
; ------------------------------------------------------------------------------
; 
                LDY   #80             ;80 Phases (40 Tracks)
FINDT0S0        LDA   IWMPH0OFF,X     ;Turn OFF Phase N
                TYA                   ;Get Phase {2 Phases/Track}
                AND   #3              ;MOD the Phase Number to get 0-3
                ASL   A               ;Double it to 0/2/4/6
                ORA   IWMSLTNDX       ;Add in the Slot Index
                TAX                   ;Put result into X-Reg
                LDA   IWMPH0ON,X      ;Turn ON Phase 0, 1, 2, or 3
                LDA   #86             ;Delay for (26+27*Acc+5*(Acc*Acc))/2 Cycles
                JSR   MON_WAIT        ;Wait 19664 Cycles
                DEY                   ;Next Phase
                BPL   FINDT0S0        ;Loop If [0=<(Y)<128]; it started at #80
;                                     ;A-Reg is 0 when MON_WAIT Returns
;                                     ;So we're looking for Track=0 Sector=0
                STA   IWMDATAPTR      ;Data Destination Ptr, Low; (Write Output)
                STA   IWMSECTOR       ;IWM: Sector to Read
                STA   IWMTRACK        ;IWM: Track to Read
                LDA   #>BOOT1         ;DOS Load Buffer Address ($0800), High Byte
                STA   IWMDATAPTR+1    ;Data Destination Ptr, High; (Write Output)
; 
; ------------------------------------------------------------------------------
; Sector Read routine.
; 
; Read bytes until we find an address header (D5 AA 96) or 
; data header (D5 AA AD), depending on which mode we're in.
; 
; This will also be called by the BOOT1 code read from the floppy disk.
; 
; On entry:
;   X: slot * 16
;   $26-27: data pointer
;   $3d: desired sector
;   $41: desired track
; ------------------------------------------------------------------------------
; 
RDSECT          CLC                   ;Find the Sector to Read
RDSECT0         PHP                   ;Find Data; Rentry for Correct T/S found
RDSECT1         LDA   IWMQ6OFF,X      ;Wait for a byte; Loop-Back Reentry Point
                BPL   RDSECT1         ;No byte yet if [0=<(A-Reg)<128], Loop
RDSECT2         EOR   #$D5            ;Is it $D5?
                BNE   RDSECT1         ;NO, keep looking, Loop
RDSECT3         LDA   IWMQ6OFF,X      ;YES, grab another byte
                BPL   RDSECT3         ;No byte yet if [0=<(A-Reg)<128], Loop
                CMP   #$AA            ;Is it $AA?
                BNE   RDSECT2         ;NO, Loop: check if it is another $D5
                NOP                   ;YES, Delay 2 Cycles
RDSECT4         LDA   IWMQ6OFF,X      ;Grab a third byte
                BPL   RDSECT4         ;No byte yet if [0=<(A-Reg)<128], Loop
                CMP   #$96            ;Is it $96?
                BEQ   RDSAD           ;YES, Read sector's Address Data next
                PLP                   ;Upon entry, did we want Data?
                BCC   RDSECT          ;NO, keep looking, Loop
                EOR   #$AD            ;YES, is it Data Prologue?
                BEQ   RDF62ESD        ;YES if [(A-Reg)=0], Read the Found Data
                BNE   RDSECT          ;NO, keep looking, Loop

; ------------------------------------------------------------------------------
; Read the Sector Address Data
; Four fields, in 4+4 encoding: Volume, Track, Sector, Cecksum
; ------------------------------------------------------------------------------
; 
; Found Address:
RDSAD           LDY   #$03            ;Sector # is the 3rd item in Header
; Address Header Loop:
RDSAD1          STA   IWMTRKFND       ;Store $96, then Volume, then Track
RDSAD2          LDA   IWMQ6OFF,X      ;Read 1st Part, Wait for a byte
                BPL   RDSAD2          ;No byte yet if [0=<(A-Reg)<128], Loop
                ROL   A               ;1st Byte has Bits 7/5/3/1
                STA   IWMBITS         ;Save it for Merging
RDSAD3          LDA   IWMQ6OFF,X      ;Read 2nd Part, Wait for a byte
                BPL   RDSAD3          ;No byte yet if [0=<(A-Reg)<128], Loop
                AND   IWMBITS         ;Merge the Bytes/Bits
                DEY                   ;Is this the 3rd item?
                BNE   RDSAD1          ;NO, keep looking, Loop
                PLP                   ;YES, pull P-Reg to keep STACK in balance
                CMP   IWMBITS+1       ;Is this the Sector we want?
                BNE   RDSECT          ;NO, go back to looking for addresses
                LDA   IWMTRKFND       ;YES, this is the Sector we want!
                CMP   A3H             ;But, is this the Track we want?
                BNE   RDSECT          ;NO, go back to looking for addresses
                BCS   RDSECT0         ;YES, Correct T/S, Go Find Data; Always
; 
; ------------------------------------------------------------------------------
; Read the 6+2 encoded sector data.
; 
; Values range from $96 - $FF.  They must have the high bit set, and must not
; have three consecutive zeroes.
; 
; The data bytes are written to disk with a rolling XOR to compute a checksum,
; so we read them back the same way.  We keep this in the A-Reg for the
; duration.  The actual value is always in the range [$00 to $3F=(%00111111)]
; (six-bits).
; 
; On entry:
;   (A-Reg)=($00)
; ------------------------------------------------------------------------------
; 
RDF62ESD        LDY   #$56            ;Read the Found 6+2 Encoded Sector Data
; 
; ------------------------------------------------------------------------------
; Read Twos Loop:                     ;Read 86 Bytes of Data into $0300-$0355
;                                     ;Each byte has 3 sets of 2 bits, encoded
; ------------------------------------------------------------------------------
; 
RDTWOS          STY   IWMBITS         ;Save Byte-Counter
RDTWOS1         LDY   IWMQ6OFF,X      ;Wait for a byte
                BPL   RDTWOS1         ;No byte yet if [0=<(Y-Reg)<128], Loop
                EOR   CNVTBL-128,Y    ;Conversion-Data XOR A-Reg --> A-Reg
; [($2D6)=($356-$80)=(CNVTBL-128)]    ;1st Entry is at [($2D6+$96)=($36C)]
                LDY   IWMBITS         ;Get Byte-Counter from Safe
                DEY                   ;Count Down to Zero (from 86)
                STA   TWOSBUFF,Y      ;Save A-Reg in the Page 3 Buffer
                BNE   RDTWOS          ;Loop if (Y-Reg)<>0
; 
; ------------------------------------------------------------------------------
; Read Sixes Loop:                    ;Read 256 Bytes of Data into $800-$8FF
;                                     ;Each byte has the high 6 bits, encoded
; ------------------------------------------------------------------------------
; 
RDSIXES         STY   IWMBITS         ;Save Byte-Counter
RDSIXES1        LDY   IWMQ6OFF,X      ;Wait for a byte
                BPL   RDSIXES1        ;No byte yet if [0=<(Y-Reg)<128], Loop
                EOR   CNVTBL-128,Y    ;Conversion-Data XOR A-Reg --> A-Reg
; [($2D6)=($356-$80)=(CNVTBL-128)]    ;1st Entry is at [($2D6+$96)=($36C)]
                LDY   IWMBITS         ;Get Byte-Counter from Safe
                STA   (IWMDATAPTR),Y  ;Save A-Reg in the Eventual Data Buffer
                INY                   ;Count Up to 256 (Zero: 256 MOD 256 = 0)
                BNE   RDSIXES         ;Loop if (Y-Reg)<>0
; 
; ------------------------------------------------------------------------------
; Read Checksum Loop:                 ;Read the Checksum Byte
; ------------------------------------------------------------------------------
; 
RDCHKSUM        LDY   IWMQ6OFF,X      ;Wait for a byte
                BPL   RDCHKSUM        ;No byte yet if [0=<(Y-Reg)<128], Loop
                EOR   CNVTBL-128,Y    ;Conversion-Data XOR A-Reg --> A-Reg
; [($2D6)=($356-$80)=(CNVTBL-128)]    ;1st Entry is at [($2D6+$96)=($36c)]
;                                     ;Does Checksum Byte match A-Reg Byte?
;                                     ;NO, BNE: Try to find an Undamaged Sector
;                                     ;YES, BNE does not happen: Drop Through
RDF62ESDX       BNE   RDSECT          ;Loop if (A)<>(0)
; 
; ------------------------------------------------------------------------------
; Decode the 6+2 encoding.  The high 6 bits of each byte are in place, now we
; just need to shift the low 2 bits of each in.
; ------------------------------------------------------------------------------
; 
                LDY   #$00            ;Update 256 Bytes
DCD62ENC        LDX   #$56            ;Run through the 2-bit pieces 3x (86*3=258)
; Decode 6+2 Encoding Loop:
DCD62ENC1       DEX                   ;Count Down to Zero (from 86)
                BMI   DCD62ENC        ;If we hit $02FF, go back to $0355
                LDA   (IWMDATAPTR),Y  ;For each Byte in the Data Buffer...
                LSR   TWOSBUFF,X      ;Grab Low Two Bits from 2sBuff ($300-$355)
                ROL   A               ;Roll them into the Low Two Bits of the Byte
                LSR   TWOSBUFF,X      ;[Doesn't this modify Data in Twos Buffer?]
                ROL   A               ;[Won't we be using this 2sBuff Data again?]
                STA   (IWMDATAPTR),Y  ;Save each Modified Byte in the Data Buffer
                INY                   ;Count Up to 256 (Zero: 256 MOD 256 = 0)
                BNE   DCD62ENC1       ;Loop if (Y-Reg)<>0
; ------------------------------------------------------------------------------
; Advance the data pointer and sector number, and check to see if the sector
; number matches the first byte of BOOT1.  If it does, we're done.  If not, go
; read the next sector.
; ------------------------------------------------------------------------------
                INC   IWMDATAPTR+1    ;Advance the Data Pointer
                INC   IWMSECTOR       ;Advance the Sector Number
                LDA   IWMSECTOR       ;The Sector we would read next
                CMP   BOOT1           ;Is next Sector < BOOT1?
                LDX   IWMSLTNDX       ;Put Slot Number in X-Reg
                BCC   RDF62ESDX       ;YES, get another Sector; Branches again!
; ------------------------------------------------------------------------------
; Boot-Strapping of the BOOT code is done; Now execute the BOOT code
; ------------------------------------------------------------------------------
                JMP   BOOT1+1         ;All done, jump to BOOT1

                HEX   0000000000      ;Spare Bytes
; 
; ==============================================================================
; Slot 7 Address Space (SLOT7)=($C700-$C7FF)
; ==============================================================================
; 
SLOT7           DS    256,$00         ;Slot ROM Space, Empty!
; 
; ==============================================================================
; All Peripheral Card Slots' Shared $C800-$CFFF Extension RAM/ROM Memory Space
; ==============================================================================
; 
ALLSLOTS        DS    1534,$00        ;All Slots RAM/ROM Space, Empty
SLTVTAB         DS    341,$00
SLTGOERR        DS    137,$00
JMPADRTBL       DS    35,$00          ;Empty Space; Base Address (UNFNC-164) for
;                                     ; Index into Unary Functions Address Table
CLRROM          DFB   $00             ;Tell Slots to Disable their Extension ROM
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($D000-$D7FF): ROM Socket $D0 on a real Apple II Plus.
; ==============================================================================
; The $D0 ROM was Programmmers Aid #1 ROM in Apple II (not in Apple II Plus)!
; ------------------------------------------------------------------------------
; The AGAT emulator APPLE2.ROM image (12.0 KB, 7/4/1996) starts here; it is
; identical to AppleWin's APPLE2.ROM image (20.0 KB, 3/27/1995) from here on.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft: Floating Point BASIC for the Apple II
; Copyright (c) 1978 by Apple Computer, Inc.  All Rights Reserved.
; Written by Microsoft, Inc. and Extended by R. Wigginton.
; ==============================================================================
; Part A, $D000-$DD66: Input Parsing, Routine Addressing, For-Next Loops, etc.
; Part B, $DD67-$E79F: Formula Evaluation, Pointer Locating, & String Handling
; Part C, $E7A0-$F1D4: Floating Point Math Routines
; Part D, $F1D5-$F7FF: Graphics Display Routines, etc.
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; ==============================================================================
; To see: "How Applesoft BASIC Programs Are Arranged In Memory",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 5 to 8
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Program Lines Are Constructed", 
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", page 15
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Program Varables* Are Structured"
;         *(Reals {Floating Point}, Integers, Strings, Functions, and Arrays),
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 21 to 24
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Floating Point Math, Constants, & FAC Behave",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 52 to 54
; ==============================================================================
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; 
; 
; ==============================================================================
;                        Applesoft Zero Page Usage Map:
; ==============================================================================
; 
;                Key: X = General usage
;                     . = Not used
;                     C = Set by cold start but not used
;                     H = Used by high resolution grraphics only
;                     G = Used by low resolution grraphics only
;                     T = Used by tape routines only
;                     D = Important DOS use
;                     $ = Used by STR$ routine only
;                     U = Set up for USR, not otherwise used
;                     8 = Used by some 80 column cards
; 
; ==============================================================================
; 
;                         0 1 2 3 4 5 6 7 8 9 A B C D E F
;                         -------------------------------
;                     0X: C C C C C C . . . . U U U X X X
;                     1X: X X X X X X X . . . H H H H 8 8
;                     2X: X X X X X X H H X X X X G G X T
;                     3X: G . X X . X X X X X . . T T T T
;                     4X: D D D D D D D D D D . . . . X X
;                     5X: X X X X X X X X X X X X X X X X
;                     6X: X X X X X X X X X X X X X X X X
;                     7X: X X X X X X X X X X X X X X X X
;                     8X: X X X X X X X X X X X X X X . X
;                     9X: X X X X X X X X X X X X X X X X
;                     AX: X X X X X X X X X X X X X X X X
;                     BX: X X X X X X X X X X X X X X X X
;                     CX: X X X X X X X X X X X X X X . .
;                     DX: H H H H H H X . X . X X X X X X
;                     EX: H H H H H H H H H H H . . . . .
;                     FX: X X X X X X X X X H . . . . . $
;                         -------------------------------
;                         0 1 2 3 4 5 6 7 8 9 A B C D E F
; 
; ==============================================================================
; 
; 
; ==============================================================================
; Preamble about the Applesoft Floating Point Accumulators
; [FAC & ARG (6 Bytes each)]:
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Floating Point Math, Constants, & FAC Behave",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 52 to 54
; ------------------------------------------------------------------------------
; Significand is the Most Significant Part of a Number; Mantissa is the
; fractional part of a Decimal Number, to the right of the decimal point:
; ==============================================================================
; FAC      EQU  $9D  ;Primary Floating Point Accumulator    (6B)
; ;FACX    EQU  $9D  ;1st FAC Exponent [Signed =(-128..+0..+127)]
; ;FACT    EQU  $9E  ;1st FAC Mantissa, Top [Signed = (-128..+0..+127)]
; ;FACH    EQU  $9F  ;1st FAC Mantissa, High    [Unsigned = (+0..+255)]
; ;FACM    EQU  $A0  ;1st FAC Mantissa, Middle  [Unsigned = (+0..+255)]
; ;FACL    EQU  $A1  ;1st FAC Mantissa, Low     [Unsigned = (+0..+255)]
; FACSIGN  EQU  $A2  ;1st FAC Unpacked Sign (msb) [Used by FP Math Package]
; ;Packed format does not use FACSIGN; the Binary Mantissa msb holds the sign;
; ;but, to print a minus sign when Printing FAC ($ED2EG), its msb must be set.
; ------------------------------------------------------------------------------
; ARG      EQU  $A5  ;Secondary Floating Point Accumulator  (6B)
; ;ARGX    EQU  $A5  ;2nd FAC Exponent [Signed = (-128..+0..+127)]
; ;ARGT    EQU  $A6  ;2nd FAC Mantissa, Top [Signed = (-128..+0..+127)]
; ;ARGH    EQU  $A7  ;2nd FAC Mantissa, High    [Unsigned = (+0..+255)]
; ;ARGM    EQU  $A8  ;2nd FAC Mantissa, Middle  [Unsigned = (+0..+255)]
; ;ARGL    EQU  $A9  ;2nd FAC Mantissa, Low     [Unsigned = (+0..+255)]
; ARGSIGN  EQU  $AA  ;2nd FAC Unpacked Sign (msb) [Used by FP Math Package]
; ;Packed format does not use ARGSIGN; the Binary Mantissa msb holds the sign.
; ==============================================================================
; ARGEXT   EQU  $92  ;----- ARG Extra Precision Byte for FP Op's  (1B)
; TEMP1    EQU  $93  ;~$97: Packed FAC Temp Save Area & FP Math Register
; TEMP2    EQU  $98  ;~$9C: Packed FAC Temp Save Area & FP Math Register
; TEMP3    EQU  $8A  ;~$8E: Packed FAC Temp Save Area & FP Math Register
; FACEXT   EQU  $AC  ;----- FAC Extra Precision Byte for FP Op's  (1B)
; RNDSEED  EQU  $C9  ;~$CD: Packed FAC Floating Point Random Number Seed
; ==============================================================================
; Packed FAC Numberic Constant Exanples:
; ==============================================================================
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit: 
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;  | Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific |
;  | ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec |
;  |========================|=====|================|===========|==============|
;  |NRM_QTR  HEX 7F00000000 |(00) |$7F-$80=$FF= -1 |$.00000000 |+2.50000000E-1|
;  |POS_QTR  HEX 7F80000000 |(00) |$7F-$80=$FF= -1 |$.80000000 |+2.50000000E-1|
;  |NEG_QTR  HEX 7F80000000 |(FF) |$7F-$80=$FF= -1 |$.80000000 |-2.50000000E-1|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_HALF HEX 8000000000 |(00) |$80-$80=$00= +0 |$.00000000 |+5.00000000E-1|
;  |POS_HALF HEX 8080000000 |(00) |$80-$80=$00= +0 |$.80000000 |+5.00000000E-1|
;  |NEG_HALF HEX 8080000000 |(FF) |$80-$80=$00= +0 |$.80000000 |-5.00000000E-1|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_ONE  HEX 8100000000 |(00) |$81-$80=$01= +1 |$.00000000 |+1.00000000E+0|
;  |POS_ONE  HEX 8180000000 |(00) |$81-$80=$01= +1 |$.80000000 |+1.00000000E+0|
;  |NEG_ONE  HEX 8180000000 |(FF) |$81-$80=$01= +1 |$.80000000 |-1.00000000E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_TEN  HEX 8420000000 |(00) |$84-$80=$04= +4 |$.20000000 |+1.00000000E+1|
;  |POS_TEN  HEX 84A0000000 |(00) |$84-$80=$04= +4 |$.A0000000 |+1.00000000E+1|
;  |NEG_TEN  HEX 84A0000000 |(FF) |$84-$80=$04= +4 |$.A0000000 |-1.00000000E+1|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_SQRH HEX 803504F334 |(00) |$80-$80=$00= +0 |$.3504F334 |+2.07106781E-1|
;  |POS_SQRH HEX 80B504F334 |(00) |$80-$80=$00= +0 |$.B504F334 |+7.07106781E-1|
;  |NEG_SQRH HEX 80B504F334 |(FF) |$80-$80=$00= +0 |$.B504F334 |-7.07106781E-1|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_SQR2 HEX 813504F334 |(00) |$81-$80=$01= +1 |$.3504F334 |+0.41421356E+0|
;  |POS_SQR2 HEX 81B504F334 |(00) |$81-$80=$01= +1 |$.B504F334 |+1.41421356E+0|
;  |NEG_SQR2 HEX 81B504F334 |(FF) |$81-$80=$01= +1 |$.B504F334 |-1.41421356E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_LN2  HEX 80317217F8 |(00) |$80-$80=$00= +0 |$.317217F8 |+1.93147181E-1|
;  |POS_LN2  HEX 80B17217F8 |(00) |$80-$80=$00= +0 |$.B17217F8 |+6.93147181E-1|
;  |NEG_LN2  HEX 80B17217F8 |(FF) |$80-$80=$00= +0 |$.B17217F8 |-6.93147181E-1|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_LOGE HEX 8138AA3B29 |(00) |$81-$80=$01= +1 |$.38AA3B29 |+0.44269504E+0|
;  |POS_LOGE HEX 81B8AA3B29 |(00) |$81-$80=$01= +1 |$.B8AA3B29 |+1.44269504E+0|
;  |NEG_LOGE HEX 81B8AA3B29 |(FF) |$81-$80=$01= +1 |$.B8AA3B29 |-1.44269504E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_PID2 HEX 81490FDAA2 |(00) |$81-$80=$01= +1 |$.490FDAA2 |+0.57079633E+0|
;  |POS_PID2 HEX 81C90FDAA2 |(00) |$81-$80=$01= +1 |$.C90FDAA2 |+1.57079633E+0|
;  |NEG_PID2 HEX 81C90FDAA2 |(FF) |$81-$80=$01= +1 |$.C90FDAA2 |-1.57079633E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_PI   HEX 82490FDAA2 |(00) |$82-$80=$02= +2 |$.490FDAA2 |+1.14159265E+0|
;  |POS_PI   HEX 82C90FDAA2 |(00) |$82-$80=$02= +2 |$.C90FDAA2 |+3.14159266E+0|
;  |NEG_PI   HEX 82C90FDAA2 |(FF) |$82-$80=$02= +2 |$.C90FDAA2 |-3.14159266E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_PIM2 HEX 83490FDAA2 |(00) |$83-$80=$03= +3 |$.490FDAA2 |+2.28318531E+0|
;  |POS_PIM2 HEX 83C90FDAA2 |(00) |$83-$80=$03= +3 |$.C90FDAA2 |+6.28318531E+0|
;  |NEG_PIM2 HEX 83C90FDAA2 |(FF) |$83-$80=$03= +3 |$.C90FDAA2 |-6.28318531E+0|
;  |------------------------|-----|----------------|-----------|--------------|
;  |BAD32768 HEX 9080000020 |(FF) |$90-$80=$10=+16 |$.80000020 |-3.27680005E+4|
;  |POS32768 HEX 9080000000 |(00) |$90-$80=$10=+16 |$.80000000 |+3.27680000E+4|
;  |NEG32768 HEX 9080000000 |(FF) |$90-$80=$10=+16 |$.80000000 |-3.27680000E+4|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_E8M1 HEX 9B3EBC1FFD |(00) |$9B-$80=$18=+24 |$.3EBC1FFD |+3.28911359E+7|
;  |POS_E8M1 HEX 9BBEBC1FFD |(00) |$9B-$80=$18=+24 |$.BEBC1FFD |+9.99999999E+7|
;  |NEG_E8M1 HEX 9BBEBC1FFD |\FF) |$9B-$80=$18=+24 |$.BEBC1FFD |-9.99999999E+7|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_E9M1 HEX 9E6E6B27FD |(00) |$9E-$80=$1E=+30 |$.6E6B27FD |+4.63129087E+8|
;  |POS_E9M1 HEX 9EEE6B27FD |(00) |$9E-$80=$1E=+30 |$.EE6B27FD |+9.99999999E+8|
;  |NEG_E9M1 HEX 9EEE6B27FD |(FF) |$9E-$80=$1E=+30 |$.EE6B27FD |-9.99999999E+8|
;  |------------------------|-----|----------------|-----------|--------------|
;  |NRM_E9   HEX 9E6E6B2800 |(00) |$9E-$80=$1E=+30 |$.6E6B2800 |+4.63129088E+8|
;  |POS_E9   HEX 9EEE6B2800 |(00) |$9E-$80=$1E=+30 |$.EE6B2800 |+1.00000000E+9|
;  |NEG_E9   HEX 9EEE6B2800 |(FF) |$9E-$80=$1E=+30 |$.EE6B2800 |-1.00000000E+9|
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
;           pi/2 = 1.570796327; pi = 3.141592654; 2*pi = 6.283185308
;          pi = 4*ATN(1)-(1E-9) = 3.14159265 <> 4*ATN(1) = 3.14159266
; ==============================================================================
; Plugging NRM_CONS into & Printing FAC [*9D:XX XX XX XX XX XX <CR> *ED2EG]--
; [You can use the AppleWin Monitor (CALL -151) or Debugger (F7) to do this.]
; ------------------------------------------------------------------------------
; Seems that there is a problem printing numbers when the mantissa is zero.
; Setting the Mantissa sign bit (adding $80000000) fixes all these problems:
; ------------------------------------------------------------------------------
; Plugging in NRM_QTR  #'s results in nothing being printed!
; Plugging in NRM_HALF #'s results in nothing being printed!
; Plugging in NRM_ONE  #'s results in a Blank Line being printed, not a 1!
; Plugging in NRM_TEN  #'s results in a 2 being printed, not a 10!
; Plugging in NRM_SQRH #'s results in (SQR(1/2))-(1/2) being printed!
; Plugging in NRM_SQR2 #'s results in (SQR(2))-(1) being printed!
; Plugging in NRM_LN2  #'s results in (LN(2))-(1/2) being printed!
; Plugging in NRM_LOGE #'s results in (LOG(base 2)(e))-(1) being printed!
; Plugging in NRM_PID2 #'s results in (PI/2)-(1) being printed!
; Plugging in NRM_PI   #'s results in (PI)-(2) being printed!
; Plugging in NRM_PIM2 #'s results in (PI*2)-(4) being printed!
; Plugging in BAD32768 #'s results in a non-integer FP value being printed!
; Plugging in NRM_E8M1 #'s results in a non-integer FP value being printed!
; Plugging in NRM_E9M1 #'s results in a non-integer FP value being printed!
; Plugging in NRM_E9   #'s results in a non-integer FP value being printed!
; ------------------------------------------------------------------------------
; Apparently, all NRM_Constant Mantissas have had 1/2 subtracted from them.
; They are the actual (renamed) Normalized Contants used in Applesoft BASIC!
; IIRC, this was done to facilitate proper rounding of Floating Point numbers.
; ==============================================================================
; 
; 
; ==============================================================================
; Applesoft BASIC Tokens:                          [AKA: TKNMTBL; (Count = 107)]
;    [Keywords, Statements, and (Math, String, & other types of) Functions]
; ==============================================================================
; Constants   EQU   $nn ;These are Constants, NOT Zero Page Equates
; TOK_*       EQU   $nn ;Originally: TOKEN.*
; ==============================================================================
; TOK_END     EQU   $80 ;Token: "END" Program Control Statement
; TOK_FOR     EQU   $81 ;Token: "FOR" Program Control Statement
; TOK_NEXT    EQU   $82 ;Token: "NEXT" Program Control Statement
; TOK_DATA    EQU   $83 ;Token: "DATA" Data Assignment Statement
; TOK_INPUT   EQU   $84 ;Token: "INPUT" Input Statement
; TOK_DEL     EQU   $85 ;Token: "DEL" Prgrm-Lines Removal Statement
; TOK_DIM     EQU   $86 ;Token: "DIM" Assignment Statement
; TOK_READ    EQU   $87 ;Token: "READ" Data Input Statement
; TOK_GR      EQU   $88 ;Token: "GR" Graphics Display Statement
; TOK_TEXT    EQU   $89 ;Token: "TEXT" Text Display Statement
; TOK_PR      EQU   $8A ;Token: "PR#" Set Output Statement
; TOK_IN      EQU   $8B ;Token: "IN#" Set Input Statement
; TOK_CALL    EQU   $8C ;Token: "CALL" Program Control Statement
; TOK_PLOT    EQU   $8D ;Token: "PLOT" Graphics Drawing Statement
; TOK_HLIN    EQU   $8E ;Token: "HLIN" Graphics Drawing Statement
; TOK_VLIN    EQU   $8F ;Token: "VLIN" Graphics Drawing Statement
; TOK_HGR2    EQU   $90 ;Token: "HGR2" Graphics Display Statement
; TOK_HGR     EQU   $91 ;Token: "HGR" Graphics Display Statement
; TOK_HCOLOR  EQU   $92 ;Token: "HCOLOR=" Assignment Statement
; TOK_HPLOT   EQU   $93 ;Token: "HPLOT" Graphics Drawing Statement
; TOK_DRAW    EQU   $94 ;Token: "DRAW" Graphics Drawing Statement
; TOK_XDRAW   EQU   $95 ;Token: "XDRAW" Graphics Drawing Statement
; TOK_HTAB    EQU   $96 ;Token: "HTAB" Cursor Position Statement
; TOK_HOME    EQU   $97 ;Token: "HOME" Text Display Statement
; TOK_ROT     EQU   $98 ;Token: "ROT=" Assignment Statement
; TOK_SCALE   EQU   $99 ;Token: "SCALE=" Assignment Statement
; TOK_SHLOAD  EQU   $9A ;Token: "SHLOAD" Data Input Statement
; TOK_TRACE   EQU   $9B ;Token: "TRACE" Debugging ON Statement
; TOK_NOTRACE EQU   $9C ;Token: "NOTRACE" Debugging OFF Statement
; TOK_NORMAL  EQU   $9D ;Token: "NORMAL" Text Display Statement
; TOK_INVERSE EQU   $9E ;Token: "INVERSE" Text Display Statement
; TOK_FLASH   EQU   $9F ;Token: "FLASH" Text Display Statement
; TOK_COLOR   EQU   $A0 ;Token: "COLOR=" Assignment Statement
; TOK_POP     EQU   $A1 ;Token: "POP" Program Control Statement
; TOK_VTAB    EQU   $A2 ;Token: "VTAB" Cursor Position Statement
; TOK_HIMEM   EQU   $A3 ;Token: "HIMEM:" Assignment Statement
; TOK_LOMEM   EQU   $A4 ;Token: "LOMEM:" Assignment Statement
; TOK_ONERR   EQU   $A5 ;Token: "ONERR" Program Control Statement
; TOK_RESUME  EQU   $A6 ;Token: "RESUME" Program Control Statement
; TOK_RECALL  EQU   $A7 ;Token: "RECALL" Arrays from Tape Statement
; TOK_STORE   EQU   $A8 ;Token: "STORE" Arrays to Tape Statement
; TOK_SPEED   EQU   $A9 ;Token: "SPEED=" Assignment Statement
; TOK_LET     EQU   $AA ;Token: "LET" Assignment Statement
; TOK_GOTO    EQU   $AB ;Token: "GOTO" Program Control Statement
; TOK_RUN     EQU   $AC ;Token: "RUN" Program Control Statement
; TOK_IF      EQU   $AD ;Token: "IF" Conditional Statement
; TOK_RESTORE EQU   $AE ;Token: "RESTORE" Data Reset Statement
; TOK_AMPER   EQU   $AF ;Token: "&" (Ampersand) User-Cmd. Statement
; TOK_GOSUB   EQU   $B0 ;Token: "GOSUB" Program Control Statement
; TOK_RETURN  EQU   $B1 ;Token: "RETURN" Program Control Statement
; TOK_REM     EQU   $B2 ;Token: "REM" Prgrm-Documentation Statement
; TOK_STOP    EQU   $B3 ;Token: "STOP" Program Control Statement
; TOK_ON      EQU   $B4 ;Token: "ON" Program Control Statement
; TOK_WAIT    EQU   $B5 ;Token: "WAIT" Program Control Statement
; TOK_LOAD    EQU   $B6 ;Token: "LOAD" Programs from Tape Statement
; TOK_SAVE    EQU   $B7 ;Token: "SAVE" Programs to Tape Statement
; TOK_DEF     EQU   $B8 ;Token: "DEF" Function Assignment Statement
; TOK_POKE    EQU   $B9 ;Token: "POKE" Set Memory Address Function
; TOK_PRINT   EQU   $BA ;Token: "PRINT" Output Statement
; TOK_CONT    EQU   $BB ;Token: "CONT" Statement
; TOK_LIST    EQU   $BC ;Token: "LIST" Pgm-Lines Display Statement
; TOK_CLEAR   EQU   $BD ;Token: "CLEAR" Reset Everything Statement
; TOK_GET     EQU   $BE ;Token: "GET" Input Statement
; TOK_NEW     EQU   $BF ;Token: "NEW" Program Creation Statement
; TOK_TAB     EQU   $C0 ;Token: "TAB(" Cursor Position Statement
; TOK_TO      EQU   $C1 ;Token: "TO" Program Control Statement
; TOK_FN      EQU   $C2 ;Token: "FN" Function Assignment Statement
; TOK_SPC     EQU   $C3 ;Token: "SPC(" Cursor Position Statement
; TOK_THEN    EQU   $C4 ;Token: "THEN" Conditional Statement
; TOK_AT      EQU   $C5 ;Token: "AT" Graphics Drawing Statement
; TOK_NOT     EQU   $C6 ;Token: "NOT" Conditional Statement
; TOK_STEP    EQU   $C7 ;Token: "STEP" Conditional Statement
; TOK_PLUS    EQU   $C8 ;Token: "+" (Plus) Math Function
; TOK_MINUS   EQU   $C9 ;Token: "-" (Minus) Math Function
; TOK_MULT    EQU   $CA ;Token: "*" (Multiply) Math Function
; TOK_DIV     EQU   $CB ;Token: "/" (Division) Math Function
; TOK_EXPOP   EQU   $CC ;Token: "^" (Exponent) Math Function
; TOK_AND     EQU   $CD ;Token: "AND" Conditional Statement
; TOK_OR      EQU   $CE ;Token: "OR" Conditional Statement
; TOK_GREATER EQU   $CF ;Token: ">" (Greater Than) Cond. Statement
; TOK_EQUAL   EQU   $D0 ;Token: "=" (Equal To) Cond. Statement
; TOK_LESSER  EQU   $D1 ;Token: "<" (Less Than) Cond. Statement
; TOK_SGN     EQU   $D2 ;Token: "SGN" Math Function
; TOK_INT     EQU   $D3 ;Token: "INT" Math Function
; TOK_ABS     EQU   $D4 ;Token: "ABS" Math Function
; TOK_USR     EQU   $D5 ;Token: "USR" User-Command Statement
; TOK_FRE     EQU   $D6 ;Token: "FRE" Free Memory Statement
; TOK_SCRN    EQU   $D7 ;Token: "SCRN(" LoRes (X,Y) Color Statement
; TOK_PDL     EQU   $D8 ;Token: "PDL" Input Statement
; TOK_POS     EQU   $D9 ;Token: "POS" Get Cursor Position Statement
; TOK_SQR     EQU   $DA ;Token: "SQR" Math Function
; TOK_RND     EQU   $DB ;Token: "RND" Math Function
; TOK_LOG     EQU   $DC ;Token: "LOG" Math Function
; TOK_EXP     EQU   $DD ;Token: "EXP" Math Function
; TOK_COS     EQU   $DE ;Token: "COS" Math Function
; TOK_SIN     EQU   $DF ;Token: "SIN" Math Function
; TOK_TAN     EQU   $E0 ;Token: "TAN" Math Function
; TOK_ATN     EQU   $E1 ;Token: "ATN" Math Function
; TOK_PEEK    EQU   $E2 ;Token: "PEEK" Read Memory Address Function
; TOK_LEN     EQU   $E3 ;Token: "LEN" String Length Function
; TOK_STR     EQU   $E4 ;Token: "STR$" String Function
; TOK_VAL     EQU   $E5 ;Token: "VAL" String Conversion Function
; TOK_ASC     EQU   $E6 ;Token: "ASC" String Conversion Function
; TOK_CHR     EQU   $E7 ;Token: "CHR$" String Function
; TOK_LEFT    EQU   $E8 ;Token: "LEFT$" String Function
; TOK_RIGHT   EQU   $E9 ;Token: "RIGHT$" String Function
; TOK_MID     EQU   $EA ;Token: "MID$" String Function
; ==============================================================================
; 
; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft - Part A, $D000-$DD66: 
; Input Parsing, Routine Addressing, For-Next Loops, etc.
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; ==============================================================================
; Applesoft Token Address Table:
; ==============================================================================
; 
; TKADTBL      EQU    $D000           ;[Entries are ADDRESS-1]
; 
; [The unused TA_* Labels I added are Global and Exported, & for future use.]
; 
TA_END          DW    END-1           ;$80...128...END
TA_FOR          DW    FOR-1           ;$81...129...FOR
TA_NEXT         DW    NEXT-1          ;$82...130...NEXT
TA_DATA         DW    DATA-1          ;$83...131...DATA
TA_INPUT        DW    INPUT-1         ;$84...132...INPUT
TA_DEL          DW    DEL-1           ;$85...133...DEL
TA_DIM          DW    DIM-1           ;$86...134...DIM
TA_READ         DW    BAS_READ-1      ;$87...135...READ
TA_GR           DW    GR-1            ;$88...136...GR
TA_TEXT         DW    TEXT-1          ;$89...137...TEXT
TA_PR           DW    PR_NUMBER-1     ;$8A...138...PR#
TA_IN           DW    IN_NUMBER-1     ;$8B...139...IN#
TA_CALL         DW    CALL-1          ;$8C...140...CALL
TA_PLOT         DW    BAS_PLOT-1      ;$8D...141...PLOT
TA_HLIN         DW    HLIN-1          ;$8E...142...HLIN
TA_VLIN         DW    VLIN-1          ;$8F...143...VLIN
TA_HGR2         DW    HGR2-1          ;$90...144...HGR2
TA_HGR          DW    HGR-1           ;$91...145...HGR
TA_HCOLOR       DW    HCOLOR-1        ;$92...146...HCOLOR=
TA_HPLOT        DW    HPLOT-1         ;$93...147...HPLOT
TA_DRAW         DW    DRAW-1          ;$94...148...DRAW
TA_XDRAW        DW    XDRAW-1         ;$95...149...XDRAW
TA_HTAB         DW    HTAB-1          ;$96...150...HTAB
; The HOME command goes directly to the Autostart F8 Monitor HOME routine:
TA_HOME         DW    HOME-1          ;$97...151...HOME
TA_ROT          DW    ROT-1           ;$98...152...ROT=
TA_SCALE        DW    SCALE-1         ;$99...153...SCALE=
TA_SHLOAD       DW    SHLOAD-1        ;$9A...154...SHLOAD
TA_TRACE        DW    TRACE-1         ;$9B...155...TRACE
TA_NOTRACE      DW    NOTRACE-1       ;$9C...156...NOTRACE
TA_NORMAL       DW    NORMAL-1        ;$9D...157...NORMAL
TA_INVERSE      DW    INVERSE-1       ;$9E...158...INVERSE
TA_FLASH        DW    FLASH-1         ;$9F...159...FLASH
TA_COLOR        DW    COLOR-1         ;$A0...160...COLOR=
; The POP command and the RETURN command (below), both go to the POPRTN handler:
TA_POP          DW    POPRTN-1        ;$A1...161...POP
TA_VTAB         DW    VTAB-1          ;$A2...162...VTAB
TA_HIMEM        DW    HIMEM-1         ;$A3...163...HIMEM:
TA_LOMEM        DW    LOMEM-1         ;$A4...164...LOMEM:
TA_ONERR        DW    ONERR-1         ;$A5...165...ONERR
TA_RESUME       DW    RESUME-1        ;$A6...166...RESUME
TA_RECALL       DW    RECALL-1        ;$A7...167...RECALL
TA_STORE        DW    STORE-1         ;$A8...168...STORE
TA_SPEED        DW    SPEED-1         ;$A9...169...SPEED=
TA_LET          DW    LET-1           ;$AA...170...LET
TA_GOTO         DW    GOTO-1          ;$AB...171...GOTO
TA_RUN          DW    RUN-1           ;$AC...172...RUN
TA_IF           DW    IF-1            ;$AD...173...IF
TA_RESTORE      DW    RESTORE-1       ;$AE...174...RESTORE
; The Ampersand ("&") command jumps directly to the Page 3 Ampersand Vector:
TA_AMPERV       DW    AMPERV-1        ;$AF...175...&
TA_GOSUB        DW    GOSUB-1         ;$B0...176...GOSUB
; The RETURN command and the POP command (above), both go to the POPRTN handler:
TA_RETURN       DW    POPRTN-1        ;$B1...177...RETURN
TA_REM          DW    REM-1           ;$B2...178...REM
TA_STOP         DW    STOP-1          ;$B3...179...STOP
TA_ONGOTO       DW    ONGOTO-1        ;$B4...180...ON
TA_WAIT         DW    WAIT-1          ;$B5...181...WAIT
TA_LOAD         DW    BAS_LOAD-1      ;$B6...182...LOAD
TA_SAVE         DW    BAS_SAVE-1      ;$B7...183...SAVE
TA_DEF          DW    DEF-1           ;$B8...184...DEF
TA_POKE         DW    POKE-1          ;$B9...185...POKE
TA_PRINT        DW    PRINT-1         ;$BA...186...PRINT
TA_CONT         DW    CONT-1          ;$BB...187...CONT
TA_LIST         DW    LIST-1          ;$BC...188...LIST
TA_CLEAR        DW    CLEAR-1         ;$BD...189...CLEAR
TA_GET          DW    GET-1           ;$BE...190...GET
TA_NEW          DW    NEW-1           ;$BF...191...NEW
; 
; ==============================================================================
; There are no direct pointers for $C0~C7:
; ==============================================================================
; xxxx  ?? ??      TA_TAB      DW     TAB-1      ;$C0...192...TAB(
; xxxx  ?? ??      TA_TO       DW     TO-1       ;$C1...193...TO
; xxxx  ?? ??      TA_FN       DW     FN-1       ;$C2...194...FN
; xxxx  ?? ??      TA_SPC      DW     SPC-1      ;$C3...195...SPC(
; xxxx  ?? ??      TA_THEN     DW     THEN-1     ;$C4...196...THEN
; xxxx  ?? ??      TA_AT       DW     AT-1       ;$C5...197...AT
; xxxx  ?? ??      TA_NOT      DW     NOT-1      ;$C6...198...NOT
; xxxx  ?? ??      TA_STEP     DW     STEP-1     ;$C7...199...STEP
; ==============================================================================
; Math Operator addresses are in the Branch Address Table (MATHTBL) below.
; Token constants $C8~$D1 are used in it as Math Operator Precedence Codes.
; ==============================================================================
; 
; 
; ==============================================================================
; Unary Functions Branch Address Table: 
; ==============================================================================
; 
; UNFNC       EQU    $D080          ;Same Addres as TN_END (next)
; 
TA_SGN          DW    SGN             ;$D2...210...SGN
TA_INT          DW    INT             ;$D3...211...INT
TA_ABS          DW    ABS             ;$D4...212...ABS
TA_USR          DW    BAS_USRVEC      ;$D5...213...USR
TA_FRE          DW    FRE             ;$D6...214...FRE
TA_ERROR        DW    ERROR           ;$D7...215...SCRN(...done special
TA_PDL          DW    PDL             ;$D8...216...PDL
TA_POS          DW    POS             ;$D9...217...POS
TA_SQR          DW    SQR             ;$DA...218...SQR
TA_RND          DW    RND             ;$DB...219...RND
TA_LOG          DW    LOG             ;$DC...220...LOG
TA_EXP          DW    EXP             ;$DD...221...EXP
TA_COS          DW    COS             ;$DE...222...COS
TA_SIN          DW    SIN             ;$DF...223...SIN
TA_TAN          DW    TAN             ;$E0...224...TAN
TA_ATN          DW    ATN             ;$E1...225...ATN
TA_PEEK         DW    PEEK            ;$E2...226...PEEK
TA_LEN          DW    LEN             ;$E3...227...LEN
TA_STR          DW    STR             ;$E4...228...STR$
TA_VAL          DW    VAL             ;$E5...229...VAL
TA_ASC          DW    ASC             ;$E6...230...ASC
TA_CHR          DW    CHRSTR          ;$E7...231...CHR$
TA_LEFT         DW    LEFTSTR         ;$E8...232...LEFT$
TA_RIGHT        DW    RIGHTSTR        ;$E9...233...RIGHT$
TA_MID          DW    MIDSTR          ;$EA...234...MID$
; 
; ==============================================================================
; Math Operator Branch Address Table
; ==============================================================================
; 
; [The unused MO_* Labels I added are Global and Exported, & for future use.]
; 
; ==============================================================================
; Math Operator Precedence Codes (MO-PC):
; ==============================================================================
; Label   MO-PC   Description
; -----   -----   --------------------------------------------------------------
; P_OR    = $46   Logical "OR" Operator (is lowest precedence)
; P_AND   = $50   Logical "AND" Operator (is next higher precedence, etc...)
; P_REL   = $64   Relational (">"), ("="), & ("<") Operators
; P_ADD   = $79   Binary Addition ("+") and Subtraction ("-") Operators
; P_MUL   = $7B   Multiplication ("*") and Division ("/") Operators
; P_PWR   = $7D   Exponentiation ("^") [Power] Operator
; P_NEQ   = $7F   Unary Negative ("-") and Comparison ("=") Operators
; ==============================================================================
; Each entry consists of: a one-byte Precedence Code <--(its Token constant), 
;            followed by: a two-byte Function/Operator Address (minus one)
; ==============================================================================
; 
; MATHTBL      EQU    $D0B2           ;Math Operator Branch Address Table
; 
MO_ADD          DFB   P_ADD           ;$C8...200...+
TA_ADD          DW    FADDT-1         ;ADD Function Address
MO_SUB          DFB   P_ADD           ;$C9...201...-
TA_SUB          DW    FSUBT-1         ;SUBTRACT Function Address
MO_MUL          DFB   P_MUL           ;$CA...202...*
TA_MUL          DW    FMULTT-1        ;MULTIPLY Function Address
MO_DIV          DFB   P_MUL           ;$CB...203.../
TA_DIV          DW    FDIVT-1         ;DIVIDE Function Address
MO_PWR          DFB   P_PWR           ;$CC...204...^
TA_PWR          DW    FPWRT-1         ;EXPONENT (POWER) Function Address
MO_AND          DFB   P_AND           ;$CD...205...AND
TA_AND          DW    AND-1           ;AND Operator Address
MO_OR           DFB   P_OR            ;$CE...206...OR
TA_OR           DW    OR-1            ;OR Operator Address
MO_UMNS_GTLT    DFB   P_NEQ           ;$CF...207...>...Unary Minus ("-")
TA_UMNS_GTLT    DW    NEGOP-1         ;(GREATER-THAN)->-(LESS-THAN) Op Address
MO_UNOT_EQUL    DFB   P_NEQ           ;$D0...208...=...Unary NOT
TA_UNOT_EQUL    DW    EQUOP-1         ;(EQUAL-TO) Operator Address
MO_UPLS_LTGT    DFB   P_REL           ;$D1...209...<...Unary Plus ("+")
TA_UPLS_LTGT    DW    RELOPS-1        ;(LESS-THAN)-<-(GREATER-THAN) Op Address
; 
; ==============================================================================
; Applesoft Token Names Branch Address Table:                 ($190 = 400 Bytes)
; ==============================================================================
; 
; [The unused TN_* Labels I added are Global and Exported, & for future use.]
; 
; ==============================================================================
; 
; TKNMTBL      EQU    $D0D0           ;Dextral Character Inverted (DCI) Names
;                                     ;Same Addres as TN_END (next)
TN_END          DCI   "END"           ;$80...128...END
TN_FOR          DCI   "FOR"           ;$81...129...FOR
TN_NEXT         DCI   "NEXT"          ;$82...130...NEXT
TN_DATA         DCI   "DATA"          ;$83...131...DATA
TN_INPUT        DCI   "INPUT"         ;$84...132...INPUT
TN_DEL          DCI   "DEL"           ;$85...133...DEL
TN_DIM          DCI   "DIM"           ;$86...134...DIM
TN_READ         DCI   "READ"          ;$87...135...READ
TN_GR           DCI   "GR"            ;$88...136...GR
TN_TEXT         DCI   "TEXT"          ;$89...137...TEXT
TN_PR           DCI   "PR#"           ;$8A...138...PR#
TN_IN           DCI   "IN#"           ;$8B...139...IN#
TN_CALL         DCI   "CALL"          ;$8C...140...CALL
TN_PLOT         DCI   "PLOT"          ;$8D...141...PLOT
TN_HLIN         DCI   "HLIN"          ;$8E...142...HLIN
TN_VLIN         DCI   "VLIN"          ;$8F...143...VLIN
TN_HGR2         DCI   "HGR2"          ;$90...144...HGR2
TN_HGR          DCI   "HGR"           ;$91...145...HGR
TN_HCOLOR       DCI   "HCOLOR="       ;$92...146...HCOLOR=
TN_HPLOT        DCI   "HPLOT"         ;$93...147...HPLOT
TN_DRAW         DCI   "DRAW"          ;$94...148...DRAW
TN_XDRAW        DCI   "XDRAW"         ;$95...149...XDRAW
TN_HTAB         DCI   "HTAB"          ;$96...150...HTAB
TN_HOME         DCI   "HOME"          ;$97...151...HOME
TN_ROT          DCI   "ROT="          ;$98...152...ROT=
TN_SCALE        DCI   "SCALE="        ;$99...153...SCALE=
TN_SHLOAD       DCI   "SHLOAD"        ;$9A...154...SHLOAD
TN_TRACE        DCI   "TRACE"         ;$9B...155...TRACE
TN_NOTRACE      DCI   "NOTRACE"       ;$9C...156...NOTRACE
TN_NORMAL       DCI   "NORMAL"        ;$9D...157...NORMAL
TN_INVERSE      DCI   "INVERSE"       ;$9E...158...INVERSE
TN_FLASH        DCI   "FLASH"         ;$9F...159...FLASH
TN_COLOR        DCI   "COLOR="        ;$A0...160...COLOR=
TN_POP          DCI   "POP"           ;$A1...161...POP
TN_VTAB         DCI   "VTAB"          ;$A2...162...VTAB
TN_HIMEM        DCI   "HIMEM:"        ;$A3...163...HIMEM:
TN_LOMEM        DCI   "LOMEM:"        ;$A4...164...LOMEM:
TN_ONERR        DCI   "ONERR"         ;$A5...165...ONERR
TN_RESUME       DCI   "RESUME"        ;$A6...166...RESUME
TN_RECALL       DCI   "RECALL"        ;$A7...167...RECALL
TN_STORE        DCI   "STORE"         ;$A8...168...STORE
TN_SPEED        DCI   "SPEED="        ;$A9...169...SPEED=
TN_LET          DCI   "LET"           ;$AA...170...LET
TN_GOTO         DCI   "GOTO"          ;$AB...171...GOTO
TN_RUN          DCI   "RUN"           ;$AC...172...RUN
TN_IF           DCI   "IF"            ;$AD...173...IF
TN_RESTORE      DCI   "RESTORE"       ;$AE...174...RESTORE
TN_AMPERSAND    DFB   '&' | $80       ;$AF...175...&
TN_GOSUB        DCI   "GOSUB"         ;$B0...176...GOSUB
TN_RETURN       DCI   "RETURN"        ;$B1...177...RETURN
TN_REM          DCI   "REM"           ;$B2...178...REM
TN_STOP         DCI   "STOP"          ;$B3...179...STOP
TN_ON           DCI   "ON"            ;$B4...180...ON
TN_WAIT         DCI   "WAIT"          ;$B5...181...WAIT
TN_LOAD         DCI   "LOAD"          ;$B6...182...LOAD
TN_SAVE         DCI   "SAVE"          ;$B7...183...SAVE
TN_DEF          DCI   "DEF"           ;$B8...184...DEF
TN_POKE         DCI   "POKE"          ;$B9...185...POKE
TN_PRINT        DCI   "PRINT"         ;$BA...186...PRINT
TN_CONT         DCI   "CONT"          ;$BB...187...CONT
TN_LIST         DCI   "LIST"          ;$BC...188...LIST
TN_CLEAR        DCI   "CLEAR"         ;$BD...189...CLEAR
TN_GET          DCI   "GET"           ;$BE...190...GET
TN_NEW          DCI   "NEW"           ;$BF...191...NEW
TN_TAB          DCI   "TAB("          ;$C0...192...TAB(
TN_TO           DCI   "TO"            ;$C1...193...TO
TN_FN           DCI   "FN"            ;$C2...194...FN
TN_SPC          DCI   "SPC("          ;$C3...195...SPC(
TN_THEN         DCI   "THEN"          ;$C4...196...THEN
TN_AT           DCI   "AT"            ;$C5...197...AT
TN_NOT          DCI   "NOT"           ;$C6...198...NOT
TN_STEP         DCI   "STEP"          ;$C7...199...STEP
TN_ADD          DFB   '+' | $80       ;$C8...200...+
TN_SUB          DFB   '-' | $80       ;$C9...201...-
TN_MUL          DFB   '*' | $80       ;$CA...202...*
TN_DIV          DFB   '/' | $80       ;$CB...203.../
TN_PWR          DFB   '^' | $80       ;$CC...204...^
TN_AND          DCI   "AND"           ;$CD...205...AND
TN_OR           DCI   "OR"            ;$CE...206...OR
TN_NEG          DFB   '>' | $80       ;$CF...207...>
TN_EQU          DFB   '=' | $80       ;$D0...208...=
TN_REL          DFB   '<' | $80       ;$D1...209...<
TN_SGN          DCI   "SGN"           ;$D2...210...SGN
TN_INT          DCI   "INT"           ;$D3...211...INT
TN_ABS          DCI   "ABS"           ;$D4...212...ABS
TN_USR          DCI   "USR"           ;$D5...213...USR
TN_FRE          DCI   "FRE"           ;$D6...214...FRE
TN_SCRN         DCI   "SCRN("         ;$D7...215...SCRN(
TN_PDL          DCI   "PDL"           ;$D8...216...PDL
TN_POS          DCI   "POS"           ;$D9...217...POS
TN_SQR          DCI   "SQR"           ;$DA...218...SQR
TN_RND          DCI   "RND"           ;$DB...219...RND
TN_LOG          DCI   "LOG"           ;$DC...220...LOG
TN_EXP          DCI   "EXP"           ;$DD...221...EXP
TN_COS          DCI   "COS"           ;$DE...222...COS
TN_SIN          DCI   "SIN"           ;$DF...223...SIN
TN_TAN          DCI   "TAN"           ;$E0...224...TAN
TN_ATN          DCI   "ATN"           ;$E1...225...ATN
TN_PEEK         DCI   "PEEK"          ;$E2...226...PEEK
TN_LEN          DCI   "LEN"           ;$E3...227...LEN
TN_STR          DCI   "STR$"          ;$E4...228...STR$
TN_VAL          DCI   "VAL"           ;$E5...229...VAL
TN_ASC          DCI   "ASC"           ;$E6...230...ASC
TN_CHR          DCI   "CHR$"          ;$E7...231...CHR$
TN_LEFT         DCI   "LEFT$"         ;$E8...232...LEFT$
TN_RIGHT        DCI   "RIGHT$"        ;$E9...233...RIGHT$
TN_MID          DCI   "MID$"          ;$EA...234...MID$
TOKNAMEND       DFB   $00             ;End of Token Name Table
; 
; ==============================================================================
; Error Messages
; ==============================================================================
; 
; [The unused Labels I added are Global and Exported, & for future use.--JPD]
; 
; ==============================================================================
; (The code uses error message constants that are defined by subtracting the
; start of the table from the address of the error.  Currently, there is no way
; to do that in SourceGen, so the constants are project symbols instead.)
; ==============================================================================
; 
; ERR_MSGS     EQU    $D260           ;Applesoft Error Messages Table
; 
NOFOR_ERR       DCI   "NEXT WITHOUT FOR" ;ERR_NOFOR     = *-ERR_MSGS = #$00
SYNTAXERR       DCI   "SYNTAX"        ;ERR_SYNTAX    = *-ERR_MSGS = #$10
NOGOSUBERR      DCI   "RETURN WITHOUT GOSUB" ;ERR_NOGOSUB   = *-ERR_MSGS = #$16
NODATAERR       DCI   "OUT OF DATA"   ;ERR_NODATA    = *-ERR_MSGS = #$2A
ILLQTYERR       DCI   "ILLEGAL QUANTITY" ;ERR_ILLQTY    = *-ERR_MSGS = #$35
OVERFLOWERR     DCI   "OVERFLOW"      ;ERR_OVERFLOW  = *-ERR_MSGS = #$45
MEMFULLERR      DCI   "OUT OF MEMORY" ;ERR_MEMFULL   = *-ERR_MSGS = #$4D
UNDEFSTATERR    DCI   "UNDEF'D STATEMENT" ;ERR_UNDEFSTAT = *-ERR_MSGS = #$5A
BADSUBSERR      DCI   "BAD SUBSCRIPT" ;ERR_BADSUBS   = *-ERR_MSGS = #$6B
REDIMDERR       DCI   "REDIM'D ARRAY" ;ERR_REDIMD    = *-ERR_MSGS = #$78
ZERODIVERR      DCI   "DIVISION BY ZERO" ;ERR_ZERODIV   = *-ERR_MSGS = #$85
ILLDIRERR       DCI   "ILLEGAL DIRECT" ;ERR_ILLDIR    = *-ERR_MSGS = #$95
BADTYPEERR      DCI   "TYPE MISMATCH" ;ERR_BADTYPE   = *-ERR_MSGS = #$A3
STRLONGERR      DCI   "STRING TOO LONG" ;ERR_STRLONG   = *-ERR_MSGS = #$B0
FRMCPXERR       DCI   "FORMULA TOO COMPLEX" ;ERR_FRMCPX    = *-ERR_MSGS = #$BF
CANTCONTERR     DCI   "CAN'T CONTINUE" ;ERR_CANTCONT  = *-ERR_MSGS = #$D2
UNDEFFUNCERR    DCI   "UNDEF'D FUNCTION" ;ERR_UNDEFFUNC = *-ERR_MSGS = #$E0
QT_ERROR        .ZSTR " ERROR",$07    ;Ring BELL; Null-Terminated String
QT_IN           .ZSTR " IN "          ;<--------- Null-Terminated String
QT_BREAK        .ZSTR $0D,"BREAK",$07 ;Ring BELL; Null-Terminated String

; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Start of Applesoft BASIC ROM Image (Part A) Executable Code    [End of Tables]
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; ==============================================================================
; Get FOR/NEXT Pointer from STACK                               <<< Buggy! >>>
; Called by FOR and NEXT to scan the STACK for a Frame with the Same Variable:
; ==============================================================================
; 
; (FORPTR) = Address of Variable if FOR or NEXT
;          = $xxFF when Called from POPRTN  <<< BUG: should be $FFxx >>>
;            <<< BUG can be fixed in (Apple II Plus) Emulator ROM images! >>>
; 
; Returns: .NE. If Variable is Not Found,
;          ^^^^ (Not Equal to Zero: P-Reg Z-Flag=0) 
;          (X) = Stack Pointer after scanning all Frames
; 
;          .EQ. If Variable is Found,
;          ^^^^ (Equal to Zero: P-Reg Z-Flag=1)
;          (X) = Stack Pointer of Frame Found
; 
; ==============================================================================
; 
GETFORPTR       TSX                   ;First, calculate our Stack Pointer Index:
                INX                   ;We put (S-Reg) into (X-Reg); Now Add 4
                INX                   ;(X-Reg) will be (S-Reg) + 4   <and/or>
                INX                   ;(X-Reg) will be (Stack Pointer) + 4
                INX                   ;Now, (X-Reg) is our Stack Pointer Index
; ----------------------------------- ;Is there a FOR Frame here?
FORFRAME        LDA   STACK+1,X       ;Get Byte from STACK
                CMP   #TOK_FOR        ;Is it a FOR Statement (Token)?
                BNE   BAS_RTS00       ;NOT a FOR Statement; Return to Caller
                LDA   FORPTR+1        ;YES; Does its NEXT have a Variable?
                BNE   SAMEVARPTR      ;YES, a Variable is Specified
; ----------------------------------- ;NO Variable; So use this FOR Frame
                LDA   STACK+2,X       ;Get its Variable Pointer, Low (from STACK)
                STA   FORPTR          ;Set our FOR Pointer, Low
                LDA   STACK+3,X       ;Get its Variable Pointer, High (from STACK)
                STA   FORPTR+1        ;Set our FOR Pointer, High
; --------------------- ;Is Same Variable (as Caller's) specified in this Frame?
SAMEVARPTR      CMP   STACK+3,X       ;Compare Variable Pointers, High
                BNE   NEXTFRAME       ;NO; So try next Frame (if any)
                LDA   FORPTR          ;MAYBE; Get Variable Pointer, Low
                CMP   STACK+2,X       ;Compare Variable Pointers, Low
                BEQ   BAS_RTS00       ;YES, Pointers are Equal; Return to Caller
; ----------------------------------- ;NO, So try next Frame (if any)
NEXTFRAME       TXA                   ;Get our Stack Pointer Index
                CLC                   ;Clear Carry for Add (to Increment our SPI)
                ADC   #18             ;(A-Reg) = (X-Reg) + (18 bytes per Frame)
                TAX                   ;Set (Increment) our Stack Pointer Index
                BNE   FORFRAME        ;Loop until our SPI is Zero (256 MOD 256)
; ------------------------------------------------------------------------------
; If FOR loops are nested > 10 deep, the Memory Full Error message is displayed.
; 10 frames at 18 bytes/frame is 180 bytes of stack space.  So, this condition
; can never happen; hense, this branch is Always Taken!  [Barring overhead, the
; maximum number of stack frames possible would be: INT(256/18) = 14.]
; ------------------------------------------------------------------------------
BAS_RTS00       RTS                   ;Return to Caller (See "Returns:" above)

; ==============================================================================
; Move Memory Block Upward
; ==============================================================================
; On Entry: [(A,{X|Y})={Low,High}] = (HIGHDS) = Highest Destination Address +1
;  _______________|_______________    (LOWTR) =  Lowest Source Address
;  {Depends on Caller/Entry-Point}   (HIGHTR) = Highest Source Address +1
; ==============================================================================
; 
; First, get setup to move upward LOWTR through HIGHTR-1 to just below HIGHDS:
MVBLKUP1        JSR   REASON          ;Assure [(HIGHDS)=(A,Y)={Low,High}]<(FRETOP)
                STA   STREND          ;Set Top of Array Storage, Low (from A-Reg)
                STY   STREND+1        ;Set Top of Array Storage, High (from Y-Reg)
; Move Memory Block Upward, 2nd Entry Point (Bypasses MVBLKUP1 Stuff)
MVBLKUP2        SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
; ----------------------------------- ;Compute Number of Bytes to be Moved
;                                     ; (from LOWTR through HIGHTR-1)
                LDA   HIGHTR          ;Get Highest Source Address +1, Low
                SBC   LOWTR           ;Subtract Lowest Source Address, Low
                STA   INDEX           ;Save Number of Bytes in Partial Page
                TAY                   ;Save Number of Bytes in Partial Page
                LDA   HIGHTR+1        ;Get Highest Source Address +1, High
                SBC   LOWTR+1         ;Subtract Lowest Source Address, High
                TAX                   ;Set X-Reg = Number of Whole Pages
                INX                   ;Set X-Reg = Number of Whole Pages +1
                TYA                   ;Retrieve Number of Bytes in Partial Page
                BEQ   NXTMVBLKUP      ;Taken if NO Partial Page Bytes
;                                     ;Move Partial Page 1st to maximize speed!
; ----------------------------------- ;Back Up: HIGHTR-(Partial Page Bytes)
MVBKPHSA        LDA   HIGHTR          ;Get Highest Source Address +1, Low
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   INDEX           ;Subtract Number of Bytes in Partial Page
                STA   HIGHTR          ;Set Highest Source Address +1, Low
                BCS   MVBKPHDA        ;If NO Borrow, Skip Setting High Byte
                DEC   HIGHTR+1        ;Set Highest Source Address +1, High
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
; ----------------------------------- ;Back Up: HIGHDS-(Partial Page Bytes)
MVBKPHDA        LDA   HIGHDS          ;Get Highest Destination Address +1, low
                SBC   INDEX           ;Subtract Number of Bytes in Partial Page
                STA   HIGHDS          ;Set Highest Destination Address +1, low
                BCS   DOMVBLKUP2      ;If NO Borrow, Skip Setting High Byte
                DEC   HIGHDS+1        ;Set Highest Destination Address +1, High
                BCC   DOMVBLKUP2      ;Always Taken

; ----------------------------------- ;Do it NOW: Move a Page of Bytes (256)
DOMVBLKUP1      LDA   (HIGHTR),Y      ;Get Byte at Highest Source Address +1
                STA   (HIGHDS),Y      ;Set Byte at Highest Destination Address +1
DOMVBLKUP2      DEY                   ;Move the Remainder of the Page of Bytes
                BNE   DOMVBLKUP1      ;Loop until End of this Page of 256 bytes
; ----------------------------------- ;Move one more byte (the last one of 256)
                LDA   (HIGHTR),Y      ;Get Byte at Highest Source Address +1
                STA   (HIGHDS),Y      ;Set Byte at Highest Destination Address +1
; ----------------------------------- ;Down to NEXT Block of 256 Bytes
NXTMVBLKUP      DEC   HIGHTR+1        ;Reduce Highest Source Address +1, High
                DEC   HIGHDS+1        ;Reduce Highest Destination Address +1, High
                DEX                   ;Move another Block of 256 Bytes?
                BNE   DOMVBLKUP2      ;YES; Move NEXT Page of Bytes (256)
                RTS                   ;NO, Finished; Return to Caller

; ==============================================================================
; Assure sufficient Stack space to do FOR, GOSUB, or Expression Evaluation
; ==============================================================================
; Upon Entry, the Accumulator (A-Reg) should contain the number of Address
; Pointers and/or half the number of bytes required to be put on the STACK
; ------------------------------------------------------------------------------
; Entered with A-Reg = (9, 3, or 1) for (FOR, GOSUB, or FRMEVL), respectivly.
; ==============================================================================
; 
CHKMEM          ASL   A               ;Double it      (* 2 bytes/Address-Pointer)
;                                     ;Carry is also Cleared for A-Reg < 128
                ADC   #$36            ;(Acc) * 2 + 54  : (54 Overhead bytes/page)
; ------------------------------------------------------------------------------
; Do the Math: >>-----------> ;(Acc) * 2 + 54 >= 256      ;To set the carry flag
;                           > ;(Acc) * 2      >= 256 - 54 ;- Overhead bytes/page
;        Conclusion: <---<< > ;(Acc) * 2      >= 202      ;= Maximum STACK bytes
;    ($64)>=(Acc)>=($65)    > ;(Acc)          >= 202 / 2  ;/ 2-bytes/Adr.Pointer
;         CC  |  CS         > ;(Acc)          >= 101      ;To set the carry flag
; ------------------------------------------------------------------------------
                BCS   MEMERR          ;Deficient Stack-Space, Do Mem Full Error
;                                     ;Never Happens: (A-Reg)=(72, 60, or 56) so
;                                     ;               Carry is Always Clear 
                STA   STKPTR          ;Save Result in Stack Pointer Index Safe
                TSX                   ;Put Stack Pointer in X-Reg
                CPX   STKPTR          ;Compare Stack Pointer to Result Saved
                BCC   MEMERR          ;Deficient Stack-Space, Do Memory Full Error
                RTS                   ;Else, Enough Stack-Space, Return to Caller

; ==============================================================================
; Assure sufficient Arrays-to-Strings Free-Space
; [(A,Y)={Low,High}] = Address to which Array Space needs to grow
; ==============================================================================
; 
REASON          CPY   FRETOP+1        ;Assure Y-Reg < FRETOP, High
                BCC   BAS_RTS01       ;Enough Free-Space, Return to Caller
                BNE   MAXFRESPC       ;Deficient Free-Space, Collect Garbage
                CMP   FRETOP          ;Assure A-Reg < FRETOP, Low 
                BCC   BAS_RTS01       ;Enough Free-Space, Return to Caller
;                                     ;Else, Deficient Free-Spc, Collect Garbage
; ------------------------------------------------------------------------------
; Save [(A,Y)={Low,High}], TEMP1, & TEMP2 to STACK (12 Bytes)
; [See also (below): "Preamble about the Applesoft Floating Point Accumulators"]
; ------------------------------------------------------------------------------
MAXFRESPC       PHA                   ;Save/Push (A-Reg) Byte on STACK
                LDX   #$09            ;[+9]=[(FAC-TEMP1-1)=($9D-$93-1)=($09)]
                TYA                   ;Save (Y-Reg) on the STACK next
PUSHNINE        PHA                   ;Save/Push (A-Reg) Byte on STACK
                LDA   TEMP1,X         ;Save TEMP1 & TEMP2 on the STACK
                DEX                   ;... (Temporary Save Areas for FAC & ARG)
                BPL   PUSHNINE        ;Loop-Back until X<0
; ------------------------------------------------------------------------------
                JSR   GARBAGE         ;Maximize Free-Space, Collect Garbage ...
; ------------------------------------------------------------------------------
; Restore TEMP2, TEMP1, & [(A,Y)={Low,High}] from STACK (12 Bytes)
; [See also (below): "Preamble about the Applesoft Floating Point Accumulators"]
; ------------------------------------------------------------------------------
                LDX   #$F7            ;[-9]=[(TEMP1-FAC+1)=($93-$9D+1)=($F7)]
PULLNINE        PLA                   ;Pull Byte off STACK
                STA   FAC,X           ;Restore TEMP2 & TEMP1 from the STACK
                INX                   ;... (Temporary Save Areas for ARG & FAC)
                BMI   PULLNINE        ;Loop-Back until X=0
                PLA                   ;Pull Byte off STACK
                TAY                   ;Restore Y-Reg with it (from STACK)
                PLA                   ;Restore A-Reg (Pull Byte off STACK)
; ----------------------------------- ;[Next is similar to REASON (above)]
                CPY   FRETOP+1        ;Assure Y-Reg < FRETOP, High
                BCC   BAS_RTS01       ;Enough Free-Space, Return to Caller
                BNE   MEMERR          ;Deficient Free-Space, Do Memory Full Error
                CMP   FRETOP          ;Assure A-Reg < FRETOP, Low 
                BCS   MEMERR          ;Deficient Free-Space, Do Memory Full Error
BAS_RTS01       RTS                   ;Enooough Free-Space, Return to Caller

; ==============================================================================
; Error Handler (Parts preceding Warm Restart): 
; ==============================================================================
; 
; ==============================================================================
; Error Handler (Part 0): Insufficient Free-Space, Do Memory Full Error
; ==============================================================================
; 
; ----------------------------------- ;Error Entry Point; Also User-Callable:
MEMERR          LDX   #ERR_MEMFULL    ;Get "?Out Of Memory" Error Message Index
; 
; ==============================================================================
; "ERROR" Function: Error Handler (Part 1)
; ==============================================================================
; Print Error Message based on X-Reg
; ----------------------------------------------------------------------------
; (X)=Offset In Error Message Table
; (ERRFLG) > 128 If ON ERR is turned ON
; (CURLINH) = (CURLIN+1) = $FF If in Direct Mode
; ==============================================================================
; 
ERROR           BIT   ERRFLG          ;Is ONERR turned ON?
                BPL   DOERRMSG        ;YES, ONERR is turned ON
                JMP   ERRHNDLR        ;NO, ONERR is turned OFF; Goto (Part 2)

; ==============================================================================
; Error Handler (Part 3): ON ERR is turned ON, so Print an Error Message
; ==============================================================================
DOERRMSG        JSR   CRDO            ;Print a Carriage <Return> Character
                JSR   OUTQUES         ;Print a Qustion Mark ("?") Character
PRERRMSG        LDA   ERR_MSGS,X      ;Get a Char from the Error Messages Table
                PHA                   ;Save Char on STACK
                JSR   OUTDO           ;Print Error Message (one Char at a time)
                INX                   ;Get set for next Char
                PLA                   ;Restore Character (Pull Byte off STACK)
                BPL   PRERRMSG        ;Loop-Back until Char has its high bit set
                JSR   STKINI          ;Reset/Initialize STACK to start at $01F8
                LDA   #<QT_ERROR      ;Get set to ...
                LDY   #>QT_ERROR      ;Print " ERROR" & Ring BELL
; ==============================================================================
; Error Handler (Final Part): Print Error Line Number then Do Warm Restart
; ==============================================================================
PRERRLINO       JSR   STROUT          ;Print String at [(A,Y)={Low,High}]
                LDY   CURLIN+1        ;Which Program Mode: Running or Direct?
                INY                   ;Print Current Line # if NOT in Direct Mode
                BEQ   RESTART         ;If Direct (Y was $FF), Do Warm RESTART
                JSR   INPRT           ;If Running (Y was NOT $FF), Print Line #
; 
; ==============================================================================
; Warm RESTART Entry Point      (Monitor commands: Ctrl-C, 0G, 3D0G, or E003G)
; ==============================================================================
; 
RESTART         JSR   CRDO            ;Print a Carriage <Return> Character
                LDX   #']' | $80      ;Print the Applesoft Prompt Character
                JSR   INLIN2          ;Get/Read a Line of Direct Input
; ----------------------------------- ;CHRGET: Get Next Character/Token ZP-S/R
                STX   TXTPTR          ;Set up CHRGET to Scan the Input Line
                STY   TXTPTR+1        ;[(X,Y)={Low,High}]= CHRGET Next Chr/Tok Ptr 
                LSR   ERRFLG          ;Defeat ONERR: Clear the Error Flag
                JSR   CHRGET          ;Get a Character
                TAX                   ;Character Got; Null is last char + 1
                BEQ   RESTART         ;Loop-Back until finished scanning (A-Reg=0)
;                                     ;Also, if NO Input (<Return> key pressed)
; ----------------------------------- ;Else, Process the Line Input Directly:
                LDX   #$FF            ;Set Direct Mode flag
                STX   CURLIN+1        ; = Current Line Number, High
;                                     ; Line Numbers Allowed: 0-63999
;                                     ; < (64000 = $FA00) < ($FFxx >= 65280)
;                                     ; is Too Big, so used as Direct Mode flag
                BCC   NMBRDLN         ;If CHRGET saw #, Input is new Prgm Line
                JSR   PARSELINE       ;Else, (CS) NO Number, So Parse the Line
                JMP   TRACEQ          ;And, Try Executing the Line

; ------------------------------------------------------------------------------
; Numbered Line Handler (Input is a new Program Line)
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Programs Are Arranged In Memory",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 5 to 8
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Program Lines Are Constructed", 
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", page 15
; ------------------------------------------------------------------------------
NMBRDLN         LDX   PRGEND          ;Get End-of-Program Pointer [EOP +(1 or 2)?]
                STX   VARTAB          ;Save as Start-of-Variables Pointer
                LDX   PRGEND+1        ;Do Pointers' High bytes, too
                STX   VARTAB+1        ;That Resets Start of Variable Table (LOMEM)
; Effectively wiping out any routines you may have installed between PRGEND and
; VARTAB (after using LOMEM: to move VARTAB up, to make space for the routines)!
; ------------------------------------------------------------------------------
; vvvvvv  Alternative Entry Point?  Just an idea!  Not actually used:
NMBRDLN2        JSR   LINGET          ;Get Line Number
                JSR   PARSELINE       ;And Parse the Input Line
                STY   TKNCNTR         ;Save InBuff Index as End-of-Line Pointer
                JSR   FNDLIN          ;Is this Line # already in the program?
                BCC   NEWLINE         ;No; Put New-Line into program
; ----------------------------------- ;Yes; Delete Old-Line (LOWTR is Pointer)
                LDY   #$01            ;Set Y=1 (for High values)
                LDA   (LOWTR),Y       ;Get Next-Line's Address, High
                STA   SRCPTR+1        ;Set Source Pointer, High
                LDA   VARTAB          ;Get EOP/Start-of-Variables Pointer, Low
                STA   SRCPTR          ;Set Source Pointer, Low
                LDA   LOWTR+1         ;Get Old-Line Pointer, High
                STA   DSTPTR+1        ;Set Destination Pointer, High
                LDA   LOWTR           ;Get Old-Line Pointer, Low
                DEY                   ;Y goes from 1 to 0  (for Low values)
                SBC   (LOWTR),Y       ;Subtract Next-Line's Address, Low
                CLC                   ;Prepare for Add with Carry
                ADC   VARTAB          ;Add EOP/Start-of-Variables Pointer, Low
; ----------------------------------- ;Result is New Program End (EOP)
                STA   VARTAB          ;Set EOP/Start-of-Variables Pointer, Low
                STA   DSTPTR          ;Set Destination Pointer, Low
                LDA   VARTAB+1        ;Get EOP/Start-of-Variables Pointer, High
                ADC   #$FF            ;Subtract 1
                STA   VARTAB+1        ;Set EOP/Start-of-Variables Pointer, High
                SBC   LOWTR+1         ;Subtract Old-Line Pointer, High
; ----------------------------------- ;Result is Index to Move Whole Memry Pages
                TAX                   ;Save Result in X-Reg
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                LDA   LOWTR           ;Get Old-Line Pointer, Low
                SBC   VARTAB          ;Subtract EOP/Start-of-Variables Ptr, Low
; ----------------------------------- ;Result is Index to Move Partial Page
                TAY                   ;Save Result in Y-Reg
                BCS   DECSRCPTR       ;No borrow, so skip changing High values
                INX                   ;Increment Index to Move Whole Memory Pages
                DEC   DSTPTR+1        ;Decrement Destination Pointer, High
DECSRCPTR       CLC                   ;Prepare for Add with Carry
                ADC   SRCPTR          ;Add Source Pointer, Low
                BCC   DOMVBLKDWN      ;No carry, so skip changing High values
                DEC   SRCPTR+1        ;Decrement Source Pointer, High
                CLC                   ;We're done with it, so clear it
; ------------------------------------------------------------------------------
; Move Block Down: Move Higher Program Lines Down, Over Deleted & Prior Lines
; ------------------------------------------------------------------------------
;                                     ;Do it NOW: Move ALL Bytes & Pages Down
DOMVBLKDWN      LDA   (SRCPTR),Y      ;Get Byte at Source Address
                STA   (DSTPTR),Y      ;Set Byte at Destination Address
                INY                   ;Incerment Index to Move Partial Page
                BNE   DOMVBLKDWN      ;Loop until Done: (Byte Counter)=0
                INC   SRCPTR+1        ;Increment Source Pointer
                INC   DSTPTR+1        ;Increment Destination Pointer
                DEX                   ;Decrement Index to Move Whole Memory Pages
                BNE   DOMVBLKDWN      ;Loop until Done: (Page Counter)=0
; ------------------------------------------------------------------------------
; Insert a New Line into the Program                      [*]=[(A,Y)={Low,High}]
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Programs Are Arranged In Memory",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 5 to 8
; ------------------------------------------------------------------------------
; To see: "How Applesoft BASIC Program Lines Are Constructed", 
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", page 15
; ------------------------------------------------------------------------------
NEWLINE         LDA   INBUFF          ;Any Characters After Line Number?
                BEQ   FIXLINKS        ;No (INBUFF is empty), so nothing to insert
; ----------------------------------- ;Yes, so make room to insert New-Line [*]:
; Clean String Area, first (Strings are stored from MEMSIZ downward to FRETOP):
                LDA   MEMSIZ          ;Get String-Space-Top (HIMEM), Low
                LDY   MEMSIZ+1        ;Get String-Space-Top (HIMEM), High
                STA   FRETOP          ;Set Free-Spc-End/String-Space-Bottom, Low
                STY   FRETOP+1        ;Set Free-Spc-End/String-Space-Bottom, High
;                                     ;That Resets String-Storage (FRETOP=HIMEM)
; ----------------------------------- ;Prepare to move memory block up [*]:
                LDA   VARTAB          ;Get EOP/Start-of-Variables, Low
                STA   HIGHTR          ;Set Source Pointer, Low
;                                     ;Carry is already Clear
                ADC   TKNCNTR         ;Add End-of-Line Pointer
                STA   HIGHDS          ;Set Destination Pointer, Low
                LDY   VARTAB+1        ;Get EOP/Start-of-Variables, High
                STY   HIGHTR+1        ;Set Source Pointer, High
                BCC   MVPRGM          ;No carry, so skip changing High values
                INY                   ;Increment EOP/Start-of-Variables, High
MVPRGM          STY   HIGHDS+1        ;Set Destination Pointer, High
; ----------------------------------- ;Do it NOW: Move Memory Block Upward
                JSR   MVBLKUP1        ;Move Block Up: to make room for New-Line
; ----------------------------------- ;Put Line-Number into New-Line-Image [*]:
                LDA   LINNUM          ;Get Line-Number, Low
                LDY   LINNUM+1        ;Get Line-Number, High
                STA   IMGLINNUM       ;Set New-Line-Image's Line-Number, Low
                STY   IMGLINNUM+1     ;Set New-Line-Image's Line-Number, High
; ----------------------------------- ;Move EOP Up (Ptr); Clears Variables [*]:
                LDA   STREND          ;Get End-of-Variables/Free-Space-Start, Low
                LDY   STREND+1        ;Get End-of-Variables/Free-Space-Start, High
                STA   VARTAB          ;Set EOP/Start-of-Variables, Low
                STY   VARTAB+1        ;Set EOP/Start-of-Variables, High
;                                     ;Reseting Variables Ups EOP (LOMEM=FRESPC)
; ----------------------------------- ;Copy New-Line-Image into Program:
;                                     ;LOWTR is Pointer to the New-Line-Area
                LDY   TKNCNTR         ;Get End-of-Line Pointer for countdown
INSERTLINE      LDA   LINEIMAGE,Y     ;Get New-Line-Image (byte)  [EOL..INBUFF-4]
                DEY                   ;Count Down               [EOL-1..INBUFF-5]
                STA   (LOWTR),Y       ;Put New-Line (byte) into Program
                BNE   INSERTLINE      ;Loop until done  [INBUFF-5 is not copied!]
; ==============================================================================
; Clear All Variables & Re-Establish All Forward Links    [*]=[(A,Y)={Low,High}]
; ==============================================================================
; Forward Links are the Next-Line Address-Pointers at the start of each Program-
; Line that point to the NEXT Program-Line; Prgm-Lines are Numbered & Tokenized!
; ==============================================================================
; FIXLINKS is aldo called when a Line Number alone is typed (e.g., ]0<Return>)
; ==============================================================================
FIXLINKS        JSR   SETPTRS         ;Reset Start-of-Program & Clear All Vars
;                                     ;Point to Start-of-Program [*]:
                LDA   TXTTAB          ;Get Start-of-Program, Low
                LDY   TXTTAB+1        ;Get Start-of-Program, High
                STA   LINPTR          ;Set Line Pointer, Low
                STY   LINPTR+1        ;Set Line Pointer, High
                CLC                   ;Prepare for Add with Carry?
NXTLNK          LDY   #1              ;Hi-Byte of Next Forward Link
                LDA   (LINPTR),Y      ;At End-of-Program yet?
                BNE   PUTLNK          ;NO, KEEP GOING! [(Forward Link)>(EOP=0)]
;                                     ;YES, Reset End-of-Program to (LOMEM) [*]:
                LDA   VARTAB          ;Get Start-of-Variables, Low
                STA   PRGEND          ;Set End-of-Program Pointer, Low
                LDA   VARTAB+1        ;Get Start-of-Variables, High
                STA   PRGEND+1        ;Set End-of-Program Pointer, High
                JMP   RESTART         ;Do Warm RESTART

; ----------------------------------- ;Setup Forward Links:
PUTLNK          LDY   #4              ;Find End of this Line (Max Length < 256)
;                                     ;Skip first 4: Forward Link & Line Number
FNDEOL          INY                   ;Fifth is First BASIC Token in Line
                LDA   (LINPTR),Y      ;Scan Tokenized Line (EOL=0)
                BNE   FNDEOL          ;Loop until a zero is found
                INY                   ;Compute Address of Next Line:
                TYA                   ;Get this Line's Length +1
                ADC   LINPTR          ;Add it to this Line's Address, Low
                TAX                   ;Save Address of Next Line, Low, in X-Reg
                LDY   #0              ;Store Forward Link, Low, in this Line:
                STA   (LINPTR),Y      ;Set Address of Next Line, Low
                LDA   LINPTR+1        ;Get this Line's Address, High
                ADC   #0              ;Add the Carry bit; This also Clears it
                INY                   ;Store Forward Link, High, too:
                STA   (LINPTR),Y      ;Set Address of Next Line, High
;                                     ;Advance Line Address Ptr to Next Line:
                STX   LINPTR          ;Set Line Pointer to Next-Line, Low
                STA   LINPTR+1        ;Set Line Pointer to Next-Line, High
                BCC   NXTLNK          ;Always Taken; Do the Next Forward Link
; 
; ==============================================================================
; Read a Line and Strip Off Sign Bits to make Characters Low ASCII
; ==============================================================================
; 
INLIN           LDX   #$80            ;Get High ASCII Null Character
INLIN2          STX   PROMPT          ;Set Command Prompt Character
                JSR   GETLN           ;Get a Line of Input
                CPX   #$EF            ;Is Line's Length <= Maximum Line Length?
                BCC   LENGTHOK        ;YES, Line's Length <= 239 Characters
                LDX   #$EF            ;NO, Truncate Line at 239 Characters
LENGTHOK        LDA   #$00            ;End-Of-Line Markers are Null Characters
                STA   INBUFF,X        ;Set End-Of-Line Marker in Input Buffer
                TXA                   ;Is Line's Length = 0?
                BEQ   NOINPUT         ;YES, it is an Empty Input Line
STRIP           LDA   INBUFF-1,X      ;NO, Strip Off each Character's Sign Bit
                AND   #%01111111      ;Mask Off Sign Bit; Make Character Low ASCII
                STA   INBUFF-1,X      ;Put Character back in its place
                DEX                   ;Are all Characters Naked yet?           ;-)
                BNE   STRIP           ;NO, Loop-back; Keep Stripping them!     :-D
NOINPUT         LDA   #$00            ;YES; Set A=0, ...
                LDX   #<INBUFF-1      ;Set X=$FF = [(INBUFF, Low)-1: (0 - 1 = -1)]
                LDY   #>INBUFF-$100   ;Set Y=$01 = [(INBUFF, High)-1: (2 - 1 = 1)]
;                       ^^^^^^^^^^^   ;Why does this display this way?
;                                     ;It should be minus one!
                RTS                   ;[(X,Y)={Low,High}] Ptr = (Input-Buffer)-1

; ==============================================================================
; Read a Charater and Strip Off its Sign Bit to make it Low ASCII
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; *** Why should this be, "INCHR BIT $C010", instead of "INCHR JSR RDKEY"? ***
;  The following looks pretty straight forward to me.  Anyone could call this:
; ------------------------------------------------------------------------------
INCHR           JSR   RDKEY           ;Get in (A) & Make Cursor Character Flash
                AND   #%01111111      ;Mask Off Sign Bit; Make Character Low ASCII
                RTS                   ;Return to Caller

; ==============================================================================
; Parse and Tokenize the Input Line?  Or, AUTORUN the Applesoft Program?
; ==============================================================================
; 
PARSELINE       LDX   TXTPTR          ;Get CHRGET's Next Char/Token Pointer
;                                     ; as Index into Unparsed Line
                DEX                   ;Prepare for INX at PARSE
                LDY   #4              ;Prep Index to Parsed Output Line, too
                STY   DATAFLG         ;& Clear DATA Statement Flag (sign-bit) 
                BIT   AUTORUN         ;Is this program locked (AUTORUN=$80)?
                BPL   PARSE           ;NO, AUTORUN Flag<128, Parse the Input Line
;                                     ;YES, AUTORUN Flag>127, Ignore Input
;                                     ; and AUTORUN the Applesoft Program:
                PLA                   ;Pull/Discard Return Address, Low
                PLA                   ;Pull/Discard Return Address, High
                JSR   SETPTRS         ;Clear All Variables
                JMP   NEWSTT          ;Start the Program Running

; ------------------------------------------------------------------------------
; Parse and Tokenize the Input Line
; ------------------------------------------------------------------------------
PARSE           INX                   ;Increment Poiter to Next Input Character
NXCHR           LDA   INBUFF,X        ;Get Next Input Character
                BIT   DATAFLG         ;Is Input flagged as a Data Statement?
                BVS   DATASTATE       ;YES (DATAFLG = $49)
                CMP   #' '            ;NO; Is Char a Space?
                BEQ   PARSE           ;YES, Ignore Blanks, Loop
DATASTATE       STA   ENDCHR          ;Save Character to Set Literal Flag
                CMP   #'"'            ;Is this the start of a Quotation?
                BEQ   QUOTATION       ;YES, Handle the Quotation
                BVS   PUTIN           ;NO; Branch If in Data Statement
                CMP   #'?'            ;Is Input Character a Question Mark?
                BNE   ISITATOKEN      ;NO, Continue checking Input Character
                LDA   #TOK_PRINT      ;YES, Replace Question Mark w/ Print Token
                BNE   PUTIN           ;Always Taken

; Is it a Token?
ISITATOKEN      CMP   #'0'            ;Is it a Digit, Colon, Or Semi-Colon?
                BCC   ISATOKEN        ;BLT: NO, It's Punctuation !"#$%&'()*+,-./
                CMP   #'<'            ;Is it a Digit, Colon, Or Semi-Colon?
                BCC   PUTIN           ;BLT: YES, So it is Not a Token
; ------------------------------------------------------------------------------
; Search Token Name Table for match, starting with current Char from Input Line
; ------------------------------------------------------------------------------
ISATOKEN        STY   STRNG2          ;Save Index to Output Line
                LDA   #<TKNMTBL       ;Get Token-Name-Table's Address-1, Low
                STA   FAC             ;Set Search Pointer, Low
                LDA   #>TKNMTBL-$100  ;Get Token-Name-Table's Address-1, High
;                       ^^^^^^^^^^^^  ;Why does this display this way?
;                                     ;It should be minus one!
                STA   FAC+1           ;Set Search Pointer, High
                LDY   #0              ;Use Y-Reg with FAC to address Table
                STY   TKNCNTR         ;Holds Current Token - $80
                DEY                   ;Prepare for INY a few lines down
                STX   TXTPTR          ;Save Position in Input Line
                DEX                   ;Prepare for INX a few lines down
INC_Y           INY                   ;Advance Pointer to Token Table
                BNE   INC_X           ;If No Carry Over, No Need to Bump the Page
                INC   FAC+1           ;If Carry Over, Need to Bump the Page
INC_X           INX                   ;Advance Pointer into Input Line
LIN             LDA   INBUFF,X        ;Get next Character from Input Line
                CMP   #' '            ;Is Character a Blank?
                BEQ   INC_X           ;YES, Ignore All Blanks
                SEC                   ;NO, Compare to Character in Table
                SBC   (FAC),Y         ;Same as next Character of Token Name?
                BEQ   INC_Y           ;YES, Continue Matching
                CMP   #$80            ;MAYBE; Was it same except for bit 7?
                BNE   NXTTOKNAM       ;NO, Skip to Next Token
                ORA   TKNCNTR         ;YES, End of Token Name; Get Token Number
                CMP   #TOK_AT         ;Did we match AT?
                BNE   PUTTOK          ;NO, So No Ambiguity
                LDA   INBUFF+1,X      ;AT could be ATN or "A TO"
                CMP   #'N'            ;ATN has precedence over AT
                BEQ   NXTTOKNAM       ;It is ATN, Find It The Hard Way
                CMP   #'O'            ;TO has precedence over AT
                BEQ   NXTTOKNAM       ;It is "A To", Find It The Hard Way
                LDA   #TOK_AT         ;Not ATN Or "A TO", So Use AT
; ------------------------------------------------------------------------------
; Store Character or Token in Output Line
; ------------------------------------------------------------------------------
PUTTOK          LDY   STRNG2          ;Get Index to Output Line
PUTIN           INX                   ;Advance Input Index
                INY                   ;Advance Output Index
                STA   LINEIMAGE,Y     ;Store Character or Token
                LDA   LINEIMAGE,Y     ;Reload it to Test for EOL or EOS
                BEQ   LINEND          ;Branch if at End Of Line
                SEC                   ;Prepare to Subtract & do it (next)
                SBC   #':'            ;Is it the End of a Statement?
                BEQ   SDF             ;YES, at EOS: Clear DATAFLG (=0)
                CMP   #TOK_DATA-58    ;(-':'); Is it a "DATA" Token?
                BNE   ISITAREM        ;NO, Keep DATAFLG as is
SDF             STA   DATAFLG         ;Set DATAFLG [(=0) or ($83-$3A=$49)]
ISITAREM        SEC                   ;Prepare to Subtract & do it (next)
                SBC   #TOK_REM-58     ;(-':'); Is it a "REM" Token?
                BNE   NXCHR           ;NO, Continue Parsing Line
                STA   ENDCHR          ;YES, Save Result (=0): Clear Literal Flag
; ------------------------------------------------------------------------------
; Handle Literals, Characters between Quotes, or Remarks, by copying the
; Characters up to the Closing Quote or to the End of Line Character
; ------------------------------------------------------------------------------
; This is routine's Drop-Down-Into Entry Point (for Reminders: ENDCHR = 0)
; and its Loop-Back Reentry Point (for processing Literals: copying characters):
COPYCHARS       LDA   INBUFF,X        ;Get Next Input Character
                BEQ   PUTIN           ;Branch if at End of Line (=0)
;              ^^^^^^^^^^^^           ;<< NOT NEEDED; ENDCHR = 0 or '"', ONLY! >
                CMP   ENDCHR          ;Branch if at Closing Quote ('"')
                BEQ   PUTIN           ;Found ENDCHR ('"') <<< or EOL (=0)! >>>
; This is routines Entry Point from PARSE routine BEQ, way above: ENDCHR = '"'
QUOTATION       INY                   ;Next Output Char
                STA   LINEIMAGE,Y     ;Set (Put Back) Output Character
                INX                   ;Next Input Char
                BNE   COPYCHARS       ;Loop until Literal is done; Always Taken
; ------------------------------------------------------------------------------
; Advance Pointer to Next Token Name
; ------------------------------------------------------------------------------
NXTTOKNAM       LDX   TXTPTR          ;Get Pointer to Input Line
                INC   TKNCNTR         ;Advance Token Counter (Token #'s - $80)
;                                     ;Skip Over Current Keyword:
SKIPOVER        LDA   (FAC),Y         ;Scan Table for High ASCII Characters
                INY                   ;Next Token, one beyond that,
                BNE   CHKTNCHR        ;It is usually enough to just INC Y-Reg
                INC   FAC+1           ;Next Set of 256 Token Name Characters
CHKTNCHR        ASL   A               ;Is Character's Sign Bit Set?
                BCC   SKIPOVER        ;NO, Loop until Next Token Name reached
                LDA   (FAC),Y         ;YES, We're at Next Name; End Of Table?
                BNE   LIN             ;NO, Loop until End of TN Table reached
                LDA   INBUFF,X        ;YES, So Not a Keyword
                BPL   PUTTOK          ;Copy Char "As Is"; Always Taken
; 
; ------------------------------------------------------------------------------
; End of Line  (In case we're in Direct Mode)
; ------------------------------------------------------------------------------
LINEND          STA   LINEIMAGE+2,Y   ;Set End of Input Line to $00
                DEC   TXTPTR+1        ;Set Next Input Character, High
                LDA   #$FF            ;Set TXTPTR = INPUT_BUFFER - 1 = $01FF
                STA   TXTPTR          ;Set Next Input Character, Low
                RTS                   ;Return to Caller

; ==============================================================================
; Search for a Specific Line
; ==============================================================================
; On Entry: Search the Program for the Line whose Number is in LINNUM.
; On  Exit: Carry is Set If Found, or Clear If Not Found, &
;           LOWTR points to Line If Found, or to Next Line If Not Found.
; ==============================================================================
; LINNUM = Line # to Find:
;            If Not Found: Carry = 0; LOWTR Points at Next Line
;                If Found: Carry = 1; LOWTR Points at Line Specified
; ==============================================================================
; 
; Search for Line # (from Start of Program):
FNDLIN          LDA   TXTTAB          ;Get Start of Program, Low
                LDX   TXTTAB+1        ;Get Start of Program, High
;                                     ;Start Search from: [(A,X)={Low,High}]=[*]
FNDLIN2         LDY   #1              ;Set Indirect Addressing Index to +1
                STA   LOWTR           ;Set Line Pointer, Low                 [*]
                STX   LOWTR+1         ;Set Line Pointer, High
                LDA   (LOWTR),Y       ;Get 2nd byte in Program Line
                BEQ   FL_NOTFND       ;Branch If End of Program (=0)
                INY                   ;Set Indirect Addressing Index to +2
                INY                   ;Set Indirect Addressing Index to +3
                LDA   LINNUM+1        ;Get Line # to Find, High
                CMP   (LOWTR),Y       ;Compare # to Program Line Number, High 
                BCC   BAS_RTS02       ;BLT: If Not Found, Return to Caller 
                BEQ   FL_CHKLO        ;If Found, Check Program Line Number, Low 
                DEY                   ;Set Indirect Addressing Index to +2
                BNE   FL_NXTLIN       ;Always Taken
FL_CHKLO        LDA   LINNUM          ;Get Line # to Find, Low
                DEY                   ;Set Indirect Addressing Index to +2
                CMP   (LOWTR),Y       ;Compare # to Program Line Number, Low
                BCC   BAS_RTS02       ;BLT: If Not Found, Return to Caller
                BEQ   BAS_RTS02       ;If Found (Carry Set), Return to Caller
FL_NXTLIN       DEY                   ;Set Indirect Addressing Index to +1
                LDA   (LOWTR),Y       ;Get Next Line Address (Forward Link), High
                TAX                   ;X-Reg is Line Pointer, High           [*]
                DEY                   ;Set Indirect Addressing Index to +0
                LDA   (LOWTR),Y       ;Get Next Line Address (Forward Link), Low
                BCS   FNDLIN2         ;A-Reg is Line Pointer, Low; Always Taken

FL_NOTFND       CLC                   ;Return Carry Clear (=0)
BAS_RTS02       RTS                   ;Return to Caller

; ==============================================================================
; "NEW" Statement: Immediate and Deferred; No parameters; Deletes current
;                  program and all variables.  [Initializes for a NEW Program!]
; ==============================================================================
; 
NEW             BNE   BAS_RTS02       ;Return to Caller if more to Statement
SCRTCH          LDA   #$00            ;No more to it, so do it!
                STA   AUTORUN         ;Clear AutoRun: UNLOCK/Enable User Commands
                TAY                   ;Clear Indirect Addressing Index
                STA   (TXTTAB),Y      ;Clear Forward Link, Low, at Program Start
                INY                   ;Set Indirect Addressing Index to +1
                STA   (TXTTAB),Y      ;Clear Forward Link, High, at Program Start
                LDA   TXTTAB          ;Get Start of Program Pointer, Low
;                                     ;The Carry Flag is not Cleared here,
;                                     ;so NEW usually adds 3, whereas FP adds 2:
                ADC   #$02            ;Carry is (what it was at entry) Not Known!
                STA   VARTAB          ;Set Start of Variables Pointer, Low
                STA   PRGEND          ;Set End of Program Pointer, Low
                LDA   TXTTAB+1        ;Get Start of Program Pointer, High
                ADC   #$00            ;Add in the Carry bit (Should be Clear!)
                STA   VARTAB+1        ;Set Start of Variables Pointer, High
                STA   PRGEND+1        ;Set End of Program Pointer, High
; ------------------------------------------------------------------------------
SETPTRS         JSR   CLRTXTPTR       ;Reset TXTPTR to TXTTAB-1, Start of Program
                LDA   #$00            ;Clear the Accumulator Register
;                                     ;This could have been DFB $2C, a fake BIT 
;                                     ;OpCode to skip the next line, but this
;                                     ;way also prevents next branch from being
;                                     ;taken
; 
; ==============================================================================
; "CLEAR" Statement: Immediate and Deferred; No parameters; Zeroes all
;                    variables, arrays and strings; Resets pointers and stacks
; ==============================================================================
; 
CLEAR           BNE   BAS_RTS03       ;Return to Caller if NOT at Statement End
;                                     ;NOT Statement End; more to it, so do it!
;                                     ;Clear String Area: [(A,Y)={Low,High}]=[*]
CLEARC          LDA   MEMSIZ          ;Get End of String Space (HIMEM), Low  [*]
                LDY   MEMSIZ+1        ;Get End of String Space (HIMEM), High
                STA   FRETOP          ;Set Start of String Storage Pointer, Low
                STY   FRETOP+1        ;Set Start of String Storage Pointer, High
;                                     ;Clear Array Area:
                LDA   VARTAB          ;Get Start of Variables Pointer, Low   [*]
                LDY   VARTAB+1        ;Get Start of Variables Pointer, High
                STA   ARYTAB          ;Set Start of Arrays Pointer, Low      [*]
                STY   ARYTAB+1        ;Set Start of Arrays Pointer, High
;                                     ;Clear StorageEnd/FreeSpaceStart Pointer:
                STA   STREND          ;Set StorageEnd/FreSpcStrt Ptr, Low    [*]
                STY   STREND+1        ;Set StorageEnd/FreSpcStrt Ptr, High
                JSR   RESTORE         ;Reset Data List Pointer back to its Start
; ==============================================================================
; Initialize Stack Pointer: Reset STACK to start at $01F8
; ==============================================================================
STKINI          LDX   #TEMPST         ;Get Start Addrs of Temp String Descriptors
                STX   TEMPPT          ;Set SD Stack: Next Temp Descriptor Pointer
; ------------------------------------------------------------------------------
; Reset/Move (Top of) Stack Pointer & Keep/Move current Return Address, too:
; ------------------------------------------------------------------------------
                PLA                   ;Pull Return Address, Low              [*]
                TAY                   ;Save it in Y-Reg
                PLA                   ;Pull Return Address, High             [*]
;                                     ;Save it in A-Reg
; ------------------------------------------------------------------------------
; Keep Top of Stack for Input Line Image: Forward Link & Line Number (4 bytes)+1
; ------------------------------------------------------------------------------
                LDX   #$F8            ;Start Stack at $1F8 (Could have used $FB)
                TXS                   ;leaving room for Parsing Input Lines
;                                     ;[Bill said this was a typographical input
;                                     ;error, because $FB looks a lot like $F8!]
; ------------------------------------------------------------------------------
; Restore current Return Address at new Top of Stack:
; ------------------------------------------------------------------------------
;                                     ;Restore from A-Reg:
                PHA                   ;Push Return Address, High             [*]
                TYA                   ;Restore from Y-Reg:
                PHA                   ;Push Return Address, Low              [*]
; ------------------------------------------------------------------------------
; Finish Stack Init:
; ------------------------------------------------------------------------------
                LDA   #$00            ;Clear the Accumulator Register
                STA   OLDTEXT+1       ;Clear Pointer, High: Defeats CONT Command
                STA   SUBFLG          ;Allow Subscripting
BAS_RTS03       RTS                   ;Return to Caller

; ==============================================================================
; Reset TXTPTR to TXTTAB-1, Start of Program
; ==============================================================================
; 
CLRTXTPTR       CLC                   ;Prepare for Add with Carry
                LDA   TXTTAB          ;Get Start of Program Pointer, Low
                ADC   #$FF            ;Add -1 (or Subtract 1)
                STA   TXTPTR          ;Set CHRGET's Next Char/Token Pointer, Low
                LDA   TXTTAB+1        ;Get Start of Program Pointer, High
                ADC   #$FF            ;Add -1 (or Subtract 1)
                STA   TXTPTR+1        ;Set CHRGET's Next Char/Token Pointer, High
                RTS                   ;Return to Caller

; ==============================================================================
; "LIST" Statement: Immediate and Deferred; Parms: [LineNum1] [[-|,] LineNum2];
;                   Lists the current Applesoft BASIC program or any part of it
; ==============================================================================
; 
LIST            BCC   STRTRNG         ;BLT: Branch if No Line Number Specified
                BEQ   STRTRNG         ;(<|=) Branch if No Line Number Specified
                CMP   #TOK_MINUS      ;Is it a Dash?
                BEQ   STRTRNG         ;It is a Dash, Start at Line 0
                CMP   #','            ;Is it a Comma?
                BNE   BAS_RTS03       ;NOT a Comma, Error, Return to Caller
; ----------------------------------- ;Start at Line 0
STRTRNG         JSR   LINGET          ;Set LINNUM to Start of Range
                JSR   FNDLIN          ;Find, Convert, & Point LOWTR at 1st Line
                JSR   CHRGOT          ;Get Character Got; Is a Range Specified?
                BEQ   MAINLST         ;Branch if a Range is Not specified
                CMP   #TOK_MINUS      ;Is it a Dash?
                BEQ   ENDRNG          ;It is a Dash, End at Line Number Specified
                CMP   #','            ;Is it a Comma?
                BNE   BAS_RTS02       ;NOT a Comma, Error, Return to Caller
; ------------------------------------------------------------------------------
ENDRNG          JSR   CHRGET          ;Get Next Character: End Line Number
                JSR   LINGET          ;Set LINNUM to End of Range
                BNE   BAS_RTS03       ;Branch If Syntax Err
; ------------------------------------------------------------------------------
MAINLST         PLA                   ;Pull/Discard Return Address, Lo then Hi
                PLA                   ;(Will Return via JMP NEWSTT)
                LDA   LINNUM          ;Check for a Second Number
                ORA   LINNUM+1        ;Any bit set? [(Low>0) OR (High>0)]<>0
                BNE   LSTNXTLIN       ;YES, there is a Second Number
                LDA   #$FF            ;NO Second Number; Maximize End Range
                STA   LINNUM          ;Set Line Number, Low
                STA   LINNUM+1        ;Set Line Number, High
; ------------------------------------------------------------------------------
LSTNXTLIN       LDY   #1              ;Set Indirect Addressing Index to 1
                LDA   (LOWTR),Y       ;High Byte of Link
                BEQ   LISTED          ;End of Program
                JSR   ISCTRLCH        ;Check if Ctrl+C has been typed
                JSR   CRDO            ;NO, Print a Carriage <Return> Character
                INY                   ;Set Indirect Addressing Index to 2
                LDA   (LOWTR),Y       ;Get Line Number, Low
                TAX                   ;Set X-Reg with it
                INY                   ;Set Indirect Addressing Index to 3
                LDA   (LOWTR),Y       ;Get Line Number, High
                CMP   LINNUM+1        ;Compare it to End of Range, High
                BNE   LSTD            ;Range Done?
                CPX   LINNUM          ;Compare X-Reg to End of Range, Low
                BEQ   LST1            ;On Last Line of Range
LSTD            BCS   LISTED          ;BGE: Range Done
; ==============================================================================
; LIST ONE LINE
; ------------------------------------------------------------------------------
LST1            STY   FORPTR          ;Save Indirect Addressing Index (=3)
                JSR   LINPRT          ;Print Line Number from (X,A)
                LDA   #' '            ;Get a SPACE Character
LISTLINE        LDY   FORPTR          ;Restore Indirect Addressing Index (=3)
                AND   #%01111111      ;Assure character is Low ASCII 
SNDCHR          JSR   OUTDO           ;Print Character in A-Reg
;                                     ;If Past Column 33, Start a New Line:
                LDA   CH              ;Get Horizontal Cursor Position
                CMP   #33             ;If CH is over 32, Print a CR & Tab(5)
                BCC   NOCRTAB         ;BLT: Else, Branch (if less than 33)
                JSR   CRDO            ;Print a Carriage <Return> Character
                LDA   #5              ;Indent Cursor 5 spaces
                STA   CH              ;Set Horizontal Cursor Position
NOCRTAB         INY                   ;Advance Indirect Addressing Index
                LDA   (LOWTR),Y       ;Get Next Char/Token in Line being listed
                BNE   TOKEN           ;Branch if Not End of Line yet
; ----------------------------------- ;End of Line (A-Reg=0)
                TAY                   ;Set Indirect Addressing Index to 0
                LDA   (LOWTR),Y       ;Get Link to Next Line, Low
                TAX                   ;Save it in X-Reg: Forward Link, Low
                INY                   ;Set Indirect Addressing Index to 1
                LDA   (LOWTR),Y       ;Get Link to Next Line, High
                STX   LOWTR           ;Set Pointer to Next Line, Low
                STA   LOWTR+1         ;Set Pointer to Next Line, High
                BNE   LSTNXTLIN       ;If Not at Last Line, List Next Line
;                                     ;Branch if Not End of Program
; ----------------------------------- ;End of Program, Put Cursor on a New Line
LISTED          LDA   #RTNL           ;Get a Carriage Return Character
                JSR   OUTDO           ;Print Character in A-Reg
                JMP   NEWSTT          ;Execute a New Statement

; ==============================================================================
; Get Character from Table; Pointer is (FAC)
; ------------------------------------------------------------------------------
GETCHAR         INY                   ;Advance Indirect Addressing Index
                BNE   GC1             ;Skip Advancing Pointer, High
                INC   FAC+1           ;Advance Table Pointer, High
GC1             LDA   (FAC),Y         ;Get Character from Table
                RTS                   ;Return to Caller

; ==============================================================================
; Is it a Token?
; ------------------------------------------------------------------------------
; There are 107 Applesoft BASIC Tokens ranging in value from 128 to 234 ($80 to
; $EA).  Hexadecimally these Token values are negative numbers with their
; highest bit set.  Subtracing 127 ($7F) from those values gives them ordinal
; values from 1 to 107 ($01 to $6B).  Hexadecimally these ordinal values are
; positive numbers with their highest bit clear.  Token Names in the Token Name
; Table vary in length, but they are Dextral Character Inverted (DCI), meaning
; that their characters are all low ASCII except for the last character in each
; Token Name, which is high ASCII.  This routine uses these facts to scan
; through the Token Name Table to find the location of a Token Name based on its
; Token value converted to its ordinal value.   Also, to help with this task, it
; uses the GETCHAR subroutine just above.  The FAC is used to hold the location.
; ------------------------------------------------------------------------------
TOKEN           BPL   SNDCHR          ;If Not a Token, Send Character (Branch)
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #$7F            ;Convert Token value to an ordinal Index
                TAX                   ;Save Count-Down-Index
                STY   FORPTR          ;Save Line Pointer
                LDY   #<TKNMTBL       ;Get Table Address, Low
                STY   FAC             ;Point FAC to Table, Low
                LDY   #>TKNMTBL-$100  ;Get Table Address, High
;                       ^^^^^^^^^^^^  ;Why does this display this way?
;                                     ;It should be minus one!
                STY   FAC+1           ;Point FAC to Table, High
; ------------------------------------------------------------------------------
; Skip through Token Names until Count-Down-Index depletes itself, thus
; loacating the Token Name needed:
; ------------------------------------------------------------------------------
                LDY   #$FF            ;Initialize Token Names Character Counter
SKPTK           DEX                   ;Count down Token Names via X-Reg
                BEQ   PT              ;Branch when Token Name needed is reached
TOKL            JSR   GETCHAR         ;Inc(Y), Get Char from Table; Ptr is (FAC)
                BPL   TOKL            ;Names are Dextral Character Inverted (DCI)
                BMI   SKPTK           ;Do Next Token Name; Always Taken

; ------------------------------------------------------------------------------
; Print a Space, then the Token Name:
; ------------------------------------------------------------------------------
PT              LDA   #' '            ;Get a Space Character
                JSR   OUTDO           ;Print the Space Character
TOKLP           JSR   GETCHAR         ;Inc(Y), Get Char from Table; Ptr is (FAC)
                BMI   TOKDUN          ;Got Last Character of Token Name
                JSR   OUTDO           ;Print Character in A-Reg
                BNE   TOKLP           ;Names are Dextral Character Inverted (DCI)
TOKDUN          JSR   OUTDO           ;Print Last Character of Token Name
                LDA   #' '            ;Get a SPACE Character to End TN with
                BNE   LISTLINE        ;Continue Listing the Line; Always Taken

; ==============================================================================
; "FOR" Statement: Immediate and Deferred; Parameters:
;                  FOR real avar = aexpr1 TO aexpr2 [STEP aexpr3];
;                  See also: "TO Phrase", "STEP Phrase", & "NEXT Statement"
; ==============================================================================
; FOR Pushes 18 bytes onto the STACK:
; ------------------------------------------------------------------------------
;   2 - TXTPTR
;   2 - Line Number
;   5 - Initial (Current) FOR Variable Value
;   1 - Step Sign
;   5 - Step Value
;   2 - Address of FOR Variable in VARTAB
;   1 - FOR Token ($81)
; ==============================================================================
FOR             LDA   #$80            ;Prepare to Set a Flag
                STA   SUBFLG          ;Set Subscripts Not Allowed
                JSR   LET             ;Do <Var> = <Exp>, Store Addr In FORPTR
                JSR   GETFORPTR       ;Is this FOR Variable Active?
                BNE   FOR2            ;NO, it is Inactive;
;                                     ;(X)=(S) after scanning all Frames; Branch
                TXA                   ;YES, Cancel It and Enclosed Loops;
;                                     ;(X)=(S) of Frame Found
                ADC   #$0F            ;Carry is Set, so this adds 16  [How know?]
                TAX                   ;X was already S+2  [How do you know this?]
                TXS                   ;Reset Stack Pointer anyway
FOR2            PLA                   ;Pull/Discard Return Address, Lo then Hi
                PLA                   ;(FOR will Return to Caller Indirectly!)
                LDA   #9              ;Assure sufficient STACK Space:
                JSR   CHKMEM          ;Check Stack Pointer >= $48 (72=9*2+54)
;              Point to next Statement and Push Statement Address onto Stack:
                JSR   DATA_END        ;Get offset in Y-Reg to next ":" or EOL
                CLC                   ;Prepare for Add with Carry
                TYA                   ;Get offset in A-Reg to next ":" or EOL
                ADC   TXTPTR          ;Add Next Char/Token Pointer, Low
                PHA                   ;Push Next Statement Address, Low
                LDA   TXTPTR+1        ;Get Next Char/Token Pointer, High
                ADC   #$00            ;Add the Carry bit
                PHA                   ;Push Next Statement Address, High
                LDA   CURLIN+1        ;Get Line Number, High
                PHA                   ;Push Line Number, High
                LDA   CURLIN          ;Get Line Number, Low
                PHA                   ;Push Line Number, Low
; ==============================================================================
; TO Phrase: Required Second Part of FOR Statement; Parameters:
;            FOR real avar = aexpr1 TO aexpr2 [STEP aexpr3];
;            See also: "FOR Statement", "STEP Statement", &
;                      "NEXT Statement"
; ==============================================================================
                LDA   #TOK_TO         ;Get TO Token value
                JSR   SYNCHR          ;Require TO: Check Current Char & Get Next
                JSR   CHKNUM          ;<Var> = <Exp> Must be Numeric
                JSR   FRMNUM          ;Get Final Value, Must be Numeric
; ----------------------------------- ;Pack Sign into FAC Mantissa:
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                ORA   #%01111111      ;Prepare to apply FAC Sign bit
                AND   FAC+1           ;Apply to FAC Mantissa, Top
                STA   FAC+1           ;Set Packed FAC Mantissa, Signed Top
; ------------------------------------------------------------------------------
; [See also (below): "Preamble about the Applesoft Floating Point Accumulators"]
; ------------------------------------------------------------------------------
; <<< BUG: Resulting TO values (above) are packed BEFORE being rounded (by PUSH-
; FAC).  This can result in a positive number being converted into a negative
; one (-1).  E.g., "10 FOR I=0 TO 2^35-1: PRINT I: NEXT" executes only once! >>>
; ------------------------------------------------------------------------------
;                                     ;Prep for Return to STEP via JMP (INDEX):
                LDA   #<STEP          ;Get STEP Statement Address, Low
                LDY   #>STEP          ;Get STEP Statement Address, High
                STA   INDEX           ;Set for JMP (Indirect): STEP Address, Low
                STY   INDEX+1         ;Set for JMP (Indirect): STEP Address, High
                JMP   PUSHFAC         ;Push FAC on STACK; Returns via JMP (INDEX)

; ==============================================================================
; STEP Phrase: Optional Third Part of FOR Statement; Parameters:
;              FOR real avar = aexpr1 TO aexpr2 [STEP aexpr3];
;              See also: "FOR Statement", "TO Phrase", & "NEXT Statement"
; ==============================================================================
STEP            LDA   #<CON_ONE       ;Get Constant One (1) Address, Low
                LDY   #>CON_ONE       ;Get Constant One (1) Address, High
;                                     ;Put STEP Default (1) in FAC ($8100000000)
                JSR   UPAY2FAC        ;Unpack FP# at [(A,Y)={Low,High}] into FAC
                JSR   CHRGOT          ;Get last Character Got
                CMP   #TOK_STEP       ;Is STEP Specified?
                BNE   ONESTEP         ;NO, Do One Step per Iteration
                JSR   CHRGET          ;YES, Get Step Amount Specified
                JSR   FRMNUM          ;Evaluate & Assure it is Numeric
ONESTEP         JSR   SIGN            ;Check its Sign:
;                                     ;FAC Sign (Neg|0|Pos) Returns (A)=(-1|0|1)
                JSR   PSHFACX         ;Push Step Amount; Returns via JMP (INDEX)
                LDA   FORPTR+1        ;Get [<Var> = <Exp>] Address, High
                PHA                   ;Push FOR Variable Pointer, High
                LDA   FORPTR          ;Get [<Var> = <Exp>] Address, Low
                PHA                   ;Push FOR Variable Pointer, Low
                LDA   #TOK_FOR        ;Get FOR Token
                PHA                   ;Push FOR Token
; ==============================================================================
; Execute a New Statement: Immediate or Deferred
; ==============================================================================
; Executes the Next Statement in a BASIC Program, if any.  (This does not mean
; the "NEXT" Statement in a FOR..NEXT Loop.  But, the Next Statement in a BASIC
; Program, could be the "NEXT" Statement in a FOR..NEXT Loop.  See also: "FOR
; Statement" & "NEXT Statement")
; ==============================================================================
NEWSTT          TSX                   ;Get Stack Pointer
                STX   REMSTK          ;Remember it: Save in Stack Pointer Safe
                JSR   ISCTRLCH        ;See if Control-C was typed
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                LDX   CURLIN+1        ;Are we in Direct Mode?
                INX                   ;Line Number is $FF if we're in Direct Mode
                BEQ   DIR             ;YES, Do Not Save these:
                STA   OLDTEXT         ;Save Next Char/Token Pointer, Low
                STY   OLDTEXT+1       ;Save Next Char/Token Pointer, High
DIR             LDY   #0              ;Clear Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Is it the End of the Line?
                BNE   COLONQ          ;NO, Branch to see if it is a Colon
;                                     ;YES, EOL; Is Forward Link a 0?
                LDY   #2              ;Set Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Get Forward Link, High
                CLC                   ;Prepare for Add with Carry
                BEQ   GOEND           ;YES, Forward Link is a 0, So we're Done!
;                                     ;NO, Fwd Link is Not a 0, So Not Done!
;                                     ;Save Line No. and Bump CHRGET's TXTPTR:
                INY                   ;Advance Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Get Line Number, Low
                STA   CURLIN          ;Set Current Line Number, Low
                INY                   ;Advance Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Get Line Number, High
                STA   CURLIN+1        ;Set Current Line Number, High
                TYA                   ;Prepare to Add (+2) with Carry Clear
                ADC   TXTPTR          ;Advance Next Char/Token Pointer, Low
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($D800-$DFFF): ROM Socket $D8 on a real Apple II Plus.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
                BCC   TRACEQ          ;Skip High Byte if NO Carry
                INC   TXTPTR+1        ;Advance Next Char/Token Pointer, High
TRACEQ          BIT   TRCFLG          ;Is TRACE ON? [(bit7)=(OFF<128/ON>127)]
                BPL   EXECUTE         ;NO, TRACE is OFF, Go Execute Statements
;                                     ;YES, TRACE is ON; Are we in Direct Mode?
                LDX   CURLIN+1        ;Get Current Line Number, High
                INX                   ;Line Number is $FF if in Direct Mode
                BEQ   EXECUTE         ;YES, Direct Command, Go Execute Statements
;                                     ;NO, Deferred Command, Print Tracing Info:
                LDA   #'#'            ;Get '#' Character in A-Reg
                JSR   OUTDO           ;Print '#' Character in A-Reg
                LDX   CURLIN          ;Get Current Line Number, Low
                LDA   CURLIN+1        ;Get Current Line Number, High
                JSR   LINPRT          ;Print the Line Number [(X,A)={Low,High}]
                JSR   OUTSP           ;Print a Space (' ') Character 
EXECUTE         JSR   CHRGET          ;Get first Character of Statement
                JSR   EXECSTMNT       ;And, Execute Statement
                JMP   NEWSTT          ;Then, Execute a New Statement

GOEND           BEQ   END4            ;Forward Link is a 0, So we're Done!

; ==============================================================================
; Execute a Statement:
; ==============================================================================
; On Entry: A-Reg contains first character of statement & Carry is Set
; At Exit:  Y-Reg contains Token Ordinal Doubled & Carry is Clear
; ==============================================================================
EXECSTMNT       BEQ   BAS_RTS05       ;Branch if Null Statement or at End of Line
; Entry Point to continue processing: ON GOTO/GOSUB
EXECSTMNT1      SBC   #$80            ;Is First Character a Token?   [($80-$EA)]
;                                     ;NOT a Token if Borrow used:   [(A)<($80)]
                BCC   ASSIGNMENT      ;BLT: If NOT Token, MUST BE an Assignment
;                                     ;YES, First Char is a Token    [($80-$EA)]
;                                     ;(C=1), (A)=(Token Ordinal)    [($00-$6A)]
                CMP   #$40            ;Is it a Routine-Statement?    [($00-$3F)]
                BCS   SYNERR          ;BGE: NO; Do Syntax Error
; ------------------------------------------------------------------------------
; Following is a very important part of Applesoft BASIC: It is the way we get to
; the Keyword/Command subroutines (via the Token Address Table) to Execute them!
; ------------------------------------------------------------------------------
;                                     ;(C=0), (A)=(Token Ordinal)    [($00-$6A)]
                ASL   A               ;YES, Double A-Reg to get Index
                TAY                   ;Set Indirect Addressing Index
                LDA   TKADTBL+1,Y     ;Get Routine Address, High
                PHA                   ;Push Routine Address, High     [High 1st]
                LDA   TKADTBL,Y       ;Get Routine Address, Low
                PHA                   ;Push Routine Address, Low       [Low 2nd]
                JMP   CHRGET          ;Go get Next Char/Token; RTS to Routine

; ------------------------------------------------------------------------------
ASSIGNMENT      JMP   LET             ;Handle the Assignment

; ==============================================================================
; Does A-Reg contain a Colon (Statement Separator)?
; ==============================================================================
COLONQ          CMP   #':'            ;Is A-Reg a Colon (:)?
                BEQ   TRACEQ          ;YES, Go see if TRACE is ON
SYNERR          JMP   SYNERROR        ;NO, Syntax Error

; ==============================================================================
; "RESTORE" Statement: Immediate and Deferred; No Parameters or Options;
;                      Resets the Data Pointer back to the beginning of all Data
; ==============================================================================
;                                                        [(A,Y)={Low,High}]=[*]
RESTORE         SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                LDA   TXTTAB          ;Get Start of Program, Low              [*]
                SBC   #1              ;[(A)=(Program Start)-1]=(Data Start), Low
                LDY   TXTTAB+1        ;Get Start of Program, High             [*]
                BCS   SETDA           ;No Borrow, So Skip High Byte
                DEY                   ;[(A)=(Program Start)-1]=(Data Start), High
SETDA           STA   DATPTR          ;Set Data Pointer, Low                  [*]
                STY   DATPTR+1        ;Set Data Pointer, High                 [*]
BAS_RTS05       RTS                   ;Return to Caller

; ==============================================================================
; Ctrl-C KeyPress: Immediate Only; No Parameters or Options; Causes a program
;                  to cease execution (with an Error Message) immediately
;                  after the statement that is currently being executed
; ==============================================================================
ISCTRLCH        LDA   KBD             ;See if Control-C was typed
                CMP   #CTRLCH         ;Compare Key/Character to High ASCII Ctrl-C
                BEQ   GETLOWKEY       ;A Control-C was typed, Branch over RTS
                RTS                   ;Control-C was Not typed, Return to Caller

GETLOWKEY       JSR   INCHR           ;Read a Key/Character and make it Low ASCII
; <<< This is NOT A BUG!  It has a purpose.  It should NOT be: "BIT $C010" as
;     per Bob Sander-Cederlof's "S-C DocuMentor: Applesoft" (see ** below).  >>>
; ------------------------------------------------------------------------------
; Entry Point to continue processing INPUT Statement when the input is a Ctrl-C:
ISONERRON       LDX   #CTRLCIRQ       ;Get "CTRL C INTERUPT ATTEMPTED" ONERR Code
                BIT   ERRFLG          ;Is ONERR GOTO Enabled?
                BPL   ISCTRLCL        ;NO, ONERR GOTO is Disabled, Jump over JMP
                JMP   ERRHNDLR        ;YES, Go to ONERR Handler, ONERR Code = 255

; ** Double check if Control-C was typed; This is final for both entry points!
ISCTRLCL        CMP   #CTRLCL         ;Compare Key/Character to Low ASCII Ctrl-C
; ------------------------------------------------------------------------------
; "ISCTRLC LDA KBD" got CTRLCH & "GETLOWKEY JSR INCHR" made it CTRLCL, so should
; pass both "STOP BCS END2" & "END2 BNE BAS_RTS06" tests below & STOP a program!
; ==============================================================================
; 
; 
; ==============================================================================
; "STOP" Statement: Immediate and Deferred; No Parameters or Options;
;                   Causes a program to cease execution (with an Error Message)
; ==============================================================================
; 
STOP            BCS   END2            ;If Carry Set, Don't Clear it, Skip next OP
; 
; ==============================================================================
; "END" Statement: Immediate and Deferred; No Parameters or Options;
;                  Causes a program to cease execution (w/o an Error Message)
; ==============================================================================
; 
END             CLC                   ;Clear the Carry Flag to END, Not to STOP!
END2            BNE   BAS_RTS06       ;Return if not Ctrl-C, STOP or END commands
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                LDX   CURLIN+1        ;Are we in Direct Mode?
                INX                   ;Line Number is $FF if we're in Direct Mode
                BEQ   END3            ;YES, Skip this Line Number Stuff:
                STA   OLDTEXT         ;Save Next Char/Token Pointer, Low
                STY   OLDTEXT+1       ;Save Next Char/Token Pointer, High
                LDA   CURLIN          ;Get Current Line Number, Low
                LDY   CURLIN+1        ;Get Current Line Number, High
                STA   OLDLIN          ;Save Current Line Number, Low
                STY   OLDLIN+1        ;Save Current Line Number, High
END3            PLA                   ;Pull/Discard Return Address, Low
                PLA                   ;Pull/Discard Return Address, High
END4            LDA   #<QT_BREAK      ;Get " BREAK" & Bell Error Message, Low
                LDY   #>QT_BREAK      ;Get " BREAK" & Bell Error Message, High
                BCC   GOSTART         ;If Carry Clear, END Program & Restart Warm
;                                     ;If Carry Set, STOP Program:
                JMP   PRERRLINO       ;Print Error Message & Restart Warm

GOSTART         JMP   RESTART         ;Do Warm Restart

; ==============================================================================
; "CONT" Statement: Immediate and Deferred; No Parameters or Options;
;                   Causes a program to resume execution at the next instruction
; ==============================================================================
; 
CONT            BNE   BAS_RTS06       ;Return to Caller if ? not CONT command
                LDX   #ERR_CANTCONT   ;Get "?Can't Continue" Error Message Index
                LDY   OLDTEXT+1       ;Get Old Char/Token Pointer, High
                BNE   CANCONT         ;Not at EOL/EOP: No Error, Jump over JMP
                JMP   ERROR           ;Go Print Error Message based on X-Reg

CANCONT         LDA   OLDTEXT         ;Get Old Char/Token Pointer, Low
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set Next Char/Token Pointer, High
                LDA   OLDLIN          ;Get Address of Last Line Executed, Low
                LDY   $78             ;Get Address of Last Line Executed, High
                STA   CURLIN          ;Reset Address of Current Line, Low
                STY   CURLIN+1        ;Reset Address of Current Line, High
BAS_RTS06       RTS                   ;Return to Caller

; ==============================================================================
; "SAVE" Command Statement: Immediate and Deferred; No Parameters or Options;
;                           Writes Program onto a Cassette Tape (Audio Output)
; ==============================================================================
;                                     ;Compute Program Length:
BAS_SAVE        SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                LDA   PRGEND          ;Get End of Program Pointer, Low
                SBC   TXTTAB          ;Subtract Start of Program Pointer, Low
                STA   LINNUM          ;Save Length of Program, Low
                LDA   PRGEND+1        ;Get End of Program Pointer, High
                SBC   TXTTAB+1        ;Subtract Start of Program Pointer, High
                STA   LINNUM+1        ;Save Length of Program, High
                JSR   VARTIO          ;Prepare to Write 3-Byte Header
                JSR   MON_WRITE       ;Write 3-Byte Header (Length & Lock Byte)
                JSR   PROGIO          ;Prepare to Write the Program
                JMP   MON_WRITE       ;Write the Program

; ==============================================================================
; "LOAD" Command Statement: Immediate and Deferred; No Parameters or Options;
;                           Reads a Program from a Cassette Tape (Audio Input)
; ==============================================================================
BAS_LOAD        JSR   VARTIO          ;Prepare to Read 3-Byte Header
                JSR   MON_READ        ;Read 3-Byte Header (Length & Lock Byte)
;                                     ;Compute Program End Address:
                CLC                   ;Prepare for Add with Carry
                LDA   TXTTAB          ;Get Start of Program Pointer, Low
                ADC   LINNUM          ;Add Length of Program, Low
                STA   VARTAB          ;Set Start of Variables Pointer, Low
                LDA   TXTTAB+1        ;Get Start of Program Pointer, High
                ADC   LINNUM+1        ;Add Length of Program, High
                STA   VARTAB+1        ;Set Start of Variables Pointer, High
                LDA   TEMPPT          ;Get Flag: If Set, Load Program from Tape
                STA   AUTORUN         ;Save Flag: If Set, Auto-Run after Loading
                JSR   PROGIO          ;Prepare to Read the Program
                JSR   MON_READ        ;Read the Program
                BIT   AUTORUN         ;If Negative, Auto-Run the Program
                BPL   BAS_LOADED      ;If Positive, Do NOT Auto-Run the Program;
;                                     ;(Wait for Next Cmd at Applesoft Prompt)
                JMP   SETPTRS         ;Auto-Run is ON, Run Program Now

BAS_LOADED      JMP   FIXLINKS        ;Auto-Run is OFF, Just Fix Forward Pointers

; ------------------------------------------------------------------------------
; Prepare to Read/Write a 3-Byte Header from/to a Cassette Tape (Audio I/O)
; ------------------------------------------------------------------------------
;                                     ;Point A1/A2 at LINNUM/TEMPPT ZP-Pointers:
VARTIO          LDA   #LINNUM         ;Get ZP-Address of Line Number Pointer, Low
                LDY   #$00            ;Get Address of All ZP-Objects, High
;                                     ;Set General Purpose A1-Reg:
                STA   A1L             ;Save Address of Line Number Pointer, Low
                STY   A1H             ;Save Address of Line Number Pointer, High
                LDA   #TEMPPT         ;Get ZP-Address of Temp Pointer, Low
;                                     ;Set General Purpose A2-Reg:
                STA   A2L             ;Save Address of Temp Pointer, Low
                STY   A2H             ;Save Address of Temp Pointer, High
                STY   AUTORUN         ;Clear the Auto-Run Flag
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; Prepare to Read/Write a Program from/to a Cassette Tape (Audio I/O)
; ------------------------------------------------------------------------------
;                                     ;Copy SOP/EOP Pointers into A1/A2:
PROGIO          LDA   TXTTAB          ;Get Start of Program Pointer, Low
                LDY   TXTTAB+1        ;Get Start of Program Pointer, High
;                                     ;Set General Purpose A1-Reg:
                STA   A1L             ;Save Start of Program Pointer, Low
                STY   A1H             ;Save Start of Program Pointer, High
                LDA   VARTAB          ;Get Start of Variables Pointer, Low
                LDY   VARTAB+1        ;Get Start of Variables Pointer, High
;                                     ;Set General Purpose A2-Reg:
                STA   A2L             ;Save Start of Variables Pointer, Low
                STY   A2H             ;Save Start of Variables Pointer, High
                RTS                   ;Return to Caller

; ==============================================================================
; "RUN" Command Statement: Immediate and Deferred; Optional Parameter: [LineNum]
; ==============================================================================
; Clears all variables, pointers, and stacks, then runs the program from its
; start, or from the line number given, or returns control to the user if there
; is no program in memory.
; ==============================================================================
RUN             PHP                   ;Save Processor Status while subtracting
                DEC   CURLIN+1        ;If in Direct Mode ($FF), make it Run Mode
                PLP                   ;Restore Processor Status
                BNE   RUNLIN          ;Branch if Given a Line Number
                JMP   SETPTRS         ;Else, Run from Program Start

RUNLIN          JSR   CLEARC          ;Clear Variables
                JMP   GO_TO_LINE      ;Run from Line Number Given

; ==============================================================================
; "GOSUB" Statement: Immediate and Deferred; Parameter: LineNum;
;                    Goes to a Subroutine at the line number given
; ==============================================================================
; Leaves 7 bytes on Stack:
;        2 -- Return Address (NEWSTT)
;        2 -- TXTPTR
;        2 -- Line #
;        1 -- Gosub Token ($B0)
; ==============================================================================
GOSUB           LDA   #$03            ;Check Stack Pointer >= $3C
                JSR   CHKMEM          ;Assure sufficient Stack space to do GOSUB
                LDA   TXTPTR+1        ;Get CHRGET's Next Char/Token Pointer, High
                PHA                   ;Push Next Char/Token Pointer, High
                LDA   TXTPTR          ;Get CHRGET's Next Char/Token Pointer, Low
                PHA                   ;Push Next Char/Token Pointer, Low
;                                     ;CURLIN = $FFXX if in Direct Mode
                LDA   CURLIN+1        ;Get Current Line Number, High
                PHA                   ;Push Current Line Number, High
                LDA   CURLIN          ;Get Current Line Number, Low
                PHA                   ;Push Current Line Number, Low
                LDA   #TOK_GOSUB      ;Get Gosub Token ($B0)
                PHA                   ;Push Gosub Token
GO_TO_LINE      JSR   CHRGOT          ;Get Char/Token Got w/o advancing TXTPTR
                JSR   GOTO            ;Run Subroutine at Line Number Given
                JMP   NEWSTT          ;Execute a New Statement

; ==============================================================================
; "GOTO" Statement: Immediate and Deferred; Parameter: LineNum; Goes to the line
;                   number given; Also used by RUN & GOSUB Statements
; ==============================================================================
GOTO            JSR   LINGET          ;Get GOTO Line
                JSR   REM_END         ;Point Y-Reg at EOL
                LDA   CURLIN+1        ;Get Current Line's Page Pointer
                CMP   LINNUM+1        ;Is Current Page < GOTO Page?
                BCS   GOTO_1          ;NO, Search from Program Start
                TYA                   ;YES, Search from Next Line
                SEC                   ;Prepare for Add with Carry Set (Adds 1)
                ADC   TXTPTR          ;Increment Next Char/Token Pointer, Low
                LDX   TXTPTR+1        ;Set Index (Next Char/Token Pointer, High)
;                                     ;Was a Page boundary crossed?
                BCC   GOTO_2          ;NO; Always Taken unless crossing boundary
;                                     ;YES, Page boundary crossed
                INX                   ;Inc Index (Next Char/Token Pointer, High)
                BCS   GOTO_2          ;Always Taken

GOTO_1          LDA   TXTTAB          ;Get Start of Program Pointer, Low
                LDX   TXTTAB+1        ;Get Start of Program Pointer, High
GOTO_2          JSR   FNDLIN2         ;Search for GOTO Line
                BCC   UNDFSTERR       ;If NOT There, Do Undefined Statement Error
;                                     ;Else, Point TXTPTR at GOTO Line:
;                                     ;Carry is Set for Subtract without Borrow
                LDA   LOWTR           ;Get General Purpose Pointer, Low
                SBC   #1              ;Subtract One, w/o Borrow [A-Data-!C]
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                LDA   EXPSGN          ;Get General Purpose Pointer, High
                SBC   #0              ;Subtract Zero with Borrow, if any
                STA   TXTPTR+1        ;Set Next Char/Token Pointer, High
BAS_RTS07       RTS                   ;Return to Caller (NEWSTT or GOSUB)

; ==============================================================================
; "POP" & "RETURN" Statements: Immediate and Deferred; No Parameters or Options
;                              (Both commands come here to this handler)
; ==============================================================================
; POP removes return address from top of stack only; RETURN removes return
; address from top of stack & uses it to go to statement following last GOSUB
; ==============================================================================
; 
POPRTN          BNE   BAS_RTS07       ;Return to Caller if A-Reg <> 0 upon entry
                LDA   #$FF            ;Prepare to Set FOR Pointer Flag
                STA   FORPTR          ;Set FOR Pointer Flag; <<< WRONG HALF! >>>
; 
; ==============================================================================
;       <<< BUG: Should be FORPTR+1 ($86); Should be $FFXX, Not $XXFF >>>
;                <<< SEE "ALL ABOUT APPLESOFT", PAGES 100-101 >>>
; <<<<<<<<< You can change it in (Apple II Plus) Emulator ROM images! >>>>>>>>>>
; ==============================================================================
; POP & RETURN Statements - BUG Serendipity Analysis:
; ==============================================================================
; Cornelis Bongers would never have discovered this bug if his subroutine was
; programmed correctly; like this below: |  NOT as he did it; like this below:
; +--------------------------------------+-------------------------------------+
; |  100 FOR I = 1 TO 100                |  100 FOR I = 1 TO 100               |
; |  110 IF A(I) = K THEN I = 100        |  110 IF A(I) = K THEN RETURN        |
; |  120 NEXT I : I = K : REM ALWAYS SO  |  120 NEXT I                         |
; |  130 RETURN : REM NATURE OF PROGRAM  |  130 RETURN                         |
; +--------------------------------------+-------------------------------------+
;  A FOR/NEXT loop needs to finish properly to not leave garbage behind. -- JPD
; ==============================================================================
; 
                JSR   GETFORPTR       ;To cancel FOR/NEXT in Subroutine
                TXS                   ;Set Stack Pointer (from X Returned)
                CMP   #TOK_GOSUB      ;Last GOSUB Found?
                BEQ   RETURN          ;NO, Do Return Routine
; ----------------------------------- ;User-Callable Error Entry Point:
NOGSBERR        LDX   #ERR_NOGOSUB    ;Throw a "?Return Without Gosub" Error
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ----------------------------------- ;Error Entry Point; Also User-Callable:
UNDFSTERR       LDX   #ERR_UNDEFSTAT  ;Throw an "?Undef'd Statement" Error
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ----------------------------------- ;Relay Error Entry Point; User-Callable:
SYNERR2         JMP   SYNERROR        ;Go Throw a "?Syntax" Error

; ------------------------------------------------------------------------------
RETURN          PLA                   ;Discard GOSUB Token
                PLA                   ;Pull Current Line Number Pointer, Low
                CPY   #$42            ;(Should be #TOK_POP*2 = $142) <<< BUG? >>>
                BEQ   PULL3           ;Branch if POP: Pull Line Number, High; & 
;                                     ;Pull Next Char/Token Pointer, Low & High;
;                                     ;Then, Return to Caller from POP3.
;                                     ;Else, Not POP, Restore Ptrs from Stack:
                STA   CURLIN          ;Restore Current Line Number Pointer, Low
                PLA                   ;Pull Current Line Number Pointer, High
                STA   CURLIN+1        ;Restore Current Line Number Pointer, High
                PLA                   ;Pull Next Char/Token Pointer, Low
                STA   TXTPTR          ;Restore Next Char/Token Pointer, Low
                PLA                   ;Pull Next Char/Token Pointer, High
                STA   TXTPTR+1        ;Restore Next Char/Token Pointer, High
; ==============================================================================
; "DATA" Statement: Skips to next COLON or EOL; Deferred Only; Parameters: 
;        DATA [literal|string|real|integer] [{, [literal|string|real|integer]}]
; ==============================================================================
; DATA Statements create a list of elements to be used by READ Statements
; ==============================================================================
DATA            JSR   DATA_END        ;Get Offset to Next ":" or EOL (into Y-Reg)
; ------------------------------------------------------------------------------
; Advance Next Char/Token Pointer by Adding Offset to Next ":" or EOL to it:
; ------------------------------------------------------------------------------
ADDON           TYA                   ;Get Offset to Next ":" or EOL (into A-Reg)
                CLC                   ;Prepare for Add with Carry
                ADC   TXTPTR          ;Add Next Char/Token Pointer, Low
                STA   TXTPTR          ;Reset Next Char/Token Pointer, Low
                BCC   BAS_RTS08       ;If No Carry-Over, Return to Caller
                INC   TXTPTR+1        ;Advance Next Char/Token Pointer, High
BAS_RTS08       RTS                   ;Return to Caller

; ==============================================================================
; Scan ahead & Get offset in Y-Reg to next ":" or EOL
; ==============================================================================
DATA_END        LDX   #':'            ;Get BASIC Inline Instruction Separator
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ==============================================================================
; REM_END: Scan ahead & Get offset in Y-Reg to next EOL  [Nothing else matters!]
; ==============================================================================
; Clear/Set Primary & Alternate String Terminators and Character/Offset Couter:
; ------------------------------------------------------------------------------
REM_END         LDX   #0              ;Get End of BASIC Program Line Char (EOL=0)
                STX   CHARAC          ;Set CHARAC: String Terminator, Alternate
                LDY   #0              ;Clear Character (Offset) Couter
                STY   ENDCHR          ;Clear ENDCHR: String Terminator, Primary
; ------------------------------------------------------------------------------
; Swap Primary & Alternate String Terminators (Swap ENDCHR with CHARAC):
; ------------------------------------------------------------------------------
; This is some kind of trick to count quote parity.  How does that work?
; It only works for the DATA_END Entry Point!  (See: 1,2,3 Before/Afters below.)
; ------------------------------------------------------------------------------
END_SWAP        LDA   ENDCHR          ;Get String Terminator, Primary
;                                     ;-------------------------- DATA or REM --
;                                     ;1. Before Quote Swap     = ( 0  or 0)
;                                     ;2. After 1st. Quote Swap = (':' or 0)
;                                     ;3. After 2nd. Quote Swap = ( 0  or 0)
;                                     ;-----------------------------------------
                LDX   CHARAC          ;Get String Terminator, Alternate
                STA   CHARAC          ;Set String Terminator, Alternate
;                                     ;-------------------------- DATA or REM --
;                                     ;1. Before Quote Swap     = (':' or 0)
;                                     ;2. After 1st. Quote Swap = ( 0  or 0)
;                                     ;3. After 2nd. Quote Swap = (':' or 0)
;                                     ;-----------------------------------------
                STX   ENDCHR          ;Set String Terminator, Primary
; ------------------------------------------------------------------------------
; Scan ahead & Get offset in Y-Reg to next ":" or EOL:
; ------------------------------------------------------------------------------
END_SCAN        LDA   (TXTPTR),Y      ;Get Next Character/Token
                BEQ   BAS_RTS08       ;EOL: A-Reg=0, Y=Offset; Return to Caller
                CMP   ENDCHR          ;Is it the End Character (':' or 0)?
                BEQ   BAS_RTS08       ;EOS: A-Reg=ENDCHR, Y=Offset; Rtn to Caller
                INY                   ;Advance Character (Offset) Couter
                CMP   #'"'            ;Is A-Reg a Quote Character?
                BNE   END_SCAN        ;NO, Loop-Back (Inner Loop)
;                                     ;YES, Switch (Quote) parity & continue:
                BEQ   END_SWAP        ; ... Loop-Back (Outer Loop); Always Taken

; ==============================================================================
; Pull Three Bytes Off of the Stack (Discards first two & Returns third): 
; ==============================================================================
PULL3           PLA                   ;Pull & Discard this byte
                PLA                   ;Pull & Discard this byte
                PLA                   ;Pull & Return  this byte
                RTS                   ;Return to Caller

; ==============================================================================
; "IF" Statement: Immediate and Deferred; Parameters:
;                 IF expression  THEN  instruction  [{: instruction}]
;                 IF expression  THEN  [GOTO]  linenumber
;                 IF expression [THEN]  GOTO   linenumber
; ==============================================================================
; If expression evaluates to False (conditions = 0), instructions following THEN
; are ignored & program execution continues from the next numbered line; If
; expression evaluates to True (conditions <> 0), instructions following THEN
; are executed.
; ==============================================================================
IF              JSR   FRMEVL          ;Evaluate expression & put result in FAC
                JSR   CHRGOT          ;Get last Character Got
                CMP   #TOK_GOTO       ;Is it a "GOTO" Token?
                BEQ   QTF             ;YES; Done checking token
                LDA   #TOK_THEN       ;NO; Is it a "THEN" Token?
                JSR   SYNCHR          ;NO; So (Maybe), Throw a "?Syntax" Error
QTF             LDA   FAC             ;YES; Is the IF Condition True or False?
                BNE   IF_TRUE         ;Branch if True
; ==============================================================================
; "REM" (or False IF) Statement: Immediate and Deferred; Parameters: {Char|"}
; ==============================================================================
; Allows text of any sort to be inserted into a program as a Reminder; 
; Statement-Separators (":") are ignored in Reminder statements; 
; Reminder statements are teminated only by a Return (CR/Null=EOL) character!
; ==============================================================================
REM             JSR   REM_END         ;(IF is False, so) Skip over rest of Line!
                BEQ   ADDON           ;Always Taken
; 
; ==============================================================================
; IF Statement (Continued)
; ==============================================================================
IF_TRUE         JSR   CHRGOT          ;Get last Character Got
;                                     ;Is it a Command Token or a Line Number?
                BCS   JGOCMD          ;Branch if Command Token
                JMP   GOTO            ;Else, Go to Line Number given

JGOCMD          JMP   EXECSTMNT       ;Execute Command

; ==============================================================================
; "ONGOTO" or "ONGOSUB" Statements: Deferred Only; Applesoft "CASE" Statements
;                       Parameters: ON aexpr GOTO  linenum {[, linenum]}
;                               or: ON aexpr GOSUB linenum {[, linenum]}
; ==============================================================================
ONGOTO          JSR   GETBYT          ;Convert (A) to Integer in (FAC+4) & (X)
                PHA                   ;Push Integer Result (Token?) onto Stack
                CMP   #TOK_GOSUB      ;Is it a "GOSUB" token?
                BEQ   ONGOCASE        ;YES, Done checking tokens
ONGOTOK         CMP   #TOK_GOTO       ;NO; Is it a "GOTO" token?
                BNE   SYNERR2         ;NO; So, Throw a "?Syntax" Error
ONGOCASE        DEC   FAC+4           ;YES; Counted to right Case Line # yet?
                BNE   ONGOFIND        ;NO; Keep looking
                PLA                   ;YES; Retrieve GOTO/GOSUB Code from Stack
                JMP   EXECSTMNT1      ;And Execute it

;                                     ;Find correct Case Line # 
ONGOFIND        JSR   CHRGET          ;Get Next Char/Token from Program Line
                JSR   LINGET          ;Convert ASC # to HEX # in LINNUM
                CMP   #','            ;Is Character a comma?
                BEQ   ONGOCASE        ;YES; Loop until Case found
                PLA                   ;Not found, so ignore ON...GOTO/GOSUB
BAS_RTS09       RTS                   ;Return to Caller

; ==============================================================================
; Convert ASC Number to HEX Number in LINNUM:
; ==============================================================================
; Enter with: Carry Set to just reset LINNUM to $0000;
;             Carry Clear to Convert ASCII Digits to BIN/HEX Number in LINNUM;
;             & First Digit of ASCII Number in A-Reg & TXTPTR pointing to next
;             (e.g., CHR just GOT by CHRGET).
; ==============================================================================
LINGET          LDX   #0              ;Prepare to Clear Line Number
                STX   LINNUM          ;Reset Line Number, Low
                STX   LINNUM+1        ;Reset Line Number, High
ASCHEX          BCS   BAS_RTS09       ;Exit Loop if Not a Digit; Return to Caller
;                                     ;(NXTDGT JSR CHRGET below does the carry)
;                                     ;Else; Subtract w/o Carry:
                SBC   #'/'            ;(#s after it) Convert Digit to Binary/Hex
                STA   CHARAC          ;Save Binary/Hex Digit
;                                     ;Check Range:
                LDA   LINNUM+1        ;Get Line Number, High
                STA   INDEX           ;Save Line Number, High; (for Multiplying)
                CMP   #$19            ;Line # too large (>63999)?
;                                     ;[(64,000=$FA00)/10]=[(6400=$1900)]
; ------------------------------------------------------------------------------
; Why is LINNUM already divided by 10?  Because, with each iteration, we are
; reading the most significant digit of a decimal line number (characters from
; left to right); which then gets multiplied by 10 before adding the next deci-
; mal digit to its value (all the while, converting ASC/decimal to BIN/hex).
; ------------------------------------------------------------------------------
                BCS   ONGOTOK         ;BGE: YES, Indirectly throw a Syntax Error
; ==============================================================================
; I could not reproduce the problem said to exist here, so I deduced why!--JPD:
; ==============================================================================
; This branches when LINNUM+1 (Line Number, High) gets up to $19.  It never goes
; past $19, so it can never reach $AB [which would cause catastrophe (below)];
; hense, this is not "<<< DANGEROUS CODE >>>" as said in the past!  Except, ...
; ------------------------------------------------------------------------------
; Supposedly, if (A)=$AB on the line above, ONGOTOK will compare equal and cause
; a catastrophic jump to [some location that does not make sense was given here]
; (for GOTO), or to other locations for other calls to LINGET.  You can see this
; if you first put BRK in [the location that does not make sense], then type
; GOTO 43776.  Any value in the range: 43776~44031 ($AB00~$ABFF) will cause the
; problem.  [Logically, this seems correct, but it doesn't happen!  ON (1)
; GOSUB/GOTO 43776 works fine as long as line 43776 exists in the program.]
; ------------------------------------------------------------------------------
; ... It will happen if you accidentally type a line number (in your list of
; line numbers) that is in the Range times 10: (437760~440310)=($6AE00~$6B7F6)]
; which are illegal line numbers > 63999.  [Who does that?  Shakey Fingers!]
; ------------------------------------------------------------------------------
; NEW
; 5  REM  ONGO.TEST
; 10 TT = 1: ON 1 GOSUB 43750  : REM BELOW RANGE
; 20 TT = 2: ON 1 GOTO  43760  : REM BELOW RANGE
; 30 TT = 3: ON 1 GOSUB 44040  : REM ABOVE RANGE
; 40 TT = 4: ON 1 GOTO  44050  : REM ABOVE RANGE
; 50 TT = 5: ON 1 GOSUB 44000  : REM INSIDE RANGE
; 60 TT = 6: ON 1 GOTO  44010  : REM INSIDE RANGE
; 63 TT = 7: ON 1 GOSUB 440600 : REM ILLEGAL LINE NO. INSIDE 10*RANGE
; 66 TT = 8: ON 1 GOTO  440700 : REM ILLEGAL LINE NO. INSIDE 10*RANGE
; 70 PRINT "PASSED ALL TESTS"
; 99 STOP
; 43750 PRINT "(";TT;") 1ST TEST ON GOSUB" : GET A$: RETURN
; 43760 PRINT "(";TT;") 1ST TEST ON GOTO"  : GET A$: GOTO 30
; 44000 PRINT "(";TT;") 3RD TEST ON GOSUB" : GET A$: RETURN
; 44010 PRINT "(";TT;") 3RD TEST ON GOTO"  : GET A$: GOTO 63
; 44040 PRINT "(";TT;") 2ND TEST ON GOSUB" : GET A$: RETURN
; 44050 PRINT "(";TT;") 2ND TEST ON GOTO"  : GET A$: GOTO 50
; 44060 PRINT "(";TT;") 4TH TEST ON GOSUB" : GET A$: RETURN
; 44070 PRINT "(";TT;") 4TH TEST ON GOTO"  : GET A$: GOTO 70
; ==============================================================================
;                                     ;Multiply by Ten:
                LDA   LINNUM          ;Get Line Number, Low
                ASL   A               ;Double Temp Line Number, Low          [2x]
                ROL   INDEX           ;Double & Add Carry to Temp Line Num, High
                ASL   A               ;Double Temp Line Number, Low          [4x]
                ROL   INDEX           ;Double & Add Carry to Temp Line Num, High
                ADC   LINNUM          ;Add Result back into Real Line Number, Low
                STA   LINNUM          ;Set Real Line Number, Low       [4x+1x=5x]
                LDA   INDEX           ;Get Temp Line Number, High            [4x]
                ADC   LINNUM+1        ;Add it to Real Line Number, High
                STA   LINNUM+1        ;Set Real Line Number, High      [4x+1x=5x]
                ASL   LINNUM          ;Double Real Line Number, Low   [2(5x)=10x]
                ROL   LINNUM+1        ;Double & Add Carry to Real Line Num, High
                LDA   LINNUM          ;Get Line Number, Low
                ADC   CHARAC          ;Add Digit (saved above)
                STA   LINNUM          ;Set Line Number, Low
                BCC   NXTDGT          ;If no Carry, Skip High Byte
                INC   LINNUM+1        ;Else, Add Carry (1) to Line Number, High
;                                     ; (INC = 3 cycles vs. ADC = 5 cycles)
NXTDGT          JSR   CHRGET          ;Get Next Char/Token
                JMP   ASCHEX          ;Convert Next Char/Token; (Exit if Not #)

; ==============================================================================
; "LET" Statement: Immediate & Deferred;
;       Parameters: [LET] avar[subscript] = aexp; [LET] svar[subscript] = sexp
; ==============================================================================
; The Variable Name (on the left) is assigned the Value of the Number or String
; Expression (on the right); the LET is optional.
; ==============================================================================
;                                     ;Do Var = Exp, Store Address In FORPTR:
LET             JSR   PTRGET          ;Locate Variable: Returns Address
;                                     ; in VARPTR & [(A,Y)={Low,High}]
                STA   FORPTR          ;Save Address of Variable In FORPTR, Lows
                STY   FORPTR+1        ;Save Address of Variable In FORPTR, Highs
                LDA   #TOK_EQUAL      ;Get Token for Equal Sign ("=")
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
                LDA   INTFLG          ;Get Integer Flag (Negative if Integer) 
                PHA                   ;Push/Save Integer Flag
                LDA   VALTYP          ;Get Variable Type ($00=Num, $FF=Str)
                PHA                   ;Push/Save Variable Type
                JSR   FRMEVL          ;Evaluate Expression Format; Result-->FAC
                PLA                   ;Pull/Retrieve ValTyp ($00=Num, $FF=Str)
                ROL   A               ;Rotate ValTyp Sign into Carry Flag
                JSR   CHKVAL          ;Is FAC Type Numeric ($00) or String ($FF)?
                BNE   LETSTR          ;If Not Numeric, Do Let for Strings
                PLA                   ;Pull/Retrieve Integer Flag (Neg if Int) 
; ------------------------------------------------------------------------------
; LET Integer Variable = Expression   (Parameters: [LET] avar[subscript] = aexp)
; ------------------------------------------------------------------------------
LETINT          BPL   LETREAL         ;Branch if Var is Flagged as Real Variable
; ----------------------------------- ;Else, Assure Packed FAC Integer Format:
                JSR   ROUND_FAC       ;Round FAC up to next 32-bit Integer
                JSR   AYINT           ;Truncate to 16-bits & Normalize Integer
; ----------------------------------- ;Store Packed FAC Integer Value in Var:
                LDY   #$00            ;Clear Indirect Addressing Index
                LDA   FAC+3           ;Get FAC Integer Value, Low
                STA   (FORPTR),Y      ;Save FAC Integer Value in Variable, Lows
                INY                   ;Advance Indirect Addressing Index
                LDA   FAC+4           ;Get FAC Integer Value, High
                STA   (FORPTR),Y      ;Save FAC Integer Value in Variable, Highs
; ----------------------------------- ;LET for Integers is done:
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; LET Real Variable = Expression      (Parameters: [LET] avar[subscript] = aexp)
; ------------------------------------------------------------------------------
;                                     ;Store Packed FAC Real/FP Value in Var:
LETREAL         JMP   SETFOR          ;Round FAC, & store where FORPNT points

; ------------------------------------------------------------------------------
; LET String Variable = Expression    (Parameters: [LET] svar[subscript] = sexp)
; ------------------------------------------------------------------------------
; Structure of a String Pointer Variable:
;      Byte 0: Variable Name, Character 1 (positive)
;           1: Variable Name, Character 2 (negative)
;           2: String Length        ]<
;           3: String Address, Low  ]<--<< String Descriptor
;           4: String Address, High ]<
;           5: Not Used
;           6: Not Used
; ------------------------------------------------------------------------------
LETSTR          PLA                   ;Pull/Discard Integer Flag
; ------------------------------------------------------------------------------
; Install String:                     ;Descriptor Adrs is in TMPVPTR (FAC+3,4)
;                                     ;Is String Data already in Storage Area?
; ----------------------------------- ;Test String Data Address, High:
PUTSTR          LDY   #2              ;Set Indirect Addressing Index to High Byte
                LDA   (TMPVPTR),Y     ;Get String Data Address, High  (FRETOP<It?)
                CMP   FRETOP+1        ;Compare to Top of Free Space, High
;                                     ;^(AKA: Bottom or Start of String Space)
                BCC   COPSTRDSC       ;YES, String Data is already in Storage Area
                BNE   STRDSC          ;NO, String Data is NOT in Storage Area!
; ----------------------------------- ;MAYBE, Test String Data Address, Low:
                DEY                   ;Set Indirect Addressing Index to Low Byte
                LDA   (TMPVPTR),Y     ;Get String Data Address, Low   (FRETOP<It?)
                CMP   FRETOP          ;Compare to Top of Free Space, Low
;                                     ;^(AKA: Bottom or Start of String Space)
                BCC   COPSTRDSC       ;YES, String Data is already in Storage Area
; ----------------------------------- ;NO, String Data is NOT in Storage Area!
;                                     ;(String Data may be inside the Program)
; Descriptor Exist?                   ;Does a String Descriptor/Variable exist?
; ----------------------------------- ;Test Descriptor Adrs, High: (VARTAB>It?)
STRDSC          LDY   TMPVPTR+1       ;Get Descriptor Address Pointer, High
                CPY   VARTAB+1        ;Compare to Start of Variables Pointer, High
                BCC   COPSTRDSC       ;NO, String Descriptor/Variable NonExistant
                BNE   NEWSTRDSC       ;YES, String Descriptor is among Variables
; ----------------------------------- ;MAYBE, Test Descriptor Address, Low:
                LDA   TMPVPTR         ;Get Descriptor Address Pointer, Low
                CMP   VARTAB          ;Compare to Start of Variables Pointer, Low
                BCS   NEWSTRDSC       ;YES, String Descriptor is among Variables
; ----------------------------------- ;NO, Str Descriptor/Variable NonExistant
;                                     ;Either: String Data is already in Storage
; Copy Descriptor                     ;Or: String Descriptor is NOT a Variable
; ----------------------------------- ;So, just Store String Descriptor: 
COPSTRDSC       LDA   TMPVPTR         ;Get Descriptor Address Pointer, Low
                LDY   TMPVPTR+1       ;Get Descriptor Address Pointer, High
                JMP   SAVSTRDSC       ;Store String Descriptor

; ----------------------------------- ;The String Descriptor is a Variable
;                                     ;But, String Data is not in String Area
; Make New Descriptor                 ;(String Data may be inside the Program)
; ----------------------------------- ;So, Make New String Descriptor:
NEWSTRDSC       LDY   #$00            ;Clear Indirect Addressing Index
                LDA   (TMPVPTR),Y     ;Get String's Length from Descriptor
                JSR   STRINI          ;Init Space to receive Descriptor & String
                LDA   DSCPTR          ;Get String Descriptor Pointer, Low
                LDY   DSCPTR+1        ;Get String Descriptor Pointer, High
                STA   STRNG1          ;Set MOVINS String Descriptor Pointer, Low
                STY   STRNG1+1        ;Set MOVINS String Descriptor Pointer, High
                JSR   MOVINS          ;Move/Install String in Storage Area
; ----------------------------------- ;FAC   = Temp Descriptor, String Length
; Store Descriptor                    ;FAC+1 = Temp Descriptor, String Addr, Lo
; ----------------------------------- ;FAC+2 = Temp Descriptor, String Addr, Hi
                LDA   #FAC            ;Get FAC Address (Descriptor to Free), Low 
                LDY   #>FAC           ;Get FAC Address (Descriptor to Free), High
; --------- Save Descriptor --------- ;Temp Descriptor Adrs: [(A,Y)={Low,High}]
SAVSTRDSC       STA   DSCPTR          ;Save Descriptor Address Pointer, Low
                STY   DSCPTR+1        ;Save Descriptor Address Pointer, High
                JSR   FRETMS          ;Free Descriptor w/o Freeing up String
; --------- Move Descriptor --------- ;Copy Descriptor into String Ptr Variable:
                LDY   #$00            ;Clear Indirect Addressing Index
                LDA   (DSCPTR),Y      ;Get String Length from Descriptor
                STA   (FORPTR),Y      ;Set Descriptor Variable, String Length 
                INY                   ;Advance Indirect Addressing Index
                LDA   (DSCPTR),Y      ;Get String Address, Low, from Descriptor
                STA   (FORPTR),Y      ;Set Descriptor Variable, String Addr, Low
                INY                   ;Advance Indirect Addressing Index
                LDA   (DSCPTR),Y      ;Get String Address, High, from Descriptor
                STA   (FORPTR),Y      ;Set Descriptor Var, String Addr, High
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; Print String
; ------------------------------------------------------------------------------
PRSTR           JSR   STRPRT          ;Print String at TMPVPTR (FAC+3,4)
                JSR   CHRGOT          ;Get Next Char/Token w/o advancing TXTPTR
; ==============================================================================
; "PRINT" Statement: Immediate & Deferred; Alias: "?" <- lists as PRINT;
; Parameters: PRINT|? [{expression} [{,|; [{expression}] }] ] [,|;]
;             PRINT|? <- a LF+CR is printed last unless followed by ","|";"
;             PRINT|? {expression;} <- ";" concatenates next [{expression}]
;             PRINT|? {;} <- followed by list of ";" is same as PRINT alone
;             PRINT|? {,} <- followed by list of "," tabs 1 field per comma
; ==============================================================================
PRINT           BEQ   CRDO            ;If Z=1, End of Statement: Print a <Return>
; Loop                                ;Continue processing Print Statement:
PRINT2          BEQ   BAS_RTS10       ;If Z=1, End of Statement: Return to Caller
                CMP   #TOK_TAB        ;(A)=>[TAB( Token]?  If so, sets C=1
                BEQ   PRTABSPC        ;If == then Go Print Spaces: TAB(X-Reg)
                CMP   #TOK_SPC        ;(A)=>[SPC( Token]?  If so, sets C=1
                CLC                   ;Countermand Comparison: Set C=0 for SPC(
                BEQ   PRTABSPC        ;If == then Go Print Spaces: SPC(X-Reg)
                CMP   #','            ;(A)=>","?  If so, sets C=1
                CLC                   ;Countermand Comparison: Set C=0 for ","
;                                     ;<<< Clear Carry is unnecessary here! >>>
                BEQ   PRCOMMA         ;If == then Go TAB to Next Comma Column
                CMP   #';'            ;(A)=>";"?  If so, sets C=1 for ";"
                BEQ   PRNXTCHR        ;If == then Go Print Next Character
                JSR   FRMEVL          ;Evaluate Expression
                BIT   VALTYP          ;Bit Variable Type ($00=Num, $FF=Str)
                BMI   PRSTR           ;If String Variable Type, Go Print String
                JSR   FOUT            ;Else, Number: Convert FAC into FOUT-Buffer
                JSR   STRLTRL         ;Make FOUT-Buffer into a Literal "String"
                JMP   PRSTR           ;Go Print the String

; ------------------------------------------------------------------------------
; Print a Carriage <Return> Character:
; ------------------------------------------------------------------------------
CRDO            LDA   #RTNL           ;Get a Carriage Return (Ctrl-M) Character
                JSR   OUTDO           ;Print Character in A-Reg
; ------------------------------------------------------------------------------
NEGATE          EOR   #%11111111      ;Invert All Bits in A-Reg << Why? Because:
;                                     ;1. It is used as a Subroutine by STRPRT
;                                     ;2. It's a good place, it does no harm! >>
; ------------------------------------------------------------------------------
BAS_RTS10       RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; TAB to Next Comma Column:
; ------------------------------------------------------------------------------
PRCOMMA         LDA   CH              ;Get Cursor's Horizontal Displacement
                CMP   #24             ;(40-16)=24 to keep cursor on screen
; ------------------------------------------------------------------------------
; <<< BUG: It Should be 32; It's a BUG if the Window Width is less than 33!  >>>
; <<< So, it should be based on Window Width (WNDWDTH=$21) less 16 columns.  >>>
; <<<<<<<<< You can change it in (Apple II Plus) Emulator ROM images! >>>>>>>>>>
; ------------------------------------------------------------------------------
                BCC   PRCMMA          ;Print NxtChr at Next Tab Column, Same Line
                JSR   CRDO            ;Print a Carriage <Return> Character
                BNE   PRNXTCHR        ;Print NxtChr at Start of Next Line; Always
; 
; ------------------------------------------------------------------------------
; Advance Cursor to Next Comma Column:
; ------------------------------------------------------------------------------
PRCMMA          ADC   #16             ;Advance 16 Columns, Same Line
                AND   #%11110000      ;Truncate to Column 16 or 32, Same Line
;                                     ;[%00110000=$30=48 would limit Cols more]
                STA   CH              ;Set Cursor's New Horizontal Displacement
                BCC   PRNXTCHR        ;Print NxtChr at Column 16|32; Always Taken
; 
; ------------------------------------------------------------------------------
; Evaluate Formula & Format of TAB(X) or SPC(X) Function:
; ------------------------------------------------------------------------------
PRTABSPC        PHP                   ;Remember: C=0 for SPC(X) or C=1 for TAB(X)
                JSR   GTBYTC          ;Get NxtChr & Eval Formula into FAC & X-Reg
                CMP   #')'            ;Should be last ChrGot for TAB(X) or SPC(X)
                BEQ   PRTAB           ;If == Go Print: TAB(X) or SPC(X)?
                JMP   SYNERROR        ;Else, Throw a "?Syntax" Error

; ------------------------------------------------------------------------------
; Print: TAB(X) or SPC(X)?
; ------------------------------------------------------------------------------
PRTAB           PLP                   ;Retrieve: C=0 for SPC(X) or C=1 for TAB(X)
                BCC   PRSPC           ;Branch if C=0; Print SPC(X-Reg)
;                                     ;Else, ... C=1; Print TAB(X-Reg)
;                                     ;[X-Reg was set via JSR GTBYTC (above)]
                DEX                   ;Reduce Column Counter to Prior Column
                TXA                   ;Calculate Space needed for TAB(X)
                SBC   CH              ;Subtract without Borrow [(A)=(X-CH-!C)]
                BCC   PRNXTCHR        ;If [(CH)<(A)], Already past that Column
                TAX                   ;SPC([(X)=(A)]) to the specified Column
PRSPC           INX                   ;Advance Column Counter
NXTSPC          DEX                   ;Reduce Column Counter
                BNE   DOSPC           ;Go Print a Space
; ------------------------------------------------------------------------------
; Print Next Character:
; ------------------------------------------------------------------------------
PRNXTCHR        JSR   CHRGET          ;Get Next Char/Token to Print
                JMP   PRINT2          ;Continue processing Print Statement (Loop)

; ------------------------------------------------------------------------------
; Print a Space:
; ------------------------------------------------------------------------------
DOSPC           JSR   OUTSP           ;Print a Space via COUT
                BNE   NXTSPC          ;Reduce Column Counter & Print Next Space
;                                     ;Always Taken
; 
; ==============================================================================
; Print String at [(A,Y)={Low,High}]; String Must End with a Zero or a Quote:
; ==============================================================================
STROUT          JSR   STRLTRL         ;Make FOUT-Buffer into a Literal "String"
; ==============================================================================
; Print String at TMPVPTR (FAC+3,4)
; ==============================================================================
STRPRT          JSR   FREFAC          ;Free up TMPVPTR & a Temp String to use
;                                     ;Returns Address in INDEX & Length in (A)
                TAX                   ;Set (X) = (Temp String Length);  [counter]
                LDY   #$00            ;Clear Indirect Addressing Index; [scanner]
                INX                   ;Advance (X) = (Temp String Length)
STRPRT_1        DEX                   ;Reduce (X) = (Temp String Length)
                BEQ   BAS_RTS10       ;Return to Caller when Done: (X)=(0)
                LDA   (INDEX),Y       ;Get Next Character from Temp String
                JSR   OUTDO           ;Print the Character
                INY                   ;Advance Indirect Addressing Index
                CMP   #RTNL           ;Was it a Carriage Return Character?
                BNE   STRPRT_1        ;NO; (Loop) Do Next Character
                JSR   NEGATE          ;Invert Bits [EOR #$FF would do it, too!]
                JMP   STRPRT_1        ;(Loop) Do Next Character

; ==============================================================================
; Print a Space Character:
; ==============================================================================
OUTSP           LDA   #' '            ;Print a Space via COUT
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ==============================================================================
; Print a Question Mark Character:
; ==============================================================================
OUTQUES         LDA   #'?'            ;Print a Question Mark via COUT
; 
; ==============================================================================
; Print Character in A-Reg
; ==============================================================================
; Note: POKE 243,32 [$20 in $F3 (FLASHBIT)] will convert output to lower case.
;       This can be cancelled by: POKE 243,0 ($00), NORMAL ($00), INVERSE ($00);
;       or FLASH ($40), POKE 243,64.
; ==============================================================================
OUTDO           ORA   #%10000000      ;Set High Bit; Make Character High ASCII
                CMP   #' ' | $80      ;Is it a Control or Visible Character?
                BCC   OUTDOCTRL       ;BLT: Branch if it is a Control Character
                ORA   FLASHBIT        ;Show (Flash=$40, Lowercase=$20, Else=$00)
OUTDOCTRL       JSR   COUT            ;Print A-Reg (via Output Device)
                AND   #%01111111      ;Clear High Bit; Make Character Low ASCII
                PHA                   ;Push/Save/Protect Character, temporarily
                LDA   SPDBYT          ;Get Output Speed Limit
                JSR   MON_WAIT        ;Limit Output Speed
                PLA                   ;Pull/Retieve Saved/Protected Character
                RTS                   ;Return to Caller

; ==============================================================================
; Input Conversion Error: Illegal character in numeric field
; ==============================================================================
;                                     ;Must resolve INPUT, READ, & GET
INPUTERR        LDA   INPUTFLG        ;Get Type ($00=INPUT, $40=GET, $98=READ)
                BEQ   RESPERR         ;Taken if INPUT
                BMI   READERR         ;Taken if READ
                LDY   #$FF            ;Else, from a GET
                BNE   ERRLINE         ;Always Taken

; ------------------------------------------------------------------------------
;                                     ;Tell where DATA is, rather than READ:
READERR         LDA   DATLIN          ;Get Now DATA Statement Line Number, Low
                LDY   DATLIN+1        ;Get Now DATA Statement Line Number, High
; ------------------------------------------------------------------------------
ERRLINE         STA   CURLIN          ;Set Current Applesoft Line Number, Low
                STY   CURLIN+1        ;Set Current Applesoft Line Number, High
                JMP   SYNERROR        ;Go Throw a "?Syntax" Error

; ==============================================================================
; Input Error:
; ==============================================================================
INPERR          PLA                   ;Pull/Retrieve Last Character Got
; ------------------------------------------------------------------------------
RESPERR         BIT   ERRFLG          ;Is ON ERR turned on?
                BPL   DOREENTRY       ;NO, Give Reentry a try
; ----------------------------------- ;User-Callable Error Entry Point:
BADRESPERR      LDX   #ERR_BADRESP    ;Get 'Bad Response to Input' Error Code
                JMP   ERRHNDLR        ;Go to Error Handler (Part 2)

; ------------------------------------------------------------------------------
DOREENTRY       LDA   #<ERR_REENTRY   ;Get REENTER INPUT Error Message Addr, Low
                LDY   #>ERR_REENTRY   ;Get REENTER INPUT Error Message Addr, High
                JSR   STROUT          ;Print String at [(A,Y)={Low,High}]
                LDA   OLDTEXT         ;Get Applesoft Old Text Pointer, Low
                LDY   OLDTEXT+1       ;Get Applesoft Old Text Pointer, High
                STA   TXTPTR          ;Set CHRGET's Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set CHRGET's Next Char/Token Pointer, High
                RTS                   ;Return to Caller

; ==============================================================================
; "GET" Statement: Deferred Only; Parameter: GET var (one Applesoft variable)
; ==============================================================================
; Fetches one character from the keyboard w/o showing it on the screen & w/o
; requiring that the RETURN key be pressed.  (Best if var is a string variable.)
; ==============================================================================
; 
GET             JSR   ERRDIR          ;Illegal if in Direct Mode
;                                     ;Simulate Input [(X,Y)={Low,High}]:
                LDX   #<INBUFF+1      ;Get Input String Address, Low
                LDY   #>INBUFF        ;Get Input String Address, High
                LDA   #$00            ;Get Zero (End of Line Marker); Prepare to:
                STA   INBUFF+1        ;Reset Input Buffer w/ EOL Marker at start
                LDA   #$40            ;Setup for GET; (Not for INPUT nor READ)
                JSR   PRCSINLST       ;Then, Process Input List
;                                     ;<<< Could save a byte here with JMP >>>
                RTS                   ;Return to Caller

; ==============================================================================
; "INPUT" Statement: Deferred Only; Parameters: INPUT [string ;] var [{, var}];
;                    Reads a line of input from the current input device.
; ==============================================================================
INPUT           CMP   #'"'            ;Check for Optional Prompt String
                BNE   QOUT            ;Taken if No Prompt String Found
                JSR   STRTEXT         ;Make Prompt String Printable
                LDA   #';'            ;Must have a Semicolon (';') NOW!
                JSR   SYNCHR          ;Else: Throw a "?Syntax" Error
                JSR   STRPRT          ;Print the Prompt String
                JMP   DIRINERR        ;Skip over next line

QOUT            JSR   OUTQUES         ;Print Question Mark ("?") Prompt Character
DIRINERR        JSR   ERRDIR          ;Illegal if in Direct Mode
                LDA   #','            ;Get a Comma to:
                STA   INBUFF-1        ;Prime the Input Buffer
                JSR   INLIN           ;Read a Line & make Characters Low ASCII
                LDA   INBUFF          ;Get first input character again to check:
                CMP   #CTRLCL         ;Compare Key/Character to Low ASCII Ctrl-C
                BNE   INFLAG0         ;Setup for INPUT; Then, Process Input List
                JMP   ISONERRON       ;Go to "Is ONERR GOTO Enabled?"

; ==============================================================================
; This subroutine is only used once by the Process Input List subroutine:
; ==============================================================================
NEXTIN          JSR   OUTQUES         ;Print Question Mark ("?") Prompt Character
                JMP   INLIN           ;Go Read a Line & make Characters Low ASCII

; ==============================================================================
; "READ" Statement: Immediate & Deferred; Parameters: READ var [{,var}]; 
;                   Reads values from DATA statements in the body of the program
; ==============================================================================
;                                     ;[(X,Y)={Low,High}]
BAS_READ        LDX   DATPTR          ;Get Next DATA Statement Address, Low
                LDY   DATPTR+1        ;Get Next DATA Statement Address, High
                LDA   #$98            ;Setup for READ; Then, Process Input List:
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line (2 bytes)

; ==============================================================================
; Process Input List (for INPUT only; Not for GET nor READ):
; ==============================================================================
; 
INFLAG0         LDA   #$00            ;Get a Zero; for INPUT Processing only
; 
; ==============================================================================
; Process Input List (for INPUT, GET, or READ):
; ==============================================================================
; Upon Entry: (A) = Input Type = [INPUT=($00), GET=($40), READ=($98)]
;             [(X,Y)={Low,High}] = Input String Address
; ==============================================================================
; 
PRCSINLST       STA   INPUTFLG        ;Set Input Type Flag
                STX   INPTR           ;Set Input Pointer, Low
                STY   INPTR+1         ;Set Input Pointer, High
; 
; ==============================================================================
; Process Input Item:
; ==============================================================================
; 
PRCSINITM       JSR   PTRGET          ;Locate Variable: Returns Address in
;                                     ; VARPTR & [(A,Y)={Low,High}]
                STA   FORPTR          ;Set General Purpose Pointer, Low
                STY   FORPTR+1        ;Set General Purpose Pointer, High
; ----------------------------------- ;Save CHRGET's TXTPTR:
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                STA   TXPSV           ;Set TXTPTR Safe, Low
                STY   TXPSV+1         ;Set TXTPTR Safe, High
; ----------------------------------- ;Point CHRGET/TXTPTR at Input Device:
                LDX   INPTR           ;Get Input Pointer, Low
                LDY   INPTR+1         ;Get Input Pointer, High
                STX   TXTPTR          ;Set Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Check the Type of Input:
                JSR   CHRGOT          ;Get Last Char/Token w/o advancing TXTPTR
                BNE   INSTART         ;Char is NOT an End of Line or a Colon
                BIT   INPUTFLG        ;Get Type ($00=INPUT, $40=GET, $98=READ)
                BVC   PRCNOTGET       ;Branch if NOT a GET [($40)=(%01000000)]
; ----------------------------------- ;GET:
                JSR   RDKEY           ;Get in (A) & Make Cursor Character Flash
                AND   #%01111111      ;Assure Character is Low ASCII 
                STA   INBUFF          ;Put Character at Start of Input Buffer
                LDX   #<INBUFF-1      ;Get (Input Buffer, Low)-1 Address
                LDY   #>INBUFF-$100   ;Get (Input Buffer, High)-1 Address
;                       ^^^^^^^^^^^   ;Why does this display this way?
;                                     ;It should be minus one!
                BNE   PRCTXTPTR       ;Always Taken

; ----------------------------------- ;Check the Type of Input (continued):
PRCNOTGET       BMI   FINDATA         ;Branch if doing a READ
                JSR   OUTQUES         ;Else, doinig INPUT: Print "?" Prompt Char
                JSR   NEXTIN          ;Print another "?" & Finish Input Line
;                                     ;[(X,Y)={Low,High}] Ptr = (Input-Buffer)-1
; ----------------------------------- ;Point CHRGET/TXTPTR at [(X,Y)={Lo,Hi}]:
PRCTXTPTR       STX   TXTPTR          ;Set Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Input Start
INSTART         JSR   CHRGET          ;Get Next Input Char/Token
                BIT   VALTYP          ;Bit Variable Type ($00=Num, $FF=Str)
                BPL   NUMIN           ;Branch if Numeric
                BIT   INPUTFLG        ;Get Type ($00=INPUT, $40=GET, $98=READ)
                BVC   PUTCHR          ;Branch if NOT a GET [($40)=(%01000000)]
; ----------------------------------- ;GET:
                INX                   ;Advance Input Character Counter
                STX   TXTPTR          ;Set Next Char/Token Pointer, Low
                LDA   #0              ;Get a Zero; No other Terminators
                STA   CHARAC          ;Set Alternate String Terminator
                BEQ   PPENDCHR        ;Always Taken

; ----------------------------------- ;Set Terminatrs: Zero, Quote, Colon, Comma
PUTCHR          STA   CHARAC          ;Set Alternate String Terminator
                CMP   #'"'            ;Terminate on Zero or Quote
                BEQ   PUTENDCHR       ;Branch if (A) = (Quote Character)
                LDA   #':'            ;Terminate on Zero or Colon
                STA   CHARAC          ;Set Alternate String Terminator
                LDA   #','            ;Terminate on Zero or Comma
PPENDCHR        CLC                   ;Prepare for Add with Carry
PUTENDCHR       STA   ENDCHR          ;Set Primary String Terminator
;                                     ;Skip over Quotation Mark, If there was 1:
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                ADC   #0              ;Add in the Quote-Carry, If there was one 
                BCC   SKIPHIGH        ;If no Carry now, Skip Uping High Address
                INY                   ;Advance Input Address, High
SKIPHIGH        JSR   STRLTRL2        ;Make Input into a Literal "String"
                JSR   POINT           ;Point TXTPTR at String
                JSR   PUTSTR          ;Install the String/Variable
                JMP   INMORE          ;Skip over Number/Data Input lines

; ----------------------------------- ;Numeric Input?
NUMIN           PHA                   ;Push/Save Last Character Got
                LDA   INBUFF          ;Anything in Input Buffer?
                BEQ   INPFIN          ;NO; See if READ or INPUT
; ----------------------------------- ;READ/DATA Input
DATIN           PLA                   ;Pull/Retrieve Last Character Got
                JSR   FIN             ;Get FP Number at TXTPTR
                LDA   INTFLG          ;Negative for Integer Variable (%)
                JSR   LETINT          ;Store Result in Variable
; ----------------------------------- ;Input More?
INMORE          JSR   CHRGOT          ;Get Last Character Got
                BEQ   SWAPPTRS        ;Branch if End of Line or Colon
                CMP   #','            ;Comma in Input?
                BEQ   SWAPPTRS        ;YES; Go Swap Pointers
                JMP   INPUTERR        ;NO; Nothing else will do

; ----------------------------------- ;Swap Pointers:
; ----------------------------------- ;Save Position in Input Buffer
SWAPPTRS        LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                STA   INPTR           ;Set Input Pointer, Low
                STY   INPTR+1         ;Set Input Pointer, High
; ----------------------------------- ;Restore Program Pointer
                LDA   TXPSV           ;Retrieve old TXTPTR from Safe, Low
                LDY   TXPSV+1         ;Retrieve old TXTPTR from Safe, High
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Get Character Last Got from Program:
                JSR   CHRGOT          ;Get Last Character Got (from new old ptr)
                BEQ   INPDONE         ;Branch if End of Statement
                JSR   CHKCOM          ;Else: See if it is a Comma
                JMP   PRCSINITM       ;Loop-Back to Process Next Input Item

; ----------------------------------- ;READ/DATA Input?
INPFIN          LDA   INPUTFLG        ;Get Type ($00=INPUT, $40=GET, $98=READ)
                BNE   DATIN           ;YES: Go right back up, to READ/DATA Input
                JMP   INPERR          ;NO: Process Input Error; ReEntry Possible?

; ----------------------------------- ;Doing a READ; Find the Data:
FINDATA         JSR   DATA_END        ;Get offset in Y-Reg to next ":" or EOL
                INY                   ;Advance to Start of Next Statement or Line
                TAX                   ;Is it an EOL or a Colon?
                BNE   NXTSTT          ;Branch if it is a Colon
                LDX   #ERR_NODATA     ;Else, EOL: Might be Out Of Data
                INY                   ;Advance Indirect Addressing Index to:
                LDA   (TXTPTR),Y      ;Get High-Byte of Forward Link/Pointer
                BEQ   GERR            ;Branch if at End of the Program
;                                     ;^(Print Error Message based on X-Reg)
; ----------------------------------- ;Else, We are Out of Data; Point to first 
;                                     ;Text Character in Next Statement or Line:
                INY                   ;Advance Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Get the Line Number, Low
                STA   DATLIN          ;Set Current DATA Statement Line #, Low
                INY                   ;Advance Indirect Addressing Index
                LDA   (TXTPTR),Y      ;Get the Line Number, High
                INY                   ;Advance Indirect Addressing Index
                STA   DATLIN+1        ;Set Current DATA Statement Line #, High
; ----------------------------------- ;Do Next Statement or Line:
NXTSTT          LDA   (TXTPTR),Y      ;Get first Token of Statement
                TAX                   ;Save Token in X-Reg
                JSR   ADDON           ;Add Y-Reg to TXTPTR
                CPX   #TOK_DATA       ;Did we find a DATA Statement?
                BNE   FINDATA         ;NOT yet!  (Branch if doing a READ)
                JMP   INSTART         ;YES: GO Read it, too!

; ----------------------------------- ;No more INPUT requested
INPDONE         LDA   INPTR           ;Get Input Pointer, Low
                LDY   INPTR+1         ;Get Input Pointer, High
                LDX   INPUTFLG        ;Get Type ($00=INPUT, $40=GET, $98=READ)
                BPL   INDNSKIP        ;Done if INPUT (or GET); Skip over JMP:
                JMP   SETDA           ;Set Data Pointer to [(A,Y)={Low,High}]

; ----------------------------------- ;INPUT: Any more Characters in Line?
INDNSKIP        LDY   #0              ;Clear Indirect Addressing Index
                LDA   (INPTR),Y       ;Get Next Input Charcter in Line
                BEQ   BAS_RTS11       ;NO, All is Well (Branch if at End of Line)
;                                     ;YES; Throw Extra Ignored Input Error:
                LDA   #<ERR_EXTRA     ;Get Error Message Address, Low
                LDY   #>ERR_EXTRA     ;Get Error Message Address, High
                JMP   STROUT          ;Print Z-String at [(A,Y)={Low,High}]

BAS_RTS11       RTS                   ;Return to Caller

ERR_EXTRA       .ZSTR "?EXTRA IGNORED",$0D ;GET/INPUT Error
ERR_REENTRY     .ZSTR "?REENTER",$0D  ;INPUT Error

; ==============================================================================
; "NEXT" Statement: Immediate and Deferred; Parameters: NEXT [avar [{,avar}]];
;                   Required Fourth Part of FOR/TO/STEP/NEXT Loop Statements;
;                   See also: "FOR Statement", "TO Phrase", & "STEP Phrase"
; ==============================================================================
NEXT            BNE   VARNXT          ;Branch if Variable after NEXT is specified
                LDY   #0              ;Flag "None" by setting FORPNT+1 = 0 
                BEQ   SKPV            ;Always Taken

VARNXT          JSR   PTRGET          ;Locate Variable: Returns Address
;                                     ; in VARPTR & [(A,Y)={Low,High}]
SKPV            STA   FORPTR          ;Save Pointer to FOR Variable, Low
                STY   FORPTR+1        ;Save Pointer to FOR Variable, High
                JSR   GETFORPTR       ;Find Variable's FOR-Frame on the STACK
                BEQ   GOTFOR          ;Branch if FOR-Frame Found
; ----------------------------------- ;User-Callable Error Entry Point:
NOFORERR        LDX   #ERR_NOFOR      ;Else: Throw a "?Next Without For" Error
GERR            BEQ   JERROR          ;Always Taken: Print Error based on X-Reg

; ----------------------------------- ;X-Reg is our Stack Pointer Index Safe:
GOTFOR          TXS                   ;Set STACK Pointer to Variable's FOR-Frame
;                                     ; (This trims off any inner loops)
                INX                   ;+ Add 4 to get STEP Value STACK Address
                INX                   ;+
                INX                   ;+
                INX                   ;+
                TXA                   ;Get STEP Value STACK Address, Low
                INX                   ;+ Add 6 to get FOR Value STACK Address
                INX                   ;+
                INX                   ;+
                INX                   ;+
                INX                   ;+
                INX                   ;+
                STX   DSTPTR          ;Save FOR Value STACK Address, Low
;                                     ;(for Comparison to FAC via FCOMP2, below)
; ----------------------------------- ;Load FAC from [(A,Y)={Low,High}]
;                                     ; = STEP Value STACK Address:
                LDY   #>STACK         ;Get STACK Page Address (=1)
                JSR   UPAY2FAC        ;Unpack STEP Value [(A,Y)={LO,HI}] into FAC
; ----------------------------------- ;Calculate New/Current FOR Value:
                TSX                   ;Retrieve FOR Value STACK Address, Low
                LDA   STACK+9,X       ;Get STEP Sign [(-1,0,1)=(Direction)]
                STA   FACSIGN         ;Save STEP Sign [(-1,0,1) for (-,0,+)]
                LDA   FORPTR          ;Retrieve Pointer to FOR Variable, Low
                LDY   FORPTR+1        ;Retrieve Pointer to FOR Variable, High
                JSR   FADD            ;Add STEP (+/- Amout) to FOR Value
                JSR   SETFOR          ;Put back New/Current FOR Value
; ----------------------------------- ;Q: Is New FOR Value at/beyond End/TO Val?
                LDY   #>STACK         ;Get STACK Page Address (=1)
;                                     ;[(A,Y)={Low,High}]=FOR Value STACK Adrs
                JSR   FCOMP2          ;Q: Compare FAC with Packed Number at (A,Y)
;                                     ;Rtns: (A)=(1|0|-1)<--(A,Y)=[(<|=|>) FAC]
                TSX                   ;Retrieve FOR Value STACK Address, Low
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   STACK+9,X       ;Subtract STEP Sign [(-1,0,1)=(Direction)]
                BEQ   ENDFOR          ;Branch if FOR/NEXT Loop is Done
; ----------------------------------- ;Else, Setup FOR Line Number:
                LDA   STACK+15,X      ;Get FOR Statement's Line Number, Low
                STA   CURLIN          ;Set Current Applesoft Line Number, Low
                LDA   STACK+16,X      ;Get FOR Statement's Line Number, High
                STA   CURLIN+1        ;Set Current Applesoft Line Number, High
; ----------------------------------- ;Set TXTPTR to just after FOR Statement:
                LDA   STACK+18,X      ;Get STACK Address of Statement after, Low
                STA   TXTPTR          ;Set CHRGET's Next Char/Token Pointer, Low
                LDA   STACK+17,X      ;Get STACK Address of Statement after, High
                STA   TXTPTR+1        ;Set CHRGET's Next Char/Token Pointer, High
; ----------------------------------- ;Go Do New/Next Statement:
GONEWST         JMP   NEWSTT          ;Execute a New Statement (This is the EXIT)

; ----------------------------------- ;Loop is Done: Pull FOR-Frame from STACK:
ENDFOR          TXA                   ;Get Stack Pointer Index from Safe
                ADC   #17             ;Carry is Set, so Adds 18 to Stack Pointer
                TAX                   ;Set Stack Pointer Index Safe
                TXS                   ;Set Stack Pointer from Index Safe
                JSR   CHRGOT          ;Get Last Character GOT w/o Uping TXTPTR
                CMP   #','            ;Was Char after Last NEXT Variable a Comma?
                BNE   GONEWST         ;NO: Go Execute a New Statement
                JSR   CHRGET          ;YES: Prime for Next FOR Variable to do:
                JSR   VARNXT          ;Do Next (Outer Loop) FOR Variable
; ----------------------------------- ;(Does Not Return!)
; 
; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft - Part B, $DD67-$E79F:
; Formula Evaluation, Pointer Locating, & String Handling
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; ==============================================================================
; To see: "How Applesoft BASIC Program Varables* Are Structured"
;         *(Reals {Floating Point}, Integers, Strings, Functions, and Arrays),
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 21 to 24
; ==============================================================================
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; 
; 
; ==============================================================================
; Evaluate & Assure Expression is Numeric
; ==============================================================================
; 
FRMNUM          JSR   FRMEVL          ;Is it a Number?  If so, put it in the FAC
; 
; ==============================================================================
; Assure (FAC) Type is Numeric (VALTYP=$00)
; ==============================================================================
; 
CHKNUM          CLC                   ;Assume (FAC) Type is Numeric (VALTYP=$00)
                DFB   BIT_ZP          ;Fake BIT OpCode to skip next line

; ==============================================================================
; Assure (FAC) Type is String (VALTYP=$FF)
; ==============================================================================
; 
CHKSTR          SEC                   ;Assume (FAC) Type is String (VALTYP=$FF)
; 
; ==============================================================================
; Determine (FAC) Type: Numeric (VALTYP=$00) or String (VALTYP=$FF)?
;              Returns: Numeric (Carry)=(0)  or String (Carry)=(1)
; ==============================================================================
; 
CHKVAL          BIT   VALTYP          ;Is (FAC) Type Numeric or String?
                BMI   NOTNUMSTR       ;If VALTYP<0, Type is NOT Numeric
                BCS   MISMATCH        ;If C=1, Type is String, NOT Numeric
BAS_RTS12       RTS                   ;If C=0, Type is Numeric; Return to Caller

NOTNUMSTR       BCS   BAS_RTS12       ;If C=1, Type is String; Return to Caller
; ----------------------------------- ;Error Entry Point; Also User-Callable:
MISMATCH        LDX   #ERR_BADTYPE    ;Else, Throw a "?Type Mismatch" Error:
JERROR          JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Expression Format Evaluator
; ==============================================================================
; Evaluate the Expression at TXTPTR; Leave the Result in the FAC
; (This subroutine works for both String & Numeric Expressions) 
; ==============================================================================
; 
; Main Formula Evaluation Routine: On entry TXTPTR points to 1st chr of Formula:
FRMEVL          LDX   TXTPTR          ;Get Next Char/Token Pointer, Low
                BNE   FESKPHI         ;If Not Zero ($00), Skip High Byte:
                DEC   TXTPTR+1        ;Reduce Next Char/Token Pointer, High
FESKPHI         DEC   TXTPTR          ;Reduce Next Char/Token Pointer, Low
                LDX   #$00            ;Clear Initial Preference Index
                DFB   BIT_ZP          ;Fake BIT OpCode to skip next line

; ------------------------------------------------------------------------------
; Prepare to Check for Relational Operators (<,=,>)
; ------------------------------------------------------------------------------
FRMEVL1         PHA                   ;Push Last Comparison Type (CMPTYP)
                TXA                   ;Get Last Preference Index
                PHA                   ;Push Last Preference Index
                LDA   #1              ;Get Number of Address Pointers Needed
                JSR   CHKMEM          ;Assure sufficient Stack space
                JSR   GETVAL          ;Get an Element
                LDA   #$00            ;Get Compare Type (1,0,-1): Zero
                STA   CPRTYP          ;Set Compare Flag (>,=,<): Is Equal To
; ------------------------------------------------------------------------------
; Check for Relational Operators (<,=,>)
; ------------------------------------------------------------------------------
FRMEVL2         JSR   CHRGOT          ;Get Last Char/Token Got
; ------------------------------------------------------------------------------
; Check for Relational Operators (<,=,>) Loop
; ------------------------------------------------------------------------------
; Tokens: |  Hexadecinal | ">" is $CF | "=" is $D0 | "<" is $D1 |
;         |      Decinal | ">" is 207 | "=" is 208 | "<" is 209 |
;         | Zero-Ordinal | ">" is   0 | "=" is   1 | "<" is   2 |
; ------------------------------------------------------------------------------
FE2LOOP         SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #TOK_GREATER    ;Is it a ">" Token?
;                                     ;Now (A)=[(0|1|2) for (">"|"="|"<")]
                BCC   FE2CONT         ;BLT: NO, it's NOT a Relational Operator
                CMP   #3              ;Is it an "=" or a "<" Token?
                BCS   FE2CONT         ;BGE: NO, it's NOT a Relational Operator
                CMP   #1              ;Token is "=" or "<"!  Is it an "=" Token?
;                                     ;If >= "=" Token, Carry is Set
                ROL   A               ;Double & Put Carry in LSB  [(2A+C)-->(A)]
;                                     ;Now (A)=[(0|3|5) for (">"|"="|"<")]
                EOR   #%00000001      ;Now (A)=[(1|2|4) for (">"|"="|"<")]
                EOR   CPRTYP          ;Set CPRTYP bit (00000<=>)~(4|2|1)
;                                     ;Check for Illegal Combinations:
                CMP   CPRTYP          ;1st Pass (00000000); 2nd Pass (00000<=>)
                BCC   SNTXERR         ;BLT: Branch If a Rel Op was Repeated;
;                                     ;^(Go Throw a "?Syntax" Error!) [Exit] 
                STA   CPRTYP          ;Set bits of CPRTYP (00000<=>)
                JSR   CHRGET          ;Get Next Char/Token
;                                     ;Is it another Rel Op (<,=,>)?
                JMP   FE2LOOP         ;Check for a 2nd Relational Operator

; ------------------------------------------------------------------------------
; Is it a Relational Operator (<,=,>)?
; ------------------------------------------------------------------------------
;                                     ;Now (A)=[(0|1|2) for (">"|"="|"<")]
FE2CONT         LDX   CPRTYP          ;Were Relational Operators Found?
                BNE   FRMREL          ;YES, Rel Ops were Found, So Evaluate Math
                BCS   NOTMATH         ;BGE: NO, Branch if [(A)>(2)];
;                                     ;Rel Ops Not Found, So Not an Equation
;                                     ;& Char/Token is [(A+207)>("<":$D1=209)]
; ------------------------------------------------------------------------------
;                                     ;Now (A)<(0); Add Difference:
                ADC   #7              ;[(TOK_GREATER)-(TOK_PLUS)=($CF-$C8)=(7)]
;                                     ;Now (A)<=[(0|1|2|3) : ("+"|"-"|"*"|"/")]
                BCC   NOTMATH         ;BLT: Branch if [(A)<(0)];
;                                     ;Rel Ops Not Found, So Not an Equation,
;                                     ;& Char/Token is [(A+207)<("+":$C8=200)]
; ------------------------------------------------------------------------------
;                                     ;Now (A)=[(0|1|2|3) for ("+"|"-"|"*"|"/")]
;                                     ;& Char/Token is [(A+207)>=("+":$C8=200)]
;                                     ;-----------------------------------------
;                                     ;If Last Result was a String, Concatenate:
                ADC   VALTYP          ;Add w/C=1: Variable Type ($00=Num, $FF=Str)
                BNE   FE2NUM          ;(A)=(1|2|3|4): Last Result was a Number
                JMP   CAT             ;(A)=(0): Last Result was a String

; ------------------------------------------------------------------------------
; It is NOT a Relational Operator (<,=,>); Nor is it a Concatenation of Strings!
; ------------------------------------------------------------------------------
;                                     ;Now (A)=(1|2|3|4): Last VALTYP was a Num
FE2NUM          ADC   #$FF            ;Add (-1) w/C=0: Now (A)=[(0|1|2|3) again
;                                     ;Multiply it by 3:
                STA   INDEX           ;Save (A)
                ASL   A               ;Double (A)
                ADC   INDEX           ;Now (A)=[(0|3|6|9) for ("+"|"-"|"*"|"/")]
                TAY                   ;Now (Y)=[(0|3|6|9) for ("+"|"-"|"*"|"/")]
; ------------------------------------------------------------------------------
; Check Form & Precedence Test
; ------------------------------------------------------------------------------
PREFTEST        PLA                   ;Get Last Precedence
                CMP   MATHTBL,Y       ;Is (Last Precedence)>("+"|"-"|"*"|"/")?
                BCS   DOMATHNOW       ;YES, if Higher Precedence: Do it Now!
                JSR   CHKNUM          ;NO; Was Last VALTYP a Number?
;                                     ;YES; Rtns here if Type is Numeric (C=0)
;                                     ;Else, NO Rtn; Does Type Mismatch Error!
; ------------------------------------------------------------------------------
NXTOP           PHA                   ;Form correct: Push Last Precedence
SAVOP           JSR   FRM_RECURSE     ;Push Rest of OP, Call FRMEVL Recursively
                PLA                   ;Pull Last Precedence
                LDY   LASTOP          ;Get Last FRMEVL Scratch Flag Saved
                BPL   PREFNC          ;Branch if [(0)<(Y)<(128)]
                TAX                   ;Set (X)=(Last Precedence)
                BEQ   GOEX            ;Exit if (X)=(A)=(0): NO Math in Expression
                BNE   DOMATH          ;Else, [(X)=(A)]<>(0): Math in Expr; Always

; ------------------------------------------------------------------------------
; Found one or more Relational Operators (<,=,>); Evaluate Math Equation:
; ------------------------------------------------------------------------------
FRMREL          LSR   VALTYP          ;Variable Type ($00=Num, $FF=Str) LSB -> C
                TXA                   ;Now (A)=[(X)=(CPRTYP)=(00000<=>)] Rel Ops
                ROL   A               ;Now (A)=(0000<=>C)]: [(C)=(0|1)=(Num|Str)]
                LDX   TXTPTR          ;Get Next Char/Token Pointer, Low
                BNE   FRSKPGR         ;Skip Page Reduction if <> 0
                DEC   TXTPTR+1        ;Decrement Next Char/Token Pointer, High
FRSKPGR         DEC   TXTPTR          ;Decrement Next Char/Token Pointer, Low
                LDY   #$1B            ;Point at Rel Ops ("<") Unary Plus entry
;                                     ;(MO_UPLS_LTGT-MTHTBL)=($D0CD-$D0B2)=($1B)
                STA   CPRTYP          ;Set Comparison Type to (0000<=>C)
                BNE   PREFTEST        ;Loop-Back; Always Taken

; ------------------------------------------------------------------------------
PREFNC          CMP   MATHTBL,Y       ;Is (Last Precedence)>("+"|"-"|"*"|"/")?
                BCS   DOMATH          ;YES, if Higher Precedence: Do it Now!
                BCC   NXTOP           ;Loop-Back; Always Taken

; ------------------------------------------------------------------------------
; Stack this Operation and call FRMEVL for another one               (Recursive)
; ------------------------------------------------------------------------------
;                                     ;Now (Y)=[(0|3|6|9) for ("+"|"-"|"*"|"/")]
;                                     ;Push Rest of OP:
FRM_RECURSE     LDA   MATHTBL+2,Y     ;Get Math Operator's S/R Address, High
                PHA                   ;Push Math Operator's S/R Address, High
                LDA   MATHTBL+1,Y     ;Get Math Operator's S/R Address, Low
                PHA                   ;Push Math Operator's S/R Address, Low
                JSR   PSHFAC          ;Returns via JMP (INDEX)
                LDA   CPRTYP          ;Get FRMEVL Compare Flag (0000<=>C)
                JMP   FRMEVL1         ;Call FRMEVL Recursively

; ------------------------------------------------------------------------------
SNTXERR         JMP   SYNERROR        ;Go Throw a "?Syntax" Error!  [Exit]

; ==============================================================================
; Stack (FAC): Set INDEX for Return & Push FAC (Values & Sign Bytes [2 kinds])
; ==============================================================================
; |     Three entry points:      |     None return across a page boundary:     |
; |     -------------------      |     -----------------------------------     |
; |     PSHFAC, from FRMEVL      |     Above at $DE05; Returns to $DE08        |
; |     PSHFACX, from STEP       |     Above at $D7C6; Returns to $D7C9        |
; |     PUSHFAC, from FOR        |     Above at $D7AC; Returns to $D7AF        |
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; FRMEVL Entry Point, to Push FAC (Values & Sign Byte [MSB]):
; ------------------------------------------------------------------------------
PSHFAC          LDA   FACSIGN         ;Get SIGN of FAC (>127 = Neg | <128 = Pos)
                LDX   MATHTBL,Y       ;Get Precedence Code (Token constant)
; ------------------------------------------------------------------------------
; STEP Entry Point, to Push STEP Amount (Value in FAC & Sign in (A)=(-1|0|1):
; ------------------------------------------------------------------------------
PSHFACX         TAY                   ;Save SIGN of {FAC|STEP} Value
;                                     ;Prepare for Return via JMP (Indirect):
                PLA                   ;Pull Return Address, Low
                STA   INDEX           ;Set Return Address, Low [for JMP (INDEX)]
                INC   INDEX           ; & Add one (like an RTS does)
                PLA                   ;Pull Return Address, High
                STA   INDEX+1         ;Set Return Address, High [for JMP (INDEX)]
;                                     ;None cross page boundary, so NO INC here!
                TYA                   ;Retrieve SIGN of {FAC|STEP} Value
                PHA                   ;Push SIGN Byte [1 of 2 types]
; ------------------------------------------------------------------------------
; FOR Entry Point, with INDEX = STEP, to Push Initial Value of FOR Variable:
; ------------------------------------------------------------------------------
PUSHFAC         JSR   ROUND_FAC       ;Round FAC to 32 bits
; ----------------------------------- ;Push FAC (L,M,H,T,X):
                LDA   FAC+4           ;Get FAC Mantissa, Low
                PHA                   ;Push FAC Mantissa, Low
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                PHA                   ;Push FAC Mantissa, Middle
                LDA   FAC+2           ;Get FAC Mantissa, High
                PHA                   ;Push FAC Mantissa, High
                LDA   FAC+1           ;Get FAC Mantissa, Top
                PHA                   ;Push FAC Mantissa, Top
                LDA   FAC             ;Get FAC Exponent
                PHA                   ;Push FAC Exponent
                JMP   (INDEX)         ;Return to Caller (Indirectly)

; ------------------------------------------------------------------------------
; If NO Relative Operators were Found, this Statement is Not an Equation!
; ------------------------------------------------------------------------------
NOTMATH         LDY   #$FF            ;Set NO Math Exit Code
                PLA                   ;Pull Precedence (Last Preference Index)
GOEX            BEQ   EXIT            ;Exit if NO Math to do
; ------------------------------------------------------------------------------
; ELSE, Statement is a Stacked Operation, so Execute the Stacked Operation:
; ------------------------------------------------------------------------------
;   A-Reg = Precedence byte
;   Stack (# of bytes): 1 - CPRMASK
;                       5 - ARG
;                       2 - Address of Subroutine to Execute
; ------------------------------------------------------------------------------
DOMATHNOW       CMP   #P_REL          ;Was it a Relational Operator (<|=|>)?
                BEQ   SKPNUMCHK       ;YES: Allow String Comparison; Skip Next Op
                JSR   CHKNUM          ;NO: Assure (FAC) Type is Numeric
;                                     ;(Y)=[(-1)|(0|3|6|9) : ("+"|"-"|"*"|"/")]
SKPNUMCHK       STY   LASTOP          ;Save Y-Reg in FRMEVL Scratch Flag
; ------------------------------------------------------------------------------
; Pull & Put Stacked FAC into ARG (Secondary FAC); Then go to Math subroutine
; (whose Address was already pushed onto the Stack) via an RTS; Note that
; Relative Ops (<|=|>) all go to RELOPS ($DF65):
; ------------------------------------------------------------------------------
DOMATH          PLA                   ;Pull Compare Flag [(CPRTYP)=(0000<=>C)]
                LSR   A               ;Retore Carry Flag; Now (A)=(00000<=>)
                STA   CPRMASK         ;Set Comparison Mask (from Comparison Type)
                PLA                   ;Pull FAC Exponent
                STA   ARG             ;Set ARG Exponent
                PLA                   ;Pull FAC Mantissa, Top
                STA   ARG+1           ;Set ARG Mantissa, Top
                PLA                   ;Pull FAC Mantissa, High
                STA   ARG+2           ;Set ARG Mantissa, High
                PLA                   ;Pull FAC Mantissa, Middle
                STA   ARG+3           ;Set ARG Mantissa, Middle
                PLA                   ;Pull FAC Mantissa, Low
                STA   ARG+4           ;Set ARG Mantissa, Low
                PLA                   ;Pull SIGN Byte [1 of 2 types]
                STA   ARGSIGN         ;Set ARG SIGN Byte [1 of 2 types]
                EOR   FACSIGN         ;XOR Signs of Ops (for Multiply/Divide)
                STA   SGNCPR          ;Set Sign Comparison Flag
EXIT            LDA   FAC             ;Get FAC Exponent (Status if FACX=0)
                RTS                   ;Do Math Operation

; ==============================================================================
; Get an Element from Expression: 
; ==============================================================================
; This is the "Kernel" subroutine of FRMEVL (for Evaluating Expression Formats)
; (It also Evaluates Expressions in Parenthesis via Recursive calls to FRMEVL)
; ==============================================================================
; Get Value of Variable or Number at TXTPTR & put it in the FAC 
; If it is a String, put pointer to String Descriptor in the FAC
; ------------------------------------------------------------------------------
GETVAL          LDA   #$00            ;Assume Numeric:
                STA   VALTYP          ;Set Variable Type ($00=Num, $FF=Str)
SKIP            JSR   CHRGET          ;Get Next Char/Token
                BCS   VARIABLE        ;BGE: It is Not a Number If Carry is Set
NUMBER          JMP   FIN             ;BLT: It is a Number If Carry is Clear

VARIABLE        JSR   ISLETC          ;Is it a Variable Name?
                BCS   FNDNUMVAR       ;YES: It is a Variable Name!
                CMP   #'.'            ;NO; Is it a Decimal Point?
                BEQ   NUMBER          ;YES: So it IS a Numeric Constant!
                CMP   #TOK_MINUS      ;NO; Is it a Unary Minus ("-") Sign?
                BEQ   UMINUS          ;YES: It is a Minus Sign!
                CMP   #TOK_PLUS       ;NO; Is it a Unary Plus ("+") Sign?
                BEQ   SKIP            ;YES (Loop-Back): It is a Plus Sign!
                CMP   #'"'            ;Is it a String Constant (Quotation Mark)?
                BNE   TOKNOT          ;NO (Skip Fwd): It is NOT a String (Quote)!
;                                     ;YES: Processes Literal String;
;                                     ;Set [(A,Y)={Low,High}]=(TXTPTR+C):
STRTEXT         LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                ADC   #$00            ;Add in the Carry Flag
                BCC   TEXTSTR         ;Skip INY (High byte) if Carry was Cleared
                INY                   ;Advance Char/Token Pointer, High
TEXTSTR         JSR   STRLTRL         ;Build String Descriptor & Put it in FAC
                JMP   POINT           ;Point (TXTPTR) to after Closing Quote

; ==============================================================================
TOKNOT          CMP   #TOK_NOT        ;Is it a "NOT" Token?
                BNE   TOKFN           ;NO (Skip Fwd): NOT a "NOT" Token!
                LDY   #$18            ;YES: Point at Rel Ops ("=") Unary Not entry
;                                     ;(MO_UNOT_EQUL-MTHTBL)=($D0CA-$D0B2)=($18)
                BNE   EQUL            ;Always: Pull RA, Stack Op, & Recurse FRMEVL

; ==============================================================================
; "EQUOP" [EQUAL-TO ("=") Operator] Function
; ==============================================================================
; 
; ==============================================================================
; Comparison for Equality (EQUAL-TO) [Rel Ops ("=") Unary Not entry]:
; ==============================================================================
; From MATHTBL: MO_UNOT_EQUL  DFB  P_NEQ    ;$D0...208...=...Unary NOT
;               TA_UNOT_EQUL  DW   EQUOP-1  ;(EQUAL-TO) Operator Address
; ------------------------------------------------------------------------------
; Also used to evaluate NOT function: 
; This routine is called only by NOT through the preceding branch to EQUL.
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
EQUOP           LDA   FAC             ;Get FAC Exponent
                BNE   EQUOP1          ;If FACX<>0, Set as FALSE
                LDY   #$01            ;Else, FACX=0: Set as TRUE
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

EQUOP1          LDY   #$00            ;FACX<>0: Set as FALSE
; ----------------------------------- ;Convert Y-Reg to Real/FP Number in FAC:
                JMP   SNGFLT          ;Float Unsigned Integer & Flag as a Number

; ==============================================================================
; TOKFN Check
; ==============================================================================
; 
TOKFN           CMP   #TOK_FN         ;Is it an "FN" (Function Assignment) Token?
                BNE   TOKSGN          ;NO (Skip Fwd): NOT an "FN" Token!
                JMP   FN_CALL         ;Go do FN (Function Assignment) Call

; ==============================================================================
; TOKSGN Check
; ==============================================================================
; 
TOKSGN          CMP   #TOK_SGN        ;Is it a "SGN" (Math Function) Token?
                BCC   PARCHK          ;NO [(BLT)=(Skip Fwd)]: NOT a "SGN" Token!
                JMP   UNARY           ;MAYBE it's a SGN Token, MAYBE NOT!

; ==============================================================================
; Evaluate "(Expression)" [within Parentheses]
; ==============================================================================
; 
PARCHK          JSR   CHKOPN          ;Is there a "(" at TXTPTR?
                JSR   FRMEVL          ;YES: Evaluate Expression (in Parentheses)
CHKCLS          LDA   #')'            ;NO; Is there a ")" at TXTPTR?
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

CHKOPN          LDA   #'('            ;Is there a "(" at TXTPTR?
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

CHKCOM          LDA   #','            ;Is there a "," at TXTPTR?
; 
; ==============================================================================
; Check Current Char & Get Next
; ==============================================================================
; 
SYNCHR          LDY   #0              ;Clear Indirect Addressing Index
                CMP   (TXTPTR),Y      ;Is Char at TXTPTR = A-Reg?
                BNE   SYNERROR        ;NO; So Throw a "?Syntax" Error
                JMP   CHRGET          ;YES; Get Next Char & Return to Caller

; ==============================================================================
; Print Syntax Error
; ==============================================================================
; 
; ----------------------------------- ;User-Callable Error Entry Point:
SYNERROR        LDX   #ERR_SYNTAX     ;Throw a "?Syntax" Error
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Comparison for Greater-Than->-Less-Than [Rel Ops (">") Unary Minus entry]:
; ==============================================================================
; From MATHTBL: MO_UMNS_GTLT  DFB P_NEQ    ;$CF...207...>...Unary Minus ("-")
;               TA_UMNS_GTLT  DW  NEGOP-1  ;(GREATER-THAN)->-(LESS-THAN) Op Adrs
; ==============================================================================
; 
UMINUS          LDY   #$15            ;Point at Rel Ops (">") Unary Minus entry
;                                     ;(MO_UMNS_GTLT-MTHTBL)=($D0C7-$D0B2)=($15)
; ==============================================================================
; 
; ==============================================================================
EQUL            PLA                   ;Pull Return Address off Stack, Low
                PLA                   ;Pull Return Address off Stack, High
                JMP   SAVOP           ;Stack this Op & call FRMEVL Recursively

; ==============================================================================
; Locate & Point to a Specific Variable:
; ==============================================================================
;                                     ;YES: It's a Variable Name! Locate Var:
FNDNUMVAR       JSR   PTRGET          ;Get Address in VARPTR & [(A,Y)={Low,High}]
; ------------------------------------------------------------------------------
;                                     ;Returns (from SETVARPTRYA) with:
;                                     ;(A)=(VARPTR)   Ptr to Var's Value, Low
;                                     ;(Y)=(VARPTR+1) Ptr to Var's Value, High
; ------------------------------------------------------------------------------
                STA   TMPVPTR         ;Set Temp Variable Pointer, Low     (FAC+3)
                STY   TMPVPTR+1       ;Set Temp Variable Pointer, High    (FAC+4)
                LDX   VALTYP          ;Get Variable Type ($00=Num, $FF=Str)
                BEQ   FNDINTVAR       ;Branch if Variable Type is Numeric (==0)
                LDX   #$00            ;Else, Variable Type is Not Numeric (<>0)
                STX   FACEXT          ;Flag it: Clear FAC Extension Byte Safe
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; Get Signed Integer at [(TMPVPTR)=(FAC+3,4)] into [(Y,A)={Low,High}], Then 
; Float (Y,A) into FAC; Skip it ALL if the Number is already a Real/FP Number!
; ------------------------------------------------------------------------------
;                                     ;Variable Type is Number (=0)
FNDINTVAR       LDX   INTFLG          ;Negative for Integer Variable (%)
                BPL   FNDFPVAR        ;Branch if Number is Not an Integer!
;                                     ;Else, it is an Integer, Get its Value ...
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;Ptr,Lo/Hi-->Value,Hi/Lo Swap Occurs Here:
                LDY   #0              ;Clear Indirect Addressing Index (Y=0)
                LDA   (TMPVPTR),Y     ;Get from Pointer, Lo: Variable Value, High
                TAX                   ;Save Variable Value, High; From: (FAC+3),Y
                INY                   ;Advance Indirect Addressing Index (Y=1)
                LDA   (TMPVPTR),Y     ;Get from Pointer, Hi: Variable Value, Low
                TAY                   ;Save Variable Value, Low;  From: (FAC+3),Y
                TXA                   ;Retrieve Variable Value, High
                JMP   GIVAYF          ;Float Signed Integer in [(Y,A)={Low,High}]

; ------------------------------------------------------------------------------
; Unpack FP Number at [(A,Y)={Low,High}] into FAC
; ------------------------------------------------------------------------------
;                                     ;Variable Type is Number (=0)
;                                     ;But, the Number is FP, Not an Integer!
;                                     ;(A) is Temp Variable Ptr, Low  (FAC+3)
;                                     ;(Y) is Temp Variable Ptr, High (FAC+4)
FNDFPVAR        JMP   UPAY2FAC        ;Unpack FP# at [(A,Y)={Low,High}] into FAC

; ==============================================================================
; Handle "SCRN(" Token
; ==============================================================================
SCREEN          JSR   CHRGET          ;Get Next Char/Token
                JSR   PLOTFNS         ;Get Column,Row Coordinates [(0-47),(0-47)]
                TXA                   ;Get Row Coordinate    [Set (A)=(X)=(0-47)]
                LDY   FIRST           ;Get Column Coordinate     [Set (Y)=(0-47)]
                JSR   SCRN            ;Get 4-bit Color at Column,Row Coordinates
                TAY                   ;Set [(Y)=(A)]=[(%0000nnnn)=($0-$F)=(0-16)]
; ----------------------------------- ;Convert (Y) to Real/FP Number in FAC:
                JSR   SNGFLT          ;Float Unsigned Integer & Flag as a Number
                JMP   CHKCLS          ;Require a Closing Parenthesis [")"]

; ==============================================================================
; Process Unary Operators (Functions):
; ==============================================================================
; Continue TOKSGN Check: Is it a "SGN" (Math Function) Token?
; ------------------------------------------------------------------------------
;                                     ;If Not Unary, Do Special:
UNARY           CMP   #TOK_SCRN       ;Is it a "SCRN(" Token?
                BEQ   SCREEN          ;YES, It's a "SCRN(" Token!
; ------------------------------------------------------------------------------
                ASL   A               ;NO: Double Token to get Index
                PHA                   ;Push/Save Routine Pointer Index
                TAX                   ;Put Index in X-Reg, too [(X)=(Token*2)]
                JSR   CHRGET          ;Get Next Char/Token
                CPX   #>UNFNC-$100    ;Is (Index/2)=(LEFT$|RIGHT$|MID$) Token?
;                                     ;[(TOK_LEFT*2-1)=($E8*2-1)=($D0-1)=($CF)]
;              -----------------------------------------------------------------
;              AKA:  #>JMPADRTBL    ;Empty Space AT $CFDC (UNFNC-164)
;                    [Base Address for Index into Unary Functions Address Table]
;              -----------------------------------------------------------------
                BCC   UNARY1          ;BLT: NO, Branch if NOT a String Function
; ----------------------------------- ;YES, String Function (LEFT$|RIGHT$|MID$):
                JSR   CHKOPN          ;Require an Opening Parenthesis ["("]
                JSR   FRMEVL          ;(Recurse) Evaluate Expression for String
;                                     ; & Leave the Result for a String in FAC]
;                                     ;^[This String Expression (Sexpr) is the
;                                     ;  1st Parameter of the String Function]
                JSR   CHKCOM          ;Require a Comma (between 1st & 2nd Parms)
                JSR   CHKSTR          ;Assure (FAC) Type is String (VALTYP=$FF)
                PLA                   ;Pull/Retrieve Routine Pointer Index 
                TAX                   ;Put Index in X-Reg, too [(X)=(Token*2)]
;                                     ;Stack String Descriptor Adrs (TMPVPTR):
                LDA   TMPVPTR+1       ;Get Temp Variable Pointer, High    (FAC+4)
                PHA                   ;Push Temp Variable Pointer, High
                LDA   TMPVPTR         ;Get Temp Variable Pointer, Low     (FAC+3)
                PHA                   ;Push Temp Variable Pointer, Low
                TXA                   ;Get Routine Pointer Index  [(A)=(Token*2)]
                PHA                   ;Push Routine Pointer Index (Doubled Token)
                JSR   GETBYT          ;Convert Next Expression to a Byte in X-Reg
;                                     ;^[This Next Expression (Aexpr) is the
;                                     ;  2nd Parameter of the String Function]
                PLA                   ;Get Routine Pointer Index  [(A)=(Token*2)]
                TAY                   ;Set Indirect Addressing Index to Jump with
                TXA                   ;Get Value of 2nd Parameter
                PHA                   ;Push Value of 2nd Parameter
                JMP   UNARY2          ;Join Unary Functions

; ----------------------------------- ;NOT a String Function (ReEntry Point)
UNARY1          JSR   PARCHK          ;Require "(Expression)" [in Parentheses]
                PLA                   ;Get Index to Unary Functions Address Table
                TAY                   ;Set Indirect Addressing Index into ^ Table
; ----------------------------------- ;Join Unary Functions (ReEntry Point)
UNARY2          LDA   UNFNC-164,Y     ;Get Jump Vector, Low, from Address Table
;                                     ;(UNFNC-TOK_SGN*2+$100)=($D080-$D2*2+$100)
                STA   JMPADRS+1       ;Set Jump from ZP to <Address>, Low
                LDA   UNFNC-163,Y     ;Get Jump Vector, High, from Address Table
;                                     ;(UNFNC-TOK_SGN*2+$101)=($D080-$D2*2+$101)
                STA   JMPADRS+2       ;Set Jump from ZP to <Address>, High
                JSR   JMPADRS         ;JMPADRS in Zero-Page is used by functions 
; ----------------------------------- ;NO Return for CHR$, LEFT$, RIGHT$, or
; MID$
                JMP   CHKNUM          ;Require Numeric Result

; ==============================================================================
; "OR" Conditional Statement
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
OR              LDA   ARG             ;Get 2nd FAC Exponent (ARGX)
                ORA   FAC             ;OR w/ 1st FAC Exponent (FACX)
                BNE   TRUE            ;Branch if [(ARGX)|(FACX)]<>0
; 
; ==============================================================================
; "AND" Conditional Statement
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
AND             LDA   ARG             ;Get 2nd FAC Exponent (ARGX)
                BEQ   FALSE           ;Branch if [(A)=(ARGX)]==0
                LDA   FAC             ;Else, Get 1st FAC Exponent (FACX)
                BNE   TRUE            ;Branch if [(A)=(FACX)]<>0
; 
; ------------------------------------------------------------------------------
; Flag "FALSE" Condition
; ------------------------------------------------------------------------------
; 
FALSE           LDY   #$00            ;Set to FALSE [(Y)=(0)]
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; 
; ------------------------------------------------------------------------------
; Flag "TRUE" Condition
; ------------------------------------------------------------------------------
; 
TRUE            LDY   #$01            ;Set to TRUE [(Y)=(1)]
; ----------------------------------- ;Convert Y-Reg to Real/FP Number in FAC:
                JMP   SNGFLT          ;Float Unsigned Integer & Flag as a Number

; 
; ==============================================================================
; "RELOPS" [Less-Than ("<") Operator] Function:
; ==============================================================================
; Common Routine for <, =, > Comparisons
; ==============================================================================
; Comparison for (LESS-THAN)-<-(GREATER-THAN) [Rel Ops ("<") Unary Plus entry]:
; ==============================================================================
; From MATHTBL: MO_UPLS_LTGT  DFB P_REL    ;$D1...209...<...Unary Plus ("+")
;               TA_UPLS_LTGT  DW RELOPS-1  ;(LESS-THAN)-<-(GREATER-THAN) Op Adrs
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
RELOPS          JSR   CHKVAL          ;Is FAC Type Numeric ($00) or String ($FF)?
                BCS   STRCMP          ;Branch if C=1: Type is String, NOT Numeric
; ----------------------------------- ;Do a Numeric Comparison [ARG(<|=|>)FAC]:
                LDA   ARGSIGN         ;Get ARG's Unpacked Sign (msb)
                ORA   #%01111111      ;Set (AND Mask msb)=(ARGSGN msb)
;                                     ;Repack Value in ARG for FCOMP:
                AND   ARG+1           ;Set in (A): Sign Bit of ARG Mantissa, Top
                STA   ARG+1           ;Save Signed ARG Mantissa, Top
                LDA   #ARG            ;Get ARG Address, Low
                LDY   #0              ;Get ARG Address, High; [(A,Y)={Low,High}]
                JSR   FCOMP           ;Compare FAC with Packed Number at (A,Y) ^
;                                     ;Rtns: (A)=(-1|0|1)<--(A,Y)=[(>|=|<) FAC]
                TAX                   ;Save [(X)=(A)] as Sign Value for finishing
                JMP   NUMCMP          ;Finish Numeric Comparison (below)

; ----------------------------------- ;Do a String Comparison:
STRCMP          LDA   #$00            ;Clear Accumulator
                STA   VALTYP          ;Set Variable Type ($00=Num, $FF=Str)
                DEC   CPRTYP          ;Make FRMEVL Compare Flag = (0000<=>0)
                JSR   FREFAC          ;Free up TMPVPTR & a Temp String
                STA   DSCTMP          ;Set (FAC) Temp Descriptor, String Length
                STX   DSCTMPL         ;Set (FAC+1) Tmp Dscrptr, Str Addr, Low
                STY   DSCTMPH         ;Set (FAC+2) Tmp Dscrptr, Str Addr, High
                LDA   ARGVPTR         ;Get (ARG+3) Temp Variable Pointer, Low
                LDY   ARGVPTR+1       ;Get (ARG+4) Temp Variable Pointer, High
                JSR   FRETMP          ;Free up a Temp String [Address in (A,Y)]
                STX   ARGVPTR         ;Set (ARG+3) Temp String Pointer, Low
                STY   ARGVPTR+1       ;Set (ARG+4) Temp String Pointer, High
                TAX                   ;Set to (ARG) Temp String Length
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   DSCTMP          ;Deduce Lesser of (ARG|FAC) String Lenghts
                BEQ   SCFS            ;Flag (0) for (ARG=FAC) String Lenghts
                LDA   #1              ;Set Accumulator
                BCC   SCFS            ;Flag (+1) for (ARG<FAC) String Lenghts
                LDX   DSCTMP          ;Get (FAC) Temp Descriptor, String Length
                LDA   #$FF            ;Flag (-1) for (ARG>FAC) String Lenghts
SCFS            STA   FACSIGN         ;Flag Shortest [(FAC|==|ARG)-->(-1|0|+1)]
                LDY   #$FF            ;Set to counter following Advance
                INX                   ;Set to counter following Reduction
CMPLOOP         INY                   ;Advance Indirect Addressing Index
                DEX                   ;Count Down for (FAC) String Length
                BNE   DOCMP           ;Branch if more Chars in both Strings
                LDX   FACSIGN         ;If Str(ARG=FAC) so far, decide by Length
NUMCMP          BMI   CMPDONE         ;Branch if (ARG>FAC) String Lenghts
                CLC                   ;Clear Carry to force following Branch:
                BCC   CMPDONE         ;Always Taken

; ----------------------------------- ;Do another String Character Comparison:
DOCMP           LDA   (ARGVPTR),Y     ;Get an (ARG) Temp String Character
                CMP   (DSCTMPL),Y     ;Compare it to (FAC) Temp String Character
                BEQ   CMPLOOP         ;Loop: Keep Comparing if Chars are Equal
                LDX   #$FF            ;Set for (ARG>FAC) String Lenghts
                BCS   CMPDONE         ;Branch if (ARG>FAC) String Lenghts
                LDX   #1              ;Set for (ARG<FAC) String Lenghts
; ----------------------------------- ;Done with String Comparison;
;                                     ;Convert (FAC|==|ARG):
CMPDONE         INX                   ;Convert from (-1|0|1) to (0,1,2):[A=X+1];
                TXA                   ;Then, if C=0, Convert to (0,2,4):[A*2+C];
                ROL   A               ;Else, if C=1, Convert to (1,2,5):[A*2+C]
                AND   CPRMASK         ;(00000<=>):[8421,8421]
                BEQ   CMPFINFLT       ;Branch if NO Match: (A=0) indicates False
                LDA   #$01            ;Else, Matches >= 1: (A=1) indicates True
CMPFINFLT       JMP   FLOAT           ;Float Signed Integer in (A) into FAC

; ==============================================================================
; "PDL" (Paddle) Statement: Immediate and Deferred; Parameter: PDL (Aexpr)
; ==============================================================================
; Function: Converts Analog Resistance Input to Digital Numeric Output
;  Input: (Aexpr)=(0|1|2|3) is the number of a game controller (potentiometer)
; Output: (0 to 255) corresponding to a variable resistance of (0 to 150 Kohms)
; ==============================================================================
; 
PDL             JSR   CONINT          ;Convert FAC to Number in (X) & (FAC+4)
;                                     ;<<< Validity [(X)<(4)] is NOT Checked! >>
                JSR   PREAD           ;Read Paddle (X); Returns Time-Count in (Y)
;                                     ;Float Unsigned Integer & Flag as Number:
                JMP   SNGFLT          ;Convert (Y) to Real Number in FAC

; ==============================================================================
; "DIM" Statement: Immediate and Deferred;
;                  Parameters: DIM Var Subscript [{,Var Subscript}]
; ==============================================================================
; Function: Array Dimensional Assignment; Allocates Space for Array Variables
; ==============================================================================
; 
; ----------------------------------- ;Next Dimension (Loop-Back) Entry Point:
NXDIM           JSR   CHKCOM          ;Require a Comma (Data Separator)
; ----------------------------------- ;DIM Statement (Main) Entry Point:
DIM             TAX                   ;Set [(X)=(A)]: Next Character after Comma
; ----------------------------------- ;[(X<>0)] & Entry Point Flags DIM calling:
                JSR   PTRGET2         ;Allocate the Array
                JSR   CHRGOT          ;Get (A): Last Character Got
                BNE   NXDIM           ;Loop if NOT at End of Line/Program
                RTS                   ;Return to Caller

; ==============================================================================
; Pointer Get: Locates or Creates a Specific Variable.
; ==============================================================================
; PTRGET reads a variable name from CHRGET & finds it in memory.  On entry,
; TXTPTR must point to the first character of the variable name.  On exit, the
; address to the value of the variable is in VARPTR & [(A,Y)={Low,High}].  If
; PTRGET cannot find a simple variable, it creates one.  If PTRGET cannot find
; an array variable, it creats an array, dimensioned from 0 to 10, with all
; elements cleared to zero.
; ==============================================================================
PTRGET          LDX   #$00            ;Clear X-Reg
                JSR   CHRGOT          ;Get Last Char/Token Got w/o uping TXTPTR
; ----------------------------------- ;Subroutine Entry Point for DIM Statement:
PTRGET2         STX   DIMFLG          ;Set Array Dimension Flag (DIM Call <> 0)
;                                     ;Set to Zero unless called frm DIM (above)
; ----------------------------------- ;Subroutine Entry Point for FN Statements:
PTRGET3         STA   VARNAM          ;Save 1st Character of Variable Name
;                                     ;VARNAM: Last-Used Variable Name Pointer
;                                     ;is being used here to store the Var Name 
;                                     ;(Bytes)=($:+-;%:--;Real:++;Function:-+)
                JSR   CHRGOT          ;Get Last Char/Token Got w/o uping TXTPTR
                JSR   ISLETC          ;Is it a Letter?
                BCS   NAMOK           ;YES, it is a Letter!
BADNAM          JMP   SYNERROR        ;NO, Not a Letter; Throw a "?SYNTAX" Error!

NAMOK           LDX   #$00            ;Clear X-Reg
                STX   VALTYP          ;Clear Variable Type ($00=Num, $FF=Str)
                STX   INTFLG          ;Clear Integer Flag (Negative if Integer) 
                JMP   PTRGETMOR       ;Branch Across BASIC Entry Points

; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($E000-$E7FF): ROM Socket $E0 on a real Apple II Plus.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
; 
; ==============================================================================
; APPLESOFT (BASIC) ENTRY POINTS:
; ==============================================================================
; 
BASIC           JMP   COLD_START      ;Hard/Cold/Ctrl-B (Reinitialize BASIC) Entry Point

BASIC2          JMP   RESTART         ;Soft/Warm/Ctrl-C (Don't Reinit BASIC) Entry Point

                BRK                   ;<<< Why not "Waste a Byte!"? >>>

; ==============================================================================
; Pointer Get (continued): General Variable Scan
; ==============================================================================
; PTRGET scans the variable name at TXTPTR, and searches the variable table
; (VARTAB) & array table (ARYTAB) for the name.  If not found, PTRGET creates a
; variable of the appropriate type.  PTRGET returns with the address in VARPTR &
; [(A,Y)={Low,High}].
; 
; Actual activity controlled somewhat by two flags:
; 
;   DIMFLG - Array Dimension Flag: Nonzero if called from DIM; Else = 0
;   SUBFLG - Subscripts Flag: $00 = Allowed; $80 = NOT Allowed;
;          = $40     if called from GETARYPT;
;          = $80     if called from DEF FN;
;          = $C1-DA  if called from FN
; ==============================================================================
;  
PTRGETMOR       JSR   CHRGET          ;Get 2nd Character of Variable Name
                BCC   PTRGETNUM       ;Branch if it's Numeric
                JSR   ISLETC          ;Is it a Letter (A-Z)?
                BCC   PTRGETSTR       ;Branch if NOT a Letter: End of Name
PTRGETNUM       TAX                   ;Save 2nd Character of Variable Name
PTRGETNLP       JSR   CHRGET          ;Scan to End of Variable Name
                BCC   PTRGETNLP       ;Loop if it's Numeric
                JSR   ISLETC          ;Is it a Letter (A-Z)?
                BCS   PTRGETNLP       ;Loop if it's a Letter
; ----------------------------------- ;Setup Variable Type Flags:
PTRGETSTR       CMP   #'$'            ;Is it a String Symbol (Dollar Sign)?
                BNE   PTRGETINT       ;Branch if NOT a String Symbol ("$")
                LDA   #$FF            ;Else: Flag as a String
                STA   VALTYP          ;Set Variable Type ($00=Num, $FF=Str)
                BNE   PTRGETNIN       ;Always Taken

PTRGETINT       CMP   #'%'            ;Is it an Integer Variable?
                BNE   PTRGET2ND       ;Branch if NOT an Integer Variable
                LDA   SUBFLG          ;Get Subscript Flag ($00=Allowed, $80=NOT)
                BMI   BADNAM          ;Branch if Integer Variable NOT Allowed;
;                                     ;^(Throws a "?SYNTAX" Error!)
; ------------------------------------------------------------------------------
; Flag Var & Name as Integer (%)      ;VARNAM: Last-Used Variable Name Pointer
;                                     ;is being used here to store the Var Name 
;                                     ;(Bytes)=($:+-;%:--;Real:++;Function:-+)
                LDA   #$80            ;Flag as Integer Variable (%:--):
                STA   INTFLG          ;Set Negative for an Integer Variable
                ORA   VARNAM          ;Set Negative: 1st Var Name Character
                STA   VARNAM          ;Save 1st Character of Variable Name
PTRGETNIN       TXA                   ;Retrieve 2nd Character of Variable Name
                ORA   #$80            ;Set Negative: 2nd Var Name Character
                TAX                   ;Save 2nd Character of Variable Name
; ------------------------------------------------------------------------------
                JSR   CHRGET          ;Get Next (Var Name Terminating) Character
PTRGET2ND       STX   VARNAM+1        ;Store 2nd Character of Variable Name
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                ORA   SUBFLG          ;Are Subscripts Allowed? [YES if ($00|$40)]
                SBC   #'('            ;And, is it an Array Variable?
                BNE   PTRGETNVC       ;Branch if NOT[[(SUBFLG)=($00)]&["("]]
PTRGETARY       JMP   ARRAY           ;Else, Go Handle the Array

PTRGETNVC       BIT   SUBFLG          ;Check Top 2 Bits (NV) of SUBFLG
                BMI   PTRGETIVP       ;($80): Branch if from FOR, DEF or FN
                BVS   PTRGETARY       ;($40): Branch if called from GETARYPTR
; ----------------------------------- ;Initialize Variable Pointer:
PTRGETIVP       LDA   #$00            ;Clear Accumulator
                STA   SUBFLG          ;Clear SUBFLG
                LDA   VARTAB          ;Get Start of Variables Pointer, Low
                LDX   VARTAB+1        ;Get Start of Variables Pointer, High
; ----------------------------------- ;Search Loops:
                LDY   #0              ;Clear Indirect Addressing Index
PTRGETLP1       STX   LOWTR+1         ;Set Var Name Search Pointer, High
PTRGETLP2       STA   LOWTR           ;Set Var Name Search Pointer, Low
                CPX   ARYTAB+1        ;At End of Simple Variables & Pointers?
;                                     ; (Start of Arrays Pointer, High)
                BNE   PTRGETFND       ;NO, Continue Searching
                CMP   ARYTAB          ;At End of Simple Variables & Pointers?
;                                     ; (Start of Arrays Pointer, Low)
                BEQ   NAMNOTFND       ;YES, Var Name Not Found, Make One
; ----------------------------------- ;Search for Varible Name/Pointer:
PTRGETFND       LDA   VARNAM          ;Get Last-Used Variable Name Pointer, Low
                CMP   (LOWTR),Y       ;Is it the Same 1st Letter?
                BNE   PTRGET4_13      ;Branch if NOT
                LDA   VARNAM+1        ;Get Last-Used Variable Name Pointer, High
                INY                   ;Advance Indirect Addressing Index
                CMP   (LOWTR),Y       ;Is it the Same 2nd Letter?
                BEQ   SETVARPTRYA     ;Branch if YES: Same Variable Name Found
; ----------------------------------- ;Else, Advance to next Var Name/Pointer:
                DEY                   ;Reduce Indirect Addressing Index
PTRGET4_13      CLC                   ;Prepare to Add without Carry
                LDA   LOWTR           ;Get Var Name Search Pointer, Low
                ADC   #7              ;Advance Var Name Search Pointer, Low
                BCC   PTRGETLP2       ;Inner Loob Back: Branch if Not Next Page
                INX                   ;Advance Var Name Search Pointer, High
                BNE   PTRGETLP1       ;Outer Loob Back; Always Taken
; 
; ==============================================================================
; Check if (A) Contains ASCII Letter ("A"~"Z")
; ------------------------------------------------------------------------------
; Return: Carry Set   (C=1) if (A)==("A"~"Z")
;         Carry Clear (C=0) if (A)<>("A"~"Z")
; ==============================================================================
; <<< NOTE: Faster & Shorter Code! >>>                   [Easier to Understand!]
; ------------------------------------------------------------------------------
;                CMP #'['  ;Compare High End
;                BCS GTE   ;Branch if (A)>("Z")
;                CMP #'A'  ;Compare Low End
;                RTS       ;(C=0) if (A)<("A")
;                          ;(C=1) if (A)=("A"~"Z")
;           GTE  CLC       ;(C=0) if (A)>("Z")
;                RTS       ;Return to Caller
; ==============================================================================
; <<< NOTE: Original (Slower & Longer) Code >>>          [Harder to Understand!]
; ------------------------------------------------------------------------------
ISLETC          CMP   #'A'            ;Compare Low End
                BCC   BAS_RTS13       ;BLT: Branch if (C=0): (A)<("A")
;                                     ;Else (C=1), Compare High End:
                SBC   #'['            ;Subtract w/o Borrow [A-Data-!C]
;                                     ;BGE: If (A)>("Z"), (C=0) Carry is Cleared
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #$A5            ;Restore A-Reg; ($100-"[")=($100-$5B)=($A5)
;                                     ;-----------------------------------------
;                                     ;If (A)<>("A"~"Z"), (C=0) Carry is Clear;
;                                     ;If (A)==("A"~"Z"), (C=1) Carry is Set:
BAS_RTS13       RTS                   ;Return to Caller

; ==============================================================================
; Variable (& Name) Not Found, So Make New Variable (With Variable Name Sought)
; ==============================================================================
;                                     ;Assure Called from (FRMVAR JSR PTRGET):
NAMNOTFND       PLA                   ;Pull Caller's Return Address, Low
                PHA                   ;Then Push-It-Back to Reset Stack Pointer
; ----------------------------------- ;*[Return Address-1 is Caller's Address+2;
;                                     ;JSR: (PC)+2->Stack; RTS: Stack+1->(PC)]:
                CMP   #<FNDNUMVAR+2   ;Called from FRMVAR [($DED5)+2, Low]*?
                BNE   MKNEWVAR        ;Branch (Exit) if NOT: Make New Variable
                TSX                   ;Get Stack Pointer for X-Indexed Addressing
                LDA   STACK+2,X       ;Get Caller's Return Address, High
                CMP   #>FNDNUMVAR     ;Called from FRMVAR [($DED5)+2, High]*?
                BNE   MKNEWVAR        ;Branch (Exit) if NOT: Make New Variable
; ----------------------------------- ;Else: Called from (FRMVAR JSR PTRGET)! 
;                                     ;It isn't an Assignment (LET), so use Fake
;                                     ;Variable Address to Return Value of Zero
;                                     ;for New Variable Name used in Expression:
                LDA   #<CON_ZERO      ;Point to Constant Zero, Low
                LDY   #>CON_ZERO      ;Point to Constant Zero, High
                RTS                   ;Return CON_ZERO (A,Y) Address to FRMVAR

CON_ZERO        DW    $0000           ;Integer or Real Zero, or Null String

; ==============================================================================
; Make New Variable
; ==============================================================================
; To make a New Simple Variable, move Arrays up 7 bytes to make room for a New
; Simple Variable, then enter 7 bytes of New Variable Data into the hole:
; ==============================================================================
;                                     ;Set to Move Array Table 7 bytes higher:
; ------------------------------------------------------------------------------
;                                     ;Set (LOWTR) = Lowest Source Address:
MKNEWVAR        LDA   ARYTAB          ;Get Start of Arrays Pointer, Low
                LDY   ARYTAB+1        ;Get Start of Arrays Pointer, High
                STA   LOWTR           ;Set Block Copy Source Start Pointer, Low
                STY   LOWTR+1         ;Set Block Copy Source Start Pointer, High
; ----------------------------------- ;Set (HIGHTR) = Highest Source Address +1:
                LDA   STREND          ;Get End of Arrays Pointer, Low
                LDY   STREND+1        ;Get End of Arrays Pointer, Low
                STA   HIGHTR          ;Set as End of Arrays Pointer, Low
                STY   HIGHTR+1        ;Set as End of Arrays Pointer, High
; ----------------------------------- ;Set (HIGHDS) = Highest Dest Adrs +1:
                CLC                   ;Prepare for Add with Carry
                ADC   #7              ;Add 7 bytes to the Top Address
                BCC   MNVSPA          ;If (C=0), NO Carry Over, Skip Page Advance
                INY                   ;If (C=1), Carry Over, Advance Page
;                                     ;(HIGHDS) = Highest Destination Adrs +1:
MNVSPA          STA   HIGHDS          ;Set Block Copy Destination Pointer, Low
                STY   HIGHDS+1        ;Set Block Copy Destination Pointer, High
; ------------------------------------------------------------------------------
                JSR   MVBLKUP1        ;Move Memory Block Upward
;                                     ;Returns (HIGHDS) Reduced to (LOWTR+8): 
;                                     ;(HIGHDS-1)=(LOWTR+7); (HIGHTR-1)=(LOWTR)
; ------------------------------------------------------------------------------
;                                     ;Store (LOWTR+8) = New Start of Arrays:
                LDA   HIGHDS          ;Get Block Copy Destination Pointer, Low
                LDY   HIGHDS+1        ;Get Block Copy Destination Pointer, High
                INY                   ;Advance Page: MVBLKUP1 leaves it 1 too low
                STA   ARYTAB          ;Set Start of Arrays Pointer, Low
                STY   ARYTAB+1        ;Set Start of Arrays Pointer, High
; ----------------------------------- ;Set New Variable Pointer Data (7 bytes):
;                                     ;VARNAM: Last-Used Variable Name Pointer
;                                     ;is being used here to store the Var Name 
;                                     ;(Bytes)=($:+-;%:--;Real:++;Function:-+)
                LDY   #0              ;Clear Indirect Addressing Index
                LDA   VARNAM          ;Get Last-Used Variable Name, Low
                STA   (LOWTR),Y       ;Set New Variable Name, Low (Byte 0)
                INY                   ;Advance Indirect Addressing Index
                LDA   VARNAM+1        ;Get Last-Used Variable Name, High (Byte 1)
                STA   (LOWTR),Y       ;Set New Variable Name, High
                LDA   #0              ;Clear Accumulator (for Real # Components)
                INY                   ;Advance Indirect Addressing Index
                STA   (LOWTR),Y       ;Clear Exponent (Byte 2)
                INY                   ;Advance Indirect Addressing Index
                STA   (LOWTR),Y       ;Clear Mantissa, Top (Byte 3)
                INY                   ;Advance Indirect Addressing Index
                STA   (LOWTR),Y       ;Clear Mantissa, High (Byte 4)
                INY                   ;Advance Indirect Addressing Index
                STA   (LOWTR),Y       ;Clear Mantissa, Middle (Byte 5)
                INY                   ;Advance Indirect Addressing Index
                STA   (LOWTR),Y       ;Clear Mantissa, Low (Byte 6)
; ----------------------------------- ;Set VARPTR & [(A,Y)={Low,High}] to New 
;                                     ;Variable's Real # Value Address (Byte 2):
SETVARPTRYA     LDA   LOWTR           ;Get New Start of Arrays Pointer, Low
                CLC                   ;Prepare for Add with Carry
                ADC   #2              ;Point to Real # Components
                LDY   LOWTR+1         ;Get New Start of Arrays Pointer, High
                BCC   SETVARPTR       ;If (C=0), NO Carry Over, Skip Page Advance
                INY                   ;If (C=1), Carry Over, Advance Page
SETVARPTR       STA   VARPTR          ;Set Last-Used Variable Value Pointer, Low
                STY   VARPTR+1        ;Set Last-Used Variable Value Pointer, High
;                                     ;Now: Points to 1st Byte of Value
                RTS                   ;Return to Caller

; ==============================================================================
; Compute Address of First Value in Array:     [(ARYPTR)=(LOWTR)+((Dims)*2)+(5)]
; ==============================================================================
; NOTE: (ARYPTR) = (HIGHDS)
; ------------------------------------------------------------------------------
;       (ARYPTR) = Applesoft Array Pointer
;       (HIGHDS) = Highest Destination Adrs +1
; ------------------------------------------------------------------------------
GETARY          LDA   NUMDIM          ;Get Number of Array Dimensions
GETARY2         ASL   A               ;Double it
                ADC   #5              ;& Add 5 Bytes for: Name, Offset, # of Dims
                ADC   LOWTR           ;Add Start of Arrays (New Var) Ptr, Low
                LDY   LOWTR+1         ;Get Start of Arrays (New Var) Ptr, High
                BCC   GETARY3         ;If (C=0), NO Carry Over, Skip Page Advance
                INY                   ;If (C=1), Carry Over, Advance Page
; ----------------------------------- ;Set Array Pointer (ARYPTR):
GETARY3         STA   ARYPTR          ;Set as Array's First Value Pointer, Low
                STY   ARYPTR+1        ;Set as Array's First Value Pointer, High
;                                     ;Now: Points to 1st Value in Array 
;                                     ;Holding: Size of Last Array Dimension, Hi
;                                     ;Returns [(ARYPTR)=(LOWTR)+((Dims)*2)+(5)]
;                                     ;        [(ARYPTR)=[(A,Y)={Low,High}]]
                RTS                   ;Return to Caller

; ==============================================================================
; The Number -32768                            [(Deficient) Packed FAC Constant]
; ==============================================================================
; <<< Meant to be -32768, which would be $9080000000, but it's 1 Byte short, so
; it picks up $20 from next instruction, making it $9080000020, -32768.00049 >>>
; ------------------------------------------------------------------------------
; 
NEG32768        HEX   90800000        ;The Number -32768.00049

; ==============================================================================
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) BAD32768 HEX 9080000020 |(FF) |$90-$80=$10=+16 |$.80000020 |-3.27680005E+4
; (!) POS32768 HEX 9080000000 |(00) |$90-$80=$10=+16 |$.80000000 |+3.27680000E+4
; (!) NEG32768 HEX 9080000000 |(FF) |$90-$80=$10=+16 |$.80000000 |-3.27680000E+4
; ------------------------------------------------------------------------------
; Hexadecimal point moves +16 bits (4 nibbles) &      $8000.0020 = 32768.00049
;     Decimal point moves 4 digits to the right:      $8000.0000 = 32768.00000
; ------------------------------------------------------------------------------
; Plugging it into & Printing FAC ($ED2EG) results in +32768, not -32768, unless
; * FACSIGN msb is also set ($80-$FF), which causes printing of the minus sign!
; ==============================================================================
; 
; <<< ====================================================================== >>>
; <<< BUG in Constant NEG32768:                                              >>>
; <<< ====================================================================== >>>
; <<<  Another mistake(?) here in Billy-Boy's (Microsoft?/Applesoft!) BASIC  >>>
; <<< ---------------------------------------------------------------------- >>>
; <<<          BUG: 10 A=-32768.00049 : A%=A : REM This is accepted          >>>
; <<<               20 PRINT A,A% : REM But this shows that:                 >>>
; <<<               30 REM A=-32768.0005 (OK), A%=32767 [No Error?]          >>>
; <<<               40 REM WRONG! WRONG! WRONG!         [See above]          >>>
; <<< ---------------------------------------------------------------------- >>>
; <<<     You cannot change this in (Apple II Plus) Emulator ROM images!     >>>
; <<< ====================================================================== >>>
; 
; 
; ==============================================================================
; Evaluate Numeric Formula at TXTPTR
; Converting Result to Integer (0 <= X <= 32767) in TMPVPTR (FAC+3,4)
; ==============================================================================
; 
MAKINT          JSR   CHRGET          ;Get Next Char/Token
                JSR   FRMNUM          ;Evaluate & Assure Expression is Numeric
; ==============================================================================
; Convert FAC to Integer; Must be positive and less than 32768
; ==============================================================================
MKINT           LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                BMI   IQERROR         ;Throw Illegal Quantity Error if Negative
; ==============================================================================
; Convert FAC to an integer; Must be -32767 <= FAC <= 32767
; ==============================================================================
AYINT           LDA   FAC             ;Exponent of Value in FAC
                CMP   #$90            ;(NEG32768's Exponent): Abs(Value) < 32768?
                BCC   CNVRT2INT       ;YES, OK for Integer Conversion
; ------------------------------------------------------------------------------
; The Next few lines are supposed to allow -32768 ($8000), but do not because
; compared to -32768.00049   [Really? Look at the Limits. Maybe it's by design!]
; ------------------------------------------------------------------------------
                LDA   #<NEG32768      ;NO; Get Address of Number to compare, Low
                LDY   #>NEG32768      ;Get Address of Number to compare, High
;                     --------------- ;[See above: "BUG in Constant NEG32768"]:
                JSR   FCOMP           ;Compare FAC with Packed Number at (A,Y) ^
;                                     ;Rtns: (A)=(-1|0|1)<--(A,Y)=[(>|=|<) FAC]
IQERROR         BNE   IQERR           ;Go Print "?Illegal Quantity" Error Message
; ------------------------------------------------------------------------------
; Go to Quick Greatest Integer Function:
; Converts FP Value in FAC to Integer Value in FAC Mantissa.
; ------------------------------------------------------------------------------
CNVRT2INT       JMP   QINT            ;Convert FAC to (4 Byte) Integer

; ==============================================================================
; Locate an Array Element or Create an Array
; ==============================================================================
ARRAY           LDA   SUBFLG          ;Get Subscript Flag ($00=Allowed, $80=NOT)
                BNE   FNDARY          ;Branch if Subscripts NOT Allowed
; ----------------------------------- ;Subscripts Given, Parse Subscript List:
;                                     ;Save Array [(DIMFLG) & (INTFLG)]:
                LDA   DIMFLG          ;Get Array Dimension Flag (DIM Call <> 0)
                ORA   INTFLG          ;Set to Negative if Integer Variable (%)
                PHA                   ;Push Array Dimension Flag
; ----------------------------------- ;Save Variable Type ($00=Num, $FF=Str):
                LDA   VALTYP          ;Get Variable Type
                PHA                   ;Push Variable Type 
; ----------------------------------- ;Parse Subscript List:
                LDY   #0              ;Init Dimension/Subscript/Loop Counter
; ----------------------------------- ;Save Dimension/Subscript/Loop Counter:
NXTDIM          TYA                   ;Get Number of Dimensions Counted
                PHA                   ;Push Number of Dimensions Counted
; ----------------------------------- ;Save Variable Name:
                LDA   VARNAM+1        ;Get Last-Used Variable Name, High
                PHA                   ;Push Last-Used Variable Name, High
                LDA   VARNAM          ;Get Last-Used Variable Name, Low
                PHA                   ;Push Last-Used Variable Name, Low
; ----------------------------------- ;Evaluate Subcript as Integer:
                JSR   MAKINT          ;Evaluate Numeric Formula at TXTPTR
;                                     ;Converts Result to an Integer in TMPVPTR
; ----------------------------------- ;Restore Variable Name:
                PLA                   ;Pull Last-Used Variable Name, Low
                STA   VARNAM          ;Set Last-Used Variable Name, Low
                PLA                   ;Pull Last-Used Variable Name, High
                STA   VARNAM+1        ;Set Last-Used Variable Name, High
; ----------------------------------- ;Restore Loop Counter:
                PLA                   ;Pull Number of Dimensions Counted
                TAY                   ;Set Number of Dimensions Counter
; ----------------------------------- ;Duplicate VALTYP & DIMFLG on the Stack & 
;                                     ;Put Subscript where they were on Stack:
                TSX                   ;Get Stack Pointer for X-Indexed Addressing
                LDA   STACK+2,X       ;Copy VALTYP from Stack (Not Pulled)
                PHA                   ;Push it back on Top of Stack
                LDA   STACK+1,X       ;Copy DIMFLG from Stack (Not Pulled)
                PHA                   ;Push it back on Top of Stack
                LDA   TMPVPTR         ;Get Subscript Value, Low  (FAC+3)
                STA   STACK+2,X       ;Place on the Stack where VALTYP was
                LDA   TMPVPTR+1       ;Get Subscript Value, High (FAC+4)
                STA   STACK+1,X       ;Place on the Stack where DIMFLG was
                INY                   ;Count the Dimension/Subscript/Iteration
; ----------------------------------- ;More Dimensions/Subscripts?
                JSR   CHRGOT          ;Get Last Character/Token Got
                CMP   #','            ;Is it a Comma?
                BEQ   NXTDIM          ;YES, Loop until all Dims/Subs put on Stack
; ----------------------------------- ;NO more Dimensions/Subscripts; Finish Up:
                STY   NUMDIM          ;Save Count of Dimensions/Subscripts
                JSR   CHKCLS          ;Check for Closing Parenthesis [")"]
                PLA                   ;Pull VALTYP from Top of Stack
                STA   VALTYP          ;Restore Variable Type
                PLA                   ;Pull DIMFLG from Top of Stack
                STA   INTFLG          ;Restore Integer Variable Flag (msb)
                AND   #%01111111      ;Mask off Integer Variable Flag (msb)
                STA   DIMFLG          ;Restore Array Dimension Flag
; 
; ==============================================================================
; Search Array Table for this Array Name
; ==============================================================================
; 
FNDARY          LDX   ARYTAB          ;Get Start of Arrays Pointer, Low
                LDA   ARYTAB+1        ;Get Start of Arrays Pointer, High
;                                     ;[(X,A)={Low,High}] = Search Pointer
ARYLOOP         STX   LOWTR           ;Set Array Variable Search Pointer, Low
                STA   LOWTR+1         ;Set Array Variable Search Pointer, High
                CMP   STREND+1        ;Compare to End of Arrays Pointer, High
                BNE   ARYNAME         ;Branch if Not at End of Array Table
                CPX   STREND          ;Compare to End of Arrays Pointer, Low
                BEQ   NEWARYVAR       ;Make New Array Variable if at End of Table
;                                     ;Else, Found Array Var Name, Check it:
ARYNAME         LDY   #0              ;Point at 1st Character of Array Name
                LDA   (LOWTR),Y       ;Get 1st Character of Array Name
                INY                   ;Point at 2nd Character of Array Name
                CMP   VARNAM          ;Are Variable Names' 1st Characters Equal?
                BNE   NXTARY          ;Keep Searching if Not a Match
                LDA   VARNAM+1        ;Get 2nd Character of Array Name
                CMP   (LOWTR),Y       ;Are Variable Names' 2nd Characters Equal?
                BEQ   ARYVARFND       ;Use Old Array Variable if Match Found
;                                     ;Else, Not a Match, Keep Searching:
NXTARY          INY                   ;Point at Offset to Next Array, Low
                LDA   (LOWTR),Y       ;Get Offset to Next Array, Low
                CLC                   ;Prepare for Add with Carry
                ADC   LOWTR           ;Add Array Variable Search Pointer, Low
                TAX                   ;Save Array Variable Search Pointer, Low
                INY                   ;Point at Offset to Next Array, High
                LDA   (LOWTR),Y       ;Get Offset to Next Array, High
                ADC   LOWTR+1         ;Add Array Variable Search Pointer, High
;                                     ;[(X,A)={Low,High}] = Search Pointer
                BCC   ARYLOOP         ;Loop-Back; Always Taken; If Not Taken,
;                                     ;"Something is Wrong with the Universe!"
; 
; ==============================================================================
; Print "Bad Subscript" or "Illegal Quantity" Error Message
; ==============================================================================
; 
; ----------------------------------- ;Error Entry Point; Also User-Callable:
SUBERR          LDX   #ERR_BADSUBS    ;Print "?Bad Subscript" Error Message
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ----------------------------------- ;Error Entry Point; Also User-Callable:
IQERR           LDX   #ERR_ILLQTY     ;Print "?Illegal Quantity" Error Message
JMPERR          JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Match Found: Use Old Array Variable
; ==============================================================================
; 
; ----------------------------------- ;Error Entry Point; NOT so User-Callable:
ARYVARFND       LDX   #ERR_REDIMD     ;Get "?Redim'd Array" Error Message Index
                LDA   DIMFLG          ;Get Array Dimension Flag (DIM Call <> 0)
                BNE   JMPERR          ;Do Error if Called from DIM Statement
;                                     ;^(Print Error Message based on X-Reg)
                LDA   SUBFLG          ;Get Subscript Flag ($00=Allowed, $80=NOT)
                BEQ   CHKDIM          ;If Allowed, Check if # of Dimensions Match
                SEC                   ;Else, NOT Allowed; So Signal Array Found!
;                                     ;\[Required by "STORE" Arrays to Tape Stt]
                RTS                   ;Return to Caller (Exit if from GETARYPTR)

; ----------------------------------- ;Prepare to Find Array Element Specified:
CHKDIM          JSR   GETARY          ;Point to 1st Value in Array: 
;                                     ;Holding: Size of Last Array Dim, High
;                                     ;Rtns: [(ARYPTR)=(LOWTR)+((Dims)*2)+(5)]
;                                     ;      [(ARYPTR)=[(A,Y)={Low,High}]]
; 
; ----------------------------------- ;Check if Number of Dimensions Match:
                LDA   NUMDIM          ;Get Number of Array Dimensions Specified
                LDY   #4              ;Point at Number of Array Dimensions (Old)
                CMP   (LOWTR),Y       ;Do Arrays' Numbers of Dimensions Match?
                BNE   SUBERR          ;NO: Print "?Bad Subscript" Error Message
                JMP   FNDARYELM       ;YES: Find Array Element Specified

; 
; ==============================================================================
; Match NOT Found: Make New Array Variable?
; ==============================================================================
;                                     ;Check if Called from GETARYPTR:
NEWARYVAR       LDA   SUBFLG          ;Get Subscript Flag ($00=Allowed, $80=NOT)
                BEQ   MAKARY          ;If Allowed, Create a New Array 
;                                     ;Else, Error!--Called from GETARYPTR:
; ----------------------------------- ;User-Callable Error Entry Point:
NODATERR        LDX   #ERR_NODATA     ;Throw an "?Out Of Data" Error
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Make New Array Variable!
; ==============================================================================
MAKARY          JSR   GETARY          ;Point to 1st Value in Array: 
;                                     ;Holding: Size of Last Array Dimension, Hi
;                                     ;Rtns: [(ARYPTR)=(LOWTR)+((Dims)*2)+(5)]
                JSR   REASON          ;Assure: [(ARYPTR)=(A,Y)={Lo,Hi}]<(FRETOP)
; ------------------------------------------------------------------------------
; Point at Variable Name & Start Element Size Calculation:
; ------------------------------------------------------------------------------
; Here, Element Size (in bytes) is the Variable's Descriptor Part.
; In a Simple Variable Pointer, it is preceded by the Variable Name (2 bytes), &
; may be succeeded by a number of unused bytes, for a total of seven bytes.
; For Array Variables, the Dimension Size Elements (2 bytes each) succeed the
; Variable's Descriptor Part & the Pointer may exceed seven bytes in total
; length.  These will also be added into the Element Size (below), which then
; becomes more than just the Variable's Descriptor, & is referred to as the
; "Total Bytes of all Array Elements."
; [Add two for the Array Varibles's Name at the beginning & you have the whole
; Array Variable Pointer length!  So, why not just subtract 2 for the total?]
; ------------------------------------------------------------------------------
                LDA   #0              ;Clear Accumulator
                TAY                   ;Clear Indirect Addressing Index
;                                     ;^(Point at 1st Char of Variable Name)
                STA   STRNG2+1        ;Clear Size: Number of Array Elements, High
;             ------------------------------------------------------------------
;             <<< NOTE: The 3 OP lines above could have been written as 2: >>>
;             ------------------------------------------------------------------
;             LDY     #0              ;Clear Indirect Addressing Index
;                                     ;^(Point at 1st Char of Variable Name)
;             STY     STRNG2+1        ;Clear Size: No. of Array Elements, High
;             ------------------------------------------------------------------
                LDX   #5              ;Assume Real Array Element Size: = 5 bytes
;                                     ;VARNAM: Last-Used Variable Name Pointer
;                                     ;is being used here to store the Var Name 
;                                     ;(Bytes)=($:+-;%:--;Real:++;Function:-+)
                LDA   VARNAM          ;Get Last-Used Variable Name, Low (1st Chr)
                STA   (LOWTR),Y       ;Set New Array Variable Name, Low (1st Chr)
                BPL   ARYNOTINT       ;Branch if Not an Integer Array
                DEX                   ;Integer Array: Reduce Size to 4 Bytes
ARYNOTINT       INY                   ;Advance Indirect Addressing Index to 1
;                                     ;^(Point at 2nd Char of Variable Name)
                LDA   VARNAM+1        ;Get Last-Used Variable Name, High (2nd Chr)
                STA   (LOWTR),Y       ;Set New Array Variable Name, High (2nd Chr)
                BPL   ARYISREAL       ;Real Array: Keep Size of 5 bytes
                DEX                   ;String Array: Reduce Size to 3 Bytes
                DEX                   ;Integer Array: Reduce Size to 2 Bytes
; ------------------------------------------------------------------------------
; Now: (X)=(5|3|2)=(Real|String|Integer)=[Size of Var's Descriptor Part (bytes)]
; (Unused)=(0|2|3)=(Real|String|Integer)=[Latter bytes of Variable Pointer]
;      (VarPtrLen)=(VarNameLen)+(X)+(Unused)=(2)+(X)+(Unused)=(7)
;              (X)=(VarPtrLen)-(VarNameLen)-(Unused)=(7-2)-(Unused)=(5)-(Unused)
; ------------------------------------------------------------------------------
ARYISREAL       STX   STRNG2          ;Store Size: Number of Array Elements, Low
; ------------------------------------------------------------------------------
                LDA   NUMDIM          ;Get Number of Dimensions
;                                     ;Bypass Offset to Next Array (set later):
                INY                   ;Advance Indirect Addressing Index to 2
                INY                   ;Advance Indirect Addressing Index to 3
                INY                   ;Advance Indirect Addressing Index to 4
                STA   (LOWTR),Y       ;Store # of Dims in 5Th Byte of Array Ptr
; ------------------------------------------------------------------------------
; Save Dimensions LOOP: Stores Dimension Elements in Array Variable Pointer
; ------------------------------------------------------------------------------
SAVDIM          LDX   #11             ;Default Dimension, Low  (10+1=11 Elements)
                LDA   #0              ;Default Dimension, High (Zero)
                BIT   DIMFLG          ;Check Array Dimension Flag (DIM Call <> 0)
                BVC   DFLTDIM         ;Use Default Value if NOT Dimensioned Array
; ----------------------------------- ;Put Specified DIM in [(X,A)={Low,High}]:
                PLA                   ;Pull Specified Array Dimension, Low
                CLC                   ;Prepare for Add with Carry
                ADC   #1              ;Size: [(Elements)=(Specified Dimension)+1]
                TAX                   ;Set (X) to Number of Dim Elements, Low
                PLA                   ;Pull Specified Array Dimension, High
                ADC   #0              ;Set (A) to Number of Dim Elements, High
; ------------------------------------------------------------------------------
; Build Dimension Table within Array Variable:
; ------------------------------------------------------------------------------
; DIMs start with the last one & go down to first (N, N-1, N-2, ..., 2, 1, 0); 
; Each DIM is 2 bytes long & in {High,Low} (vs. the normal {Low,High}) format!
; ------------------------------------------------------------------------------
;                                     ;Add Dimension Size to Array Descriptor:
DFLTDIM         INY                   ;Advance Indirect Addressing Index
;                                     ;^(Point at Next Dimension Size, High)
                STA   (LOWTR),Y       ;Set Size: Number of Dim Elements, High
                INY                   ;Advance Indirect Addressing Index
;                                     ;^(Point at Next Dimension Size, Low)
                TXA                   ;Get Size: Number of Dim Elements, Low
                STA   (LOWTR),Y       ;Set Size: Number of Dim Elements, Low
;                                     ;-----------------------------------------
                JSR   MULTSUBS        ;Multiply this Dimension by Running Size
;                                     ;-----------------------------------------
                STX   STRNG2          ;Store Running Size, Low
                STA   STRNG2+1        ;Store Running Size, High
                LDY   INDEX           ;Retrieve (Y) saved by MULTSUBS
;                                     ;^(Point at Last-Used Dimension Size, Low)
                DEC   NUMDIM          ;Count Down: Number of Dimensions
                BNE   SAVDIM          ;Loop until Done: Count Down to Zero
; ------------------------------------------------------------------------------
; Now: Total Bytes of all Array Elements (Running Size) is [(X,A)={Low,High}]
; ==============================================================================
; Get Address at End of Array & Assure sufficient Arrays-to-Strings Free-Space:
; ------------------------------------------------------------------------------
;                                     ;Point to End of Array (Compute Address):
                ADC   ARYPTR+1        ;Add Address of 1st Value in Array, High
                BCS   GME             ;Do "?Out Of Memory" Error if too large
                STA   ARYPTR+1        ;Save as Array End Address, High
                TAY                   ;Save High End Address in (Y), too
                TXA                   ;Get Total Bytes of all Array Elements, Low
                ADC   ARYPTR          ;Add Address of 1st Value in Array, Low
                BCC   CHKARYSPC       ;Skip Advancing High Byte if NO Carryover
                INY                   ;Add Carry to (Y): Array End Address, High
                BEQ   GME             ;Do "?Out Of Memory" Error if too large
; ------------------------------------------------------------------------------
; Now: [(A,Y)={Low,High}] = Address to which Array Space needs to grow
; ------------------------------------------------------------------------------
CHKARYSPC       JSR   REASON          ;Assure [(ARYPTR)=(A,Y)={Low,High}]<(FRETOP)
                STA   STREND          ;Set End of Array Vars & Ptrs Storage, Low
                STY   STREND+1        ;Set End of Array Vars & Ptrs Storage, High
; ----------------------------------- ;Prepare to Clear the Array:
                LDA   #0              ;Prepare to Zero the Array Elements
;                                     ;Compensate for Reduction at Top of Loop:
                INC   STRNG2+1        ;Advance Count: Running Size, High
                LDY   STRNG2          ;Get Count: Running Size, Low
                BEQ   CLRNXTPG        ;Branch if No Partial Page to Clear
; ----------------------------------- ;Clear the Array (from Top to Bottom):
CLRARY          DEY                   ;Reduce Count: Running Size, Low
                STA   (ARYPTR),Y      ;Clear a Page of 256 Bytes or less
                BNE   CLRARY          ;Loop until Done with Page
; ----------------------------------- ;Clear the Array (Full Pages Entry Point):
CLRNXTPG        DEC   ARYPTR+1        ;Reduce Page: Array End Address, High
                DEC   STRNG2+1        ;Reduce Count: Running Size, High
                BNE   CLRARY          ;Loop until Done with All Pages
; ------------------------------------------------------------------------------
; Compute Offset to Next Variable (End Of Arrays) & Store in Array Descriptor:
; ------------------------------------------------------------------------------
;                                     ;Point at this Array's 1st Element:
                INC   ARYPTR+1        ;Advance Page: Array End Address, High
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                LDA   STREND          ;Get End of Array Vars & Ptrs Storage, Low
                SBC   LOWTR           ;Subtract this Array Variable Address, Low
                LDY   #2              ;Point at Offset to Next Variable, low
                STA   (LOWTR),Y       ;Set Offset to NxtVar (End Of Arrays), low
                LDA   STREND+1        ;Get End of Array Vars & Ptrs Storage, High
                INY                   ;Point at Offset to Next Variable, High
                SBC   LOWTR+1         ;Subtract this Array Variable Address, High
                STA   (LOWTR),Y       ;Set Offset to NxtVar (End Of Arrays), High
; ----------------------------------- ;Was this S/R Called from a DIM Statement?
                LDA   DIMFLG          ;Get Array Dimension Flag (DIM Call <> 0)
                BNE   BAS_RTS14       ;YES: We Are Finished!
;                                     ;NO: Now we need to find the Element
; 
; ==============================================================================
; Find Array Element Specified
; ==============================================================================
; (LOWTR),Y Points at Number of Dimensions in the Array Descriptor.
; The Dimension Subscripts are all on the Stack as Integers.
; ==============================================================================
; 
                INY                   ;Point at Number of Dimensions
FNDARYELM       LDA   (LOWTR),Y       ;Get Number of Dimensions
                STA   NUMDIM          ;Save Number of Dimensions
                LDA   #0              ;Clear Accumulator
                STA   STRNG2          ;Clear Subscript Accumulator, Low; & High:
; ----------------------------------- ;Dimension {Check/Look-Up/Search} Loop:
DIMLUP          STA   STRNG2+1        ;Set Subscript Accumulator, High
                INY                   ;Point at Last Dimension Size, High
                PLA                   ;Pull Next Subscript, Low
                TAX                   ;Save it in X-Reg as Current Subscript, Low
                STA   TMPVPTR         ;Set (FAC+3) as Current Subscript, Low 
                PLA                   ;Pull Next Subscript, High
                STA   TMPVPTR+1       ;Set (FAC+4) as Current Subscript, High
                CMP   (LOWTR),Y       ;Compare it with Dimensioned Size, High
                BCC   DIMOK           ;Branch if Subscript is Not Too Large
                BNE   GSE             ;Branch if Subscript is Too Large (Error!)
                INY                   ;Point at Last Dimension Size, Low
                TXA                   ;Retrieve Current Subscript, Low
                CMP   (LOWTR),Y       ;Compare it with Dimensioned Size, Low
                BCC   DIMOK1          ;Branch if Subscript is Not Too Large
;                                     ;Else, Subscript is Too Large (Error!)
; 
; ------------------------------------------------------------------------------
; Error Vectors:
; ------------------------------------------------------------------------------
; 
GSE             JMP   SUBERR          ;Print "?Bad Subscript" Error Message

GME             JMP   MEMERR          ;Do "?Out Of Memory" Error

; ------------------------------------------------------------------------------
; Find Array Element Specified (continued)
; ------------------------------------------------------------------------------
; 
;                                     ;Determine if 1st time through S/R:
DIMOK           INY                   ;Point at Last Dimension Size, Low
DIMOK1          LDA   STRNG2+1        ;Get Subscript from Sub Accumulator, High
                ORA   STRNG2          ;Get Subscript from Sub Accumulator, Low
;                                     ;(A)=(High OR Low)=(0) if Subscript is 0
                CLC                   ;Prepare for Add with Carry
                BEQ   NEXTDIM         ;Branch if (A)=(0): 1st time through
;                                     ;^ Also prevents Multiplying by Zero
                JSR   MULTSUBS        ;Not Zero, So Multiply Subscripts
;                                     ;---- Multiplies: [(STRNG2)*[(LOWTR),Y]]
;                                     ;Returns Product: [(X,(A=Y))={Low,High}]
                TXA                   ;Get from (X): Product of Subscripts, Low
;                                     ;^[Overwrites (A): Product of Subs, High)
                ADC   TMPVPTR         ;Add Current Subscript, Low  (FAC+3)
                TAX                   ;Save Result in X-Reg
                TYA                   ;Get from (Y): Product of Subscripts, High
                LDY   INDEX           ;Retrieve (Y): Saved by MULTSUBS
;                                     ;^(Points at Last Dimension Size, Low)
NEXTDIM         ADC   TMPVPTR+1       ;Add Current Subscript, High (FAC+4)
                STX   STRNG2          ;Store Accumulated Offset, Low
                DEC   NUMDIM          ;Reduce Loop Counter: Number of Dimensions
                BNE   DIMLUP          ;Loop until All Subscripts are Done
;                                     ;Now Multiply by Element Size:
                STA   STRNG2+1        ;Store Accumulated Offset, High
                LDX   #5              ;Real Array: Start with Size of 5 Bytes
                LDA   VARNAM          ;Get Last-Used Variable Name Pointer, Low
                BPL   DIMNOTINT       ;Branch if Not Integer Variable
                DEX                   ;Else, Integer: Reduce Size to 4 Bytes
DIMNOTINT       LDA   VARNAM+1        ;Get Last-Used Variable Name Pointer, High
                BPL   DIMISREAL       ;Branch if Real: Keep Size of {5|4} Bytes
                DEX                   ;String Array: Reduce Size to 3 Bytes
                DEX                   ;Integer Array: Reduce Size to 2 Bytes
DIMISREAL       STX   RESULT+2        ;Set Multiplier: Size of Each Entry, Low
                LDA   #0              ;Set Multiplier: Size of Each Entry, High
                JSR   MULTSUBS1       ;Multiply Product of Dimensions (STRNG2) by
;                                     ;Size of Each Element [(X,A)={Low,High}]
;                                     ;Returns Product: [(X,(A=Y))={Low,High}]
                TXA                   ;Get from (X): Accumulated Offset, Low
;                                     ;^[Overwrites (A): Accumulated Offset, Hi]
                ADC   ARYPTR          ;Add Address of 1st Array Element, Low
                STA   VARPTR          ;Set Specified Element Pointer, Low
                TYA                   ;Get from (Y): Accumulated Offset, High
                ADC   ARYPTR+1        ;Add Address of 1st Array Element, High
                STA   VARPTR+1        ;Set Specified Element Pointer, High
                TAY                   ;Set (Y): Specified Element Pointer, High
                LDA   VARPTR          ;Set (A): Specified Element Pointer, Low
;                                     ;--- (X): Accumulated Offset, Low
BAS_RTS14       RTS                   ;Return [(A,Y)={Low,High}] & (X) to Caller

; ==============================================================================
; 16-bit Integer Multiplication Routine: (Used Only by Array Subscript Routines)
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; 1st Entry Point Returns Product: [(X,(A=Y))={Low,High}]=[(STRNG2)*[(LOWTR),Y]]
; ------------------------------------------------------------------------------
MULTSUBS        STY   INDEX           ;Save (Y) for Caller to Retieve after RTS
                LDA   (LOWTR),Y       ;Get Multiplier, Low
                STA   RESULT+2        ;Save Multiplier, Low
                DEY                   ;Point at Multiplier, High
                LDA   (LOWTR),Y       ;Get Multiplier, High
; ------------------------------------------------------------------------------
; 2nd Entry Point Returns Product: [(X,(A=Y))={Low,High}]=[(STRNG2)*(X,A)]
; ------------------------------------------------------------------------------
MULTSUBS1       STA   RESULT+3        ;Save Multiplier, High
                LDA   #16             ;Get Index for 16-bit Multiplication
                STA   INDX            ;Set Index for 16-bit Multiplication
;                                     ;Initialize Product:
                LDX   #0              ;Clear Product, Low
                LDY   #0              ;Clear Product, High
; ----------------------------------- ;Multiply Subs Loop:
MLTSBSLOOP      TXA                   ;Get Product, Low
                ASL   A               ;Double Product, Low
                TAX                   ;Save Product, Low
                TYA                   ;Get Product, High
                ROL   A               ;Double Product (& Add Carry), High
                TAY                   ;Save Product, High
                BCS   GME             ;Do "?Out Of Memory" Error if too large
                ASL   STRNG2          ;Double Subscript Accumulated Offset, Low
                ROL   STRNG2+1        ;Double Subs Accumulated Offset (+C), High
                BCC   MULTSUBS1_2     ;BLT: Branch if Not too large
;                                     ;Else: Add into Partial Product:
                CLC                   ;Prepare for Add with Carry
                TXA                   ;Get Product, Low
                ADC   RESULT+2        ;Add (with Carry) Multiplier, Low
                TAX                   ;Save Product, Low
                TYA                   ;Get Product, High
                ADC   RESULT+3        ;Add (with Carry) Multiplier, High
                TAY                   ;Save Product, High
                BCS   GME             ;Do "?Out Of Memory" Error if too large
MULTSUBS1_2     DEC   INDX            ;Reduce Bit Counter Index
                BNE   MLTSBSLOOP      ;Loop Untill All 16-bits are Done
                RTS                   ;Return [(X,(A=Y))={Low,High}] to Caller

; ==============================================================================
; "FRE" Statement: Immediate & Deferred; Parameter: FRE (Any Legal Expression);
; E.g., X=FRE(0); Collects Garbage & Returns Number of Bytes of Free Memory left
; ==============================================================================
; 
FRE             LDA   VALTYP          ;Get Variable Type ($00=Num, $FF=Str)
                BEQ   FREESPACE       ;Branch if Variable Type is Numeric
                JSR   FREFAC          ;Free up TMPVPTR & a Temp String
FREESPACE       JSR   GARBAGE         ;Maximize Free-Space, Collect Garbage ...
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                LDA   FRETOP          ;Get FreSpcEnd & StringStorageStart, Low
                SBC   STREND          ;Subtract End of Vars & Ptrs Storage, Low
                TAY                   ;Now: (Y) is Free Space, Low
                LDA   FRETOP+1        ;Get FreSpcEnd & StringStorageStart, High
                SBC   STREND+1        ;Subtract End of Vars & Ptrs Storage, High
;                                     ;Now: (A) is Free Space, High
; 
; ------------------------------------------------------------------------------
; Float Signed Integer in [(Y,A)={Low,High}] into FAC
; ------------------------------------------------------------------------------
; 
GIVAYF          LDX   #0              ;Clear X-Index Register
                STX   VALTYP          ;Set Variable Type as Numeric (=0)
                STA   FAC+1           ;Save (A) in FAC Mantissa, Top; (A)={High}
                STY   FAC+2           ;Save (Y) in FAC Mantissa, High; (Y)={Low}
;                                     ;<<< Don't FAC+3,4 Need to be Cleared? >>>
                LDX   #$90            ;Set Exponent to 2^16 = 65,536 = %0001,0000
;                                     ;FAC FP#, So Set High Bit: $90=%1001,0000
;                                     ;(Shifts Decimal Pt. 16-bits to the Right)
                JMP   FLOAT1          ;Convert to Signed Real/FP Number in FAC

; ==============================================================================
; "POS" Position Function
; ==============================================================================
; 
POS             LDY   CH              ;Get Current Cursor Horizontal Displacement
; 
; ------------------------------------------------------------------------------
; Convert Number in Y-Index Register to Real/FP Number in FAC
; ------------------------------------------------------------------------------
; 
;                                     ;Float Unsigned Integer & Flag as Number:
SNGFLT          LDA   #0              ;Clear Accumulator; for: [(Y,A)={Low,High}]
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
;                                     ;<< SEC has no purpose whatsoever here! >>
;                                     ;Float Signed Integer in [(Y,A)={Lo,Hi}]:
                BEQ   GIVAYF          ;Always Taken

; ==============================================================================
; Print "?Illegal Direct" or "?Undef'd Function" Error Message
; ==============================================================================
; 
ERRDIR          LDX   CURLIN+1        ;Which Program Mode: Running or Direct?
                INX                   ;If in Direct Mode: (X)=[($FF)-->(0)]
                BNE   BAS_RTS14       ;Branch If in Direct Mode [(X)=(0)]
; ----------------------------------- ;User-Callable Error Entry Point:
IDERR           LDX   #ERR_ILLDIR     ;Throw an "?Illegal Direct" Error
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ----------------------------------- ;Error Entry Point; Also User-Callable:
UNDFNCERR       LDX   #ERR_UNDEFFUNC  ;Throw an "?Undef'd Function" Error
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; "DEF" Statement: Deferred Only;  Defines User Functions in Applesoft Programs
; ==============================================================================
;      Parameters: DEF FN Name (real avar) = aexpr1
;                  FN Name (aexpr2)
; ==============================================================================
;  "FN" Statement: Immediate & Deferred; Puts User Functions to Work [see below]
; ==============================================================================
; Structure of a User Defined Function Variable Pointer:
; ------------------------------------------------------------------------------
; Byte 0: Varible Name Character 1 (Negative):
;      1: Varible Name Character 2 (Postive):
;         ^ [A Function Name is a Simple Variable]
;      2: Address of Definition, Low:
;      3: Address of Definition, High:
;         ^ [Program Memory Address of 1st Character of Expression (after "=")]
;      4: Address of Argument Variable, Low:
;      5: Address of Argument Variable, High:
;         ^ [Address of the Real Variable after the Function Name: FN Name (RV)]
;      6: First Character of Definition:
;         ^ [1st Character of Expression (after "=")]
; ==============================================================================
; 
;                                     ;Setup Function Name Variable:
DEF             JSR   FN_NAME         ;Parse FN, Function Name
                JSR   ERRDIR          ;Do Illegal Direct Error if in Direct Mode
                JSR   CHKOPN          ;Must have Opening Parenthesis ["("] Now!
; ----------------------------------- ;Flag PRTGET that Call's frm here, DEF FN:
                LDA   #$80            ;Flag for Subscripts NOT Allowed
                STA   SUBFLG          ;Set Subscript Flag ($00=Allowed, $80=NOT)
; ----------------------------------- ;Get Pointer to Argument:
                JSR   PTRGET          ;Locate Variable: Returns Address
;                                     ;in VARPTR & [(A,Y)={Low,High}]
; ----------------------------------- ;Assure Proper Form: DEF FN Name (Var)=Exp
                JSR   CHKNUM          ;Assure (FAC) Type is Numeric (VALTYP=$00)
                JSR   CHKCLS          ;Must have Closing Parenthesis [")"] Now!
                LDA   #TOK_EQUAL      ;Must have "Equal To" Char/Token ("=") Now!
                JSR   SYNCHR          ;Check Current Char & Get Next Char/Token
; ----------------------------------- ;[See Next: Common Parse FN_NAME Routine]
;                                     ;Save 1st Character of Definition:
                PHA                   ;Push Char/Token after Equal Sign ("=")
; ----------------------------------- ;Save Pointer to Argument:
                LDA   VARPTR+1        ;Get Last-Used Variable Value Pointer, High
                PHA                   ;Push Last-Used Variable Value Pointer, High
                LDA   VARPTR          ;Get Last-Used Variable Value Pointer, Low
                PHA                   ;Push Last-Used Variable Value Pointer, Low
; ----------------------------------- ;Save CHRGET's Next Char/Token Pointer:
                LDA   TXTPTR+1        ;Get Next Char/Token Pointer, High
                PHA                   ;Push Next Char/Token Pointer, High
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                PHA                   ;Push Next Char/Token Pointer, Low
                JSR   DATA            ;Advance TXTPTR to Next ":" or EOL
                JMP   FN_DATA         ;Store 5 bytes Pushed above into FN "Value"

; ==============================================================================
; Common Routine for DEF FN & FN, to Parse the Function & the Function Name
; ==============================================================================
; 
FN_NAME         LDA   #TOK_FN         ;Must have "FN" Token Now!
                JSR   SYNCHR          ;Check Current Char & Get Next Char/Token
;                                     ;^[Throw Syntax Error If CurChr Not "FN"]
                ORA   #$80            ;Set Sign Bit on 1st Character of FN Name,
                STA   SUBFLG          ;Making $C0 < SUBFLG < $DB,
                JSR   PTRGET3         ;Which tells PTRGET who Called
;                                     ;Found Valid Function Name; Save Address:
                STA   FNCNAM          ;Set Function Name Pointer, Low
                STY   FNCNAM+1        ;Set Function Name Pointer, High
;                                     ;Adrs now in FNCNAM & [(A,Y)={Low,High}]
                JMP   CHKNUM          ;Assure (FAC) Type is Numeric (VALTYP=$00)

; ==============================================================================
; "FN" Statement: Immediate & Deferred; Puts Defined User Functions to Work
; ==============================================================================
;     Parameters: FN Name (aexpr2)
; ==============================================================================
;           [See above: "Structure of a User Defined Function Variable Pointer"]
; ==============================================================================
; 
FN_CALL         JSR   FN_NAME         ;Parse FN, Function Name
; ----------------------------------- ;Stack FN Address for Nested FN Calls:
                LDA   FNCNAM+1        ;Get Function Name Pointer, High
                PHA                   ;Push Function Name Pointer, High
                LDA   FNCNAM          ;Get Function Name Pointer, Low
                PHA                   ;Push Function Name Pointer, Low
; ----------------------------------- ;May have Nested FN Calls:
                JSR   PARCHK          ;Must have "(Expression)" Now; Eval to FAC
                JSR   CHKNUM          ;Assure (FAC) Type is Numeric (VALTYP=$00)
; ----------------------------------- ;Restore FN Address for Nested FN Calls:
                PLA                   ;Pull Function Name Pointer, Low
                STA   FNCNAM          ;Set Function Name Pointer, Low
                PLA                   ;Pull Function Name Pointer, High
                STA   FNCNAM+1        ;Set Function Name Pointer, High
; ------------------------------------;Set Old-Variable Value Pointer:
                LDY   #2              ;Point at Argument Variable Pointer, Low
                LDA   (FNCNAM),Y      ;Get Argument Variable Pointer, Low
                STA   VARPTR          ;Set Old-Variable Value Pointer, Low
                TAX                   ;Save Argument Variable Pointer, Low
                INY                   ;Point at Argument Variable Pointer, High
                LDA   (FNCNAM),Y      ;Get Argument Variable Pointer, High
                BEQ   UNDFNCERR       ;Throw an "?Undef'd Function" Error if Null
                STA   VARPTR+1        ;Else: Set Old-Variable Value Pointer, High
;                                     ;Now AVP is in VARPTR & [(X,A)={Low,High}]
; ----------------------------------- ;Push Value of any pre-existing Old-Var
;                                     ;with the same Name as Argument Variable:
                INY                   ;Now: (Y)=(4) 
SAVOLD          LDA   (VARPTR),Y      ;Get Old-Variable Value
                PHA                   ;Push Old-Variable Value
                DEY                   ;Count Down (Pushes 5 bytes)
                BPL   SAVOLD          ;Loop until Done [(Y)=(0)]
                LDY   VARPTR+1        ;Get Old-Variable Value Pointer, High
; ----------------------------------- ;Now Old-Var Valu is in [(X,Y)={Low,High}]
                JSR   FACRND2XY       ;Store FAC (Rounded) in Old-Variable
; ----------------------------------- ;Save Program Position:
;                                     ;Save CHRGET's Next Char/Token Pointer
;                                     ;(Remember TXTPTR for after FN call):
                LDA   TXTPTR+1        ;Get Next Char/Token Pointer, High
                PHA                   ;Push Next Char/Token Pointer, High
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                PHA                   ;Push Next Char/Token Pointer, Low
; ----------------------------------- ;Point CHRGET at Function Definition:
;                                     ;Now, still: [(Y)=(0)] from FACRND2XY
                LDA   (FNCNAM),Y      ;Get Function Definition Pointer, Low
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                INY                   ;Advance Indirect Addressing Index
                LDA   (FNCNAM),Y      ;Get Function Definition Pointer, High
                STA   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Save Address of Argument Variable:
                LDA   VARPTR+1        ;Get Argument Variable Pointer, High
                PHA                   ;Push Address of Argument Variable, High
                LDA   VARPTR          ;Get Argument Variable Pointer, Low
                PHA                   ;Push Address of Argument Variable, Low
; ----------------------------------- ;AVP is stl in VARPTR & [(X,A)={Low,High}]
                JSR   FRMNUM          ;Evaluate Function
; ----------------------------------- ;Pull & Save Address of Argument Variable:
                PLA                   ;Pull Address of Argument Variable, Low
                STA   FNCNAM          ;Save Argument Variable Pointer, Low
                PLA                   ;Pull Address of Argument Variable, High
                STA   FNCNAM+1        ;Save Argument Variable Pointer, Low
; ----------------------------------- ;Are we Done with the Definition?
                JSR   CHRGOT          ;Get Last Char/Token Gotten
                BEQ   GETOLD          ;TXTPTR Must be at Next ":" or EOL
                JMP   SYNERROR        ;Throw a "?Syntax" Error if it is Not there

; ----------------------------------- ;Retrieve Program Position:
;                                     ;Retrieve CHRGET's Next Char/Token Pointer
;                                     ;(TXTPTR Remembered for after FN call):
GETOLD          PLA                   ;Pull Next Char/Token Pointer, Low
                STA   TXTPTR          ;Restore Next Char/Token Pointer, Low
                PLA                   ;Pull Next Char/Token Pointer, High
                STA   TXTPTR+1        ;Restore Next Char/Token Pointer, High
; ----------------------------------- ;Retrieve Old-Variable Valu; Pull 5 bytes:
FN_DATA         LDY   #0              ;Clear Indirect Addressing Index (=0)
; <<< Why No Count Down Loop here, too; Inverted as in SAVOLD above? >>>
                PLA                   ;Pull Old-Variable Value
                STA   (FNCNAM),Y      ;Restore Old-Variable Value
                PLA                   ;Pull Old-Variable Value
                INY                   ;Advance Indirect Addressing Index (=1)
                STA   (FNCNAM),Y      ;Restore Old-Variable Value
                PLA                   ;Pull Old-Variable Value
                INY                   ;Advance Indirect Addressing Index (=2)
                STA   (FNCNAM),Y      ;Restore Old-Variable Value
                PLA                   ;Pull Old-Variable Value
                INY                   ;Advance Indirect Addressing Index (=3)
                STA   (FNCNAM),Y      ;Restore Old-Variable Value
                PLA                   ;Pull Old-Variable Value
                INY                   ;Advance Indirect Addressing Index (=4)
                STA   (FNCNAM),Y      ;Restore Old-Variable Value
                RTS                   ;Return to Caller

; ==============================================================================
; "STR$" String Function: Immediate & Deferred; Parameter: STR$(aexpr)
; ==============================================================================
; Converts a Number (aexpr) into a String representing its Value.
; The Number is evaluated before it is converted into a String.
; If the Number exceeds the limit for Reals, an Overflow Error occurs.
; ==============================================================================
; 
STR             JSR   CHKNUM          ;Assure (FAC) Type is Numeric (VALTYP=$00)
                LDY   #>FOUTBUFF      ;Starts String at STACK-1 ($00FF)
                JSR   FOUT1           ;Convert FAC to Z-String in FOUT-Buffer
; <<< How do we know there wasn't a collision with the Top of the Stack? >>>
                PLA                   ;Pull/Discard Return Address, Low
                PLA                   ;Pull/Discard Return Address, High
                LDA   #FOUTBUFF       ;Point to STACK-1, Low
                LDY   #>FOUTBUFF      ;Point to STACK-1, High {Zero-Page}
                BEQ   STRLTRL         ;Make FOUT-Buffer into a Literal "String"

; ==============================================================================
; Initialize String Space & Set String Descriptors for a Character String:
; ==============================================================================
STRINI          LDX   TMPVPTR         ;Get Temp Variable Pointer, Low     (FAC+3)
                LDY   TMPVPTR+1       ;Get Temp Variable Pointer, High    (FAC+4)
                STX   DSCPTR          ;Set String Descriptor Pointer, Low
                STY   DSCPTR+1        ;Set String Descriptor Pointer, High
; ==============================================================================
; Make String Space & Set the Temporary Descriptor for a Character String:
; ==============================================================================
STRSPC          JSR   GETSPACE        ;Get Space for the Character String
                STX   DSCTMPL         ;Set Temp Descriptor, Str Ptr, Low  (FAC+1)
                STY   DSCTMPH         ;Set Temp Descriptor, Str Ptr, High (FAC+2)
                STA   DSCTMP          ;Set Temp Descriptor, String Length (FAC+0)
                RTS                   ;Retun to Caller

; ==============================================================================
; String Literal #1: Make String {AY/INPUT/STACK} Buffer into a Literal "String"
; ==============================================================================
; Build a Descriptor for String starting at [(A,Y)={Low,High}] terminated only
; by a Zero or a Quotation Mark [built ins].  Return with a Temporary Descriptor
; and its Address in DSCTMP (FAC+0,1,2) and TMPVPTR (FAC+3,4), respectively; and
; Flag as String Variable (VALTYP = $FF).
; ==============================================================================
; Setup Literal Scan Delimiters to Stop STRLTRL2 only on a Zero or a Quote Mark:
; ------------------------------------------------------------------------------
STRLTRL         LDX   #'"'            ;Get a Quotation Mark/Character
                STX   CHARAC          ;Store Quote so STRLTRL2 will stop on it
                STX   ENDCHR          ;Store Quote so STRLTRL2 will stop on it
; ==============================================================================
; String Literal #2: Make String {AY/INPUT/STACK} Buffer into a Literal "String"
; ==============================================================================
; Build Descriptor for String starting at [(A,Y)={Low,High}] terminated by Zero
; or Quote Mark [built ins], & CHARAC or ENDCHR [caller/user must-be presets]. 
; Return with a Temp Descriptor and its Address in DSCTMP (FAC+0,1,2) and
; TMPVPTR (FAC+3,4), respectively; and Flag as String Variable (VALTYP = $FF).
; ==============================================================================
STRLTRL2        STA   STRNG1          ;Set Start of String: TmpStrPtr#1, Low
                STY   STRNG1+1        ;Set Start of String: TmpStrPtr#1, High
                STA   DSCTMPL         ;Set Temp Descriptor, String Pointer, Low
                STY   DSCTMPH         ;Set Temp Descriptor, String Pointer, High
; ----------------------------------- ;Find End of String:
                LDY   #$FF            ;Preset Indirect Addressing Index
STRFNDEND       INY                   ;Advance Indirect Addressing Index 
                LDA   (STRNG1),Y      ;Get Next String Character
                BEQ   STRZNDFND       ;Branch if [Z=1] End of Zero-String Found
                CMP   CHARAC          ;Else [Z=0]: Is it Alternate Terminator #1?
                BEQ   STRENDFND       ;Branch if [Z=1] End of String Found
                CMP   ENDCHR          ;Else [Z=0]: Is it Alternate Terminator #2?
                BNE   STRFNDEND       ;Loop if [Z=0] End of String NOT Found
; ----------------------------------- ;Else [Z=1]: End of String Found
STRENDFND       CMP   #'"'            ;Is it a Quotation Mark?
                BEQ   STRQNDFND       ;Branch if [Z=1] Quote Found [C=1]
;                                     ;Else [Z=0]: Quote NOT Found [C=(A>='"')]
; ----------------------------------- ;Calculate End of String Address:
STRZNDFND       CLC                   ;Prepare to Add with NO Carry (No Quote!)
;                                     ;Else [C=1]: Includes '"' in Str (Length)
STRQNDFND       STY   DSCTMP          ;Set Temp Descriptor, String Length
                TYA                   ;Get Temp Descriptor, String Length
                ADC   STRNG1          ;Add Start of String: TmpStrPtr#1, Low
                STA   STRNG2          ;Set End of String: TmpStrPtr#2, Low
                LDX   STRNG1+1        ;Get Start of String: TmpStrPtr#1, High
                BCC   STRLTRLNC       ;If NO Carry, Skip incrementing High Byte:
                INX                   ;Inc Start of String: TmpStrPtr#1, High
STRLTRLNC       STX   STRNG2+1        ;Set End of String: TmpStrPtr#2, High
; ------------------------------------------------------------------------------
; Where does the String start?  The String must be moved if it starts at the End
; of Page 0 ($FF), or if it is in the Input Buffer (Page 2):
; ------------------------------------------------------------------------------
                LDA   STRNG1+1        ;Get Start of String: TmpStrPtr#1, High
                BEQ   STRLTRLZP       ;Page 0!  (Must be from STR$ Function)
                CMP   #>INBUFF        ;Is it in the Input Buffer (Page 2)?
                BNE   PUTNEW          ;NO, Not Page 0 or 2; So just do Descriptor
; ----------------------------------- ;YES, Page 0 or 2:
STRLTRLZP       TYA                   ;Get Temp Descriptor, String Length
                JSR   STRINI          ;Make Space for the String
                LDX   STRNG1          ;Get Start of String: TmpStrPtr#1, Low
                LDY   STRNG1+1        ;Get Start of String: TmpStrPtr#1, High
                JSR   MOVSTR          ;Move the Character String
; ------------------------------------------------------------------------------
; Assure Temporary "String Descriptors" Stack is not full:
; ------------------------------------------------------------------------------
;                                     ;When Stack is Full: [(TEMPPT|X)=#INDEX]!
PUTNEW          LDX   TEMPPT          ;Get SD Stack: Next Temp Descriptor Pointer
;                                     ;Str Descriptor Stack ($55~$5D)=(9 bytes)
;                                     ; Holds up to 3 Descriptors (3 bytes each)
                CPX   #INDEX          ;Is Stack Full: Too many Temp Descriptors?
                BNE   PUTEMP          ;NO; There is room for another one
; ------------------------------------------------------------------------------
; <<< BUG if ever [(TEMPPT|X) > #INDEX]!  BCC|BLT would be better here; followed
; by CPX #TEMPST & BCS|BGE PUTTEMP to assure (TEMPPT|X) is within the stack. >>>
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;User-Callable Error Entry Point:
FRM2CPXERR      LDX   #ERR_FRMCPX     ;YES; Throw a "?Formula Too Complex" Error:
JERR            JMP   ERROR           ;Go Print Error Message based on X-Reg

; ------------------------------------------------------------------------------
; Copy Temp Descriptor [in DSCTMP (FAC+0,1,2)] into the Temp Descriptor Stack. 
; Put its ZP-Address there into the Temp Variable Pointer [TMPVPTR (FAC+3,4)].
; ------------------------------------------------------------------------------
PUTEMP          LDA   DSCTMP          ;Get Temp Descriptor, String Length
                STA   LOC0,X          ;Set SD Stack: Tmp Descriptor, StrLen
                LDA   DSCTMPL         ;Get Temp Descriptor, String Address, Low
                STA   LOC0+1,X        ;Set SD Stack: Tmp Descriptor, StrAdr, Low
                LDA   DSCTMPH         ;Get Temp Descriptor, String Address, High
                STA   LOC0+2,X        ;Set SD Stack: Tmp Descriptor, StrAdr, High
                LDY   #$00            ;Get Zero to Clear:
                STX   TMPVPTR         ;Set Temp Variable Pointer, Low     (FAC+3)
                STY   TMPVPTR+1       ;Set Temp Variable Pointer, High    (FAC+4)
                DEY                   ;Get String Variable Type ($FF)
                STY   VALTYP          ;Flag as String: Set Variable Type to ($FF)
                STX   LASTPT          ;Set SD Stack: Last Temp Descriptor Pointer
                INX
                INX                   ;Add 3 bytes (per Descriptor) to it
                INX
                STX   TEMPPT          ;Set SD Stack: Next Temp Descriptor Pointer
;                                     ;When Stack's Full: [(TEMPPT|X)=#INDEX]!
                RTS                   ;Return to Caller

; ==============================================================================
; Get/Make Space for a Character String at the Bottom of String Storage:
; ==============================================================================
; Enter with: A-Reg Set to String Length (Number of Bytes) Desired/Needed
; Return with: [(X,Y)={Low,High}] Set to the Address of the New Space Allocated
;              (A-Reg remains unchanged)
; ==============================================================================
; 
GETSPACE        LSR   GARFLG          ;Enable Garbage Collection
;                                     ;^(Clears Sign Bit of Flag)
GETSPC          PHA                   ;Save String Length (Bytes) Desired/Needed
; ----------------------------------- ;Compute New Bottom/Start of String Space)
;                                     ;^(AKA: Free Space End|Top of Free Space)
;                                     ;[Actuly Subtracts: (FRETOP)-(NewStrLen)]:
                EOR   #%11111111      ;Invert Bits
                SEC                   ;Prepare for Add with Carry Set (Adds 1)
                ADC   FRETOP          ;Add Top of Free Space, Low
                LDY   FRETOP+1        ;Get Top of Free Space, High
                BCS   GETSPC2         ;BGE: Branch if in Same Page of Memory
                DEY                   ;Else, Reduce Page Address, too
; ----------------------------------- ;Does it Fit in Remaining Memory?:
GETSPC2         CPY   STREND+1        ;CMP to End of Vars & Ptrs Storage, High
                BCC   MEMFULL         ;NO: Try Garbage Collection to Free Memory
                BNE   GOTSPACE        ;YES: It Fits in Memory Remaining
                CMP   STREND          ;CMP to End of Vars & Ptrs Storage, Low
                BCC   MEMFULL         ;NO: Try Garbage Collection to Free Memory
;                                     ;YES: It Fits in Memory Remaining
; ----------------------------------- ;Save New Top of Free Space:
;                                     ;^(AKA: Bottom or Start of String Space)
GOTSPACE        STA   FRETOP          ;Set Top of Free Space, Low
                STY   FRETOP+1        ;Set Top of Free Space, High
                STA   FRESPC          ;Set Temporary String Pointer, Low
                STY   FRESPC+1        ;Set Temporary String Pointer, High
                TAX                   ;Save Top of Free Space, Low
; ----------------------------------- ;Now: (FRETOP)=(FRESPC)=[(X,Y)={Low,High}]
                PLA                   ;Pull String Length Aquired [into (A)], too
                RTS                   ;Return to Caller (w/ all these things set)

; ----------------------------------- ;Error Entry Point; NOT so User-Callable:
MEMFULL         LDX   #ERR_MEMFULL    ;Get "?Out Of Memory" Error Message Index
                LDA   GARFLG          ;Get Garbage Collection Flag; Done Yet?
                BMI   JERR            ;YES: Print Error Message based on X-Reg
                JSR   GARBAGE         ;NO: Maximize Free-Space, Collect Garbage
                LDA   #$80            ;Flag Garbage Collection Done
                STA   GARFLG          ;Set Garbage Collection Flag
                PLA                   ;Pull String Length (Bytes) Desired/Needed
                BNE   GETSPC          ;Branch if String Space still Needed
; ------------------------------------------------------------------------------
; Maximize Free-Space, Collect Garbage from Top to Bottom:
; ------------------------------------------------------------------------------
; Shove all Referenced Strings as high as possible in memory (against HIMEM),
; freeing up space below String-Area down to Top End of Variables & Pointers
; Storage (STREND).
; ------------------------------------------------------------------------------
;     [(String-Area)=(HIMEM)-(FRETOP)]  &  [(Free-Space)=(FRETOP)-(STREND)]
; ------------------------------------------------------------------------------
GARBAGE         LDX   MEMSIZ          ;Get End of String Space (HIMEM) Ptr, Low
                LDA   MEMSIZ+1        ;Get End of String Space (HIMEM) Ptr, High
; ----------------------------------- ;Find Highest String:
;                                     ;1 Pass thru All Vars for each Active Str
FNDVAR          STX   FRETOP          ;Set Top of Free Space, Low
                STA   FRETOP+1        ;Set Top of Free Space, High
;                                     ;^(AKA: Bottom or Start of String Space)
;                                     ;That Resets String-Storage (FRETOP=HIMEM)
                LDY   #0              ;Clear Y-Index Register
                STY   FNCNAM+1        ;Clear Address of Descriptor, High
;                                     ;^(Flag: "Still have Strings to Collect")
; ----------------------------------- ;Point to Bottom of Free Space:
                LDA   STREND          ;Get End of Array Vars & Ptrs Storage, Low
                LDX   STREND+1        ;Get End of Array Vars & Ptrs Storage, High
                STA   LOWTR           ;Set as Bottom of Free Space, Low
                STX   LOWTR+1         ;Set as Bottom of Free Space, High
; ----------------------------------- ;Start by Collecting Temp Descriptors:
                LDA   #TEMPST         ;Get Address of Next Temp Dscrptr Ptr, Low
                LDX   #>TEMPST        ;Get Address of Next Temp Dscrptr Ptr, High
                STA   INDEX           ;Set String Variable Index Pointer, Low
                STX   INDEX+1         ;Set String Variable Index Pointer, High
TVAR            CMP   TEMPPT          ;Done Collecting Temporary Descriptors?
                BEQ   SVARS           ;YES: Go Do Simple Variables; EXIT LOOP
                JSR   CHKVAR          ;NO: Check Temporary String Descriptor
                BEQ   TVAR            ;Loop-Back; Always Taken
; ----------------------------------- ;Now Collect Simple Variables:
SVARS           LDA   #7              ;Get Standard Length of Simple Variables
                STA   DSCLEN          ;Set String Descriptor Length
; ----------------------------------- ;Start at beginning of Variable Table:
                LDA   VARTAB          ;Get Start of Variables Pointer, Low
                LDX   VARTAB+1        ;Get Start of Variables Pointer, High
                STA   INDEX           ;Set String Variable Index Pointer, Low
                STX   INDEX+1         ;Set String Variable Index Pointer, High
; ----------------------------------- ;Done Collecting Simple Variables?
SVAR            CPX   ARYTAB+1        ;Reached Start of Arrays Pointer, High?
                BNE   SVARGO          ;NO: Continue ...
                CMP   ARYTAB          ;Reached Start of Arrays Pointer, Low
                BEQ   ARYVAR          ;YES: Go Collect Array Variables; EXIT LOOP
SVARGO          JSR   CHKSMPLVAR      ;NO: Check Simple Variable
                BEQ   SVAR            ;Loop-Back; Always Taken
; ----------------------------------- ;Collect Array Variables:
ARYVAR          STA   HIGHDS          ;Set as Now Variable Pointer, Low
                STX   HIGHDS+1        ;Set as Now Variable Pointer, High
                LDA   #3              ;Get Standard Length of String Descriptors
                STA   DSCLEN          ;Set String Descriptor Length
; ----------------------------------- ;Scan Array Variables LOOP:
;                                     ;CMP [(A,X)={Low,High}] to End of Arrays:
ARYVAR2         LDA   HIGHDS          ;Get Next Variable Pointer, Low
                LDX   HIGHDS+1        ;Get Next Variable Pointer, High
; ----------------------------------- ;Done Collecting Array Variables?
ARYVAR3         CPX   STREND+1        ;Reached End of Vars & Ptrs Storage High?
                BNE   ARYVARGO        ;NO: Continue ...
                CMP   STREND          ;Reached End of Vars & Ptrs Storage, Low?
                BNE   ARYVARGO        ;NO: Continue ...
;                                     ;YES: Done Collecting Array Variables;
                JMP   GRBGPASS        ;Go Move Highest String to Top; EXIT LOOP

; ----------------------------------- ;Setup Pointer to Start of Array:
ARYVARGO        STA   INDEX           ;Set Array Variable Index Pointer, Low
                STX   INDEX+1         ;Set Array Variable Index Pointer, High
                LDY   #0              ;Point at 1st Character of Array Name
                LDA   (INDEX),Y       ;Get 1st Character of Array Name
                TAX                   ;Save 1st Character of Array Name
                INY                   ;Point at 2nd Character of Array Name
                LDA   (INDEX),Y       ;Get 2nd Character of Array Name
;                                     ;Now (X,A)=(Array Name)
; ----------------------------------- ;Prepare for Variable Type Check:
                PHP                   ;Push Status of 2nd Array Name Character
;                                     ;^[(N) {2nd Char})=($:+-;%:--;Real:++)]
; ----------------------------------- ;Advance Pointer to Next Variable:
                INY                   ;Point at Offset to Next Array, Low
                LDA   (INDEX),Y       ;Get Offset to Next Array, Low
; ----------------------------------- ;Calculate Start of Next Array:
;                                     ;(Here, Carry's always Clear, for Add w/C)
                ADC   HIGHDS          ;Add Now Variable Pointer, Low
                STA   HIGHDS          ;Set as Next Variable Pointer, Low
                INY                   ;Point at Offset to Next Array, High
                LDA   (INDEX),Y       ;Get Offset to Next Array, High
                ADC   HIGHDS+1        ;Add Now Variable Pointer, High
                STA   HIGHDS+1        ;Set as Next Variable Pointer, High
; ----------------------------------- ;Assure Array is a String Array:
                PLP                   ;Pull Status of 2nd Array Name Character
;                                     ;^[(N) {2nd Char})=($:+-;%:--;Real:++)]
                BPL   ARYVAR2         ;Loop-Back if Real/FP Array (VarName)^
                TXA                   ;Retrieve 1st Character of Array Name
                BMI   ARYVAR2         ;Loop-Back if Integer Array (VarName)^
; ----------------------------------- ;Array is a String Array:
                INY                   ;Point at Number of Array Dimensions
                LDA   (INDEX),Y       ;Get Number of Array Dimensions
                LDY   #0              ;Clear Indirect Addressing Index
                ASL   A               ;Double Number of Array Dimensions
                ADC   #5              ;& Add Five; Result: (A)=(2*Dims+5)
;                                     ;Now (A)=(Size of this Array Variable)
; ----------------------------------- ;Point at 1st Array Element:
                ADC   INDEX           ;Add Array Variable Index Pointer, Low
                STA   INDEX           ;Set Array Variable Index Pointer, Low
                BCC   AVGSKPADV       ;Skip Page Advance if Carry Clear
                INC   INDEX+1         ;Else, Carry Set, Advance Page Address
; ----------------------------------- ;Step through each Element in Str Array:
AVGSKPADV       LDX   INDEX+1         ;Get Array Variable Index Pointer, High
ARYSTR          CPX   HIGHDS+1        ;Has Pointer Reached Next Variable, High?
                BNE   GOGO            ;NO: Process Next Element
                CMP   HIGHDS          ;Has Pointer Reached Next Variable, Low?
                BEQ   ARYVAR3         ;YES, Loop-Back: Do Next Array Variable
GOGO            JSR   CHKVAR          ;NO: Continue Processing Array
                BEQ   ARYSTR          ;Loop-Back: Do Next Element; Always Taken
; 
; ==============================================================================
; Check Simple Variable: Assure Variable is a String
; ==============================================================================
; Upon Entry here: (Y)=(0) Always, (INDEX)=(String Variable Index Pointer);
;   & from SVARGO: (INDEX),Y Points at Variable's Name
; ------------------------------------------------------------------------------
CHKSMPLVAR      LDA   (INDEX),Y       ;Get 1st Character of Variable Name
                BMI   CHKBUMP         ;Branch if Not a String Variable
;                                     ;^[It's Integer Var ($:+-;%:--;Real:++)]
                INY                   ;Point at 2nd Character of Variable Name
                LDA   (INDEX),Y       ;Get 2nd Character of Variable Name
                BPL   CHKBUMP         ;Branch if Not a String Variable
;                                     ;^[It's a Real/FP Var ($:+-;%:--;Real:++)]
; 
; ==============================================================================
; Check Variable: If String is Not Empty, Check if it is Highest
; ==============================================================================
                INY                   ;Point at String Length
; ------------------------------------------------------------------------------
; Upon Entry here: (Y)=(0) & (INDEX)=(String Variable Index Pointer);
;     & from TVAR: (INDEX),Y Points at Variable's Descriptor;
;     & from GOGO: (INDEX),Y Points at Variable's Current Element [Doesn't Jibe]
; ------------------------------------------------------------------------------
CHKVAR          LDA   (INDEX),Y       ;Get String Length
                BEQ   CHKBUMP         ;Skip it if it is a Null String
                INY                   ;Point at String Address, Low
                LDA   (INDEX),Y       ;Get String Address, Low
                TAX                   ;Save (for CPX) String Address, Low
                INY                   ;Point at String Address, High
                LDA   (INDEX),Y       ;Get String Address, High
;                                     ;(FRETOP AKA: Bottom/Start of String Spc)
                CMP   FRETOP+1        ;Reached Top of Free Space, High?
                BCC   CHKVAR1         ;NO, Below Top of Free Space, High
                BNE   CHKBUMP         ;YES, Above Top of Free Space, High
                CPX   FRETOP          ;Reached Top of Free Space, Low?
                BCS   CHKBUMP         ;YES, Above Top of Free Space, Low
;                                     ;^^^: Garbage Collected already, Skip it
; ----------------------------------- ;Above Highest String Found?
CHKVAR1         CMP   LOWTR+1         ;Reached Bottom of Free Space, High?
                BCC   CHKBUMP         ;NO, Ignore for Now, Skip it
                BNE   CHKVAR2         ;YES, This is the new Highest String
                CPX   LOWTR           ;Reached Bottom of Free Space, Low?
                BCC   CHKBUMP         ;NO, Ignore for Now, Skip it
; ----------------------------------- ;YES, Make it new Highest String:
CHKVAR2         STX   LOWTR           ;Save as Pointer to Highest String, Low
                STA   LOWTR+1         ;Save as Pointer to Highest String, High
; ----------------------------------- ;Save Address of Descriptor too:
                LDA   INDEX           ;Get Address of Descriptor, Low
                LDX   INDEX+1         ;Get Address of Descriptor, High
                STA   FNCNAM          ;Save as Address of Descriptor, Low
                STX   FNCNAM+1        ;Save as Address of Descriptor, High
;                                     ;^(Flag: "Still have Strings to Collect")
                LDA   DSCLEN          ;Get String Descriptor Length
                STA   GARLEN          ;Set as String Descriptor Length
;                                     ;^(Length for Garbage Collection)
; ----------------------------------- ;Advance to Next Variable:
CHKBUMP         LDA   DSCLEN          ;Get String Descriptor Length
                CLC                   ;Prepare for Add with Carry
                ADC   INDEX           ;Add Address of Descriptor, Low
                STA   INDEX           ;Set Address of Descriptor, Low
                BCC   CHKEXIT         ;Skip Advancing Page if No Carry Over
                INC   INDEX+1         ;Advance Address of Descriptor, High
CHKEXIT         LDX   INDEX+1         ;Return (INDEX)=[(A,X)={Low,High}]
                LDY   #0              ;Return (Y)=(0)
                RTS                   ;Return to Caller

; ==============================================================================
; Move Highest String to Top
; ==============================================================================
; 
GRBGPASS        LDX   FNCNAM+1        ;Retrieve Address of Descriptor, High
;                                     ;^(Flag: "Still have Strings to Collect")
                BEQ   CHKEXIT         ;Collection Ends if Flag is still Zero
; <<< ---------------------------------------------------------------------- >>>
; Any attemp to collect a temp string will abort collection.  This BUG is rarely
; a problem, but could be if collection is forced by a concatination and the
; string space just has room for the new string after collection.  For example:
; LOMEM:10000: HIMEM:10012: A$="A": A$=A$+"B": A$=A$+"C": PRINT A$ prints "ABA"
; [in immediate mode, but in deferred mode, prints "ABC", in AppleWin 1.29.3.0].
; <<< ====================================================================== >>>
; 
; ----------------------------------- ;Compute Y-Index to Point at String Length
;                                     ; & String Pointer, Variable Elements:
                LDA   GARLEN          ;Get String Descriptor Length
                AND   #%00000100      ;If it was 3 or 7, make it 0 or 4
;                                     ;^(4 is Simple Variable, else 0)
                LSR   A               ;Make it 0 or 2; Name precedes Descriptor
                TAY                   ;Point at String Length in Descriptor
;                                     ;^(2 is Simple Variable, else 0)
                STA   GARLEN          ;Save to Set Y-Index into Variable later
; ----------------------------------- ;String is between Bottom of Free Space
;                                     ;(LOWTR) & Top-End of Arrays (HIGHTR):
                LDA   (FNCNAM),Y      ;Get String Length from Descriptor
;                                     ;Carry was Cleared by LSR (for Add w/C)
                ADC   LOWTR           ;Add Bottom of Free Space, Low
                STA   HIGHTR          ;Set as new Top-End of Arrays, Low
                LDA   LOWTR+1         ;Get Bottom of Free Space, High
                ADC   #0              ;Add Carry to Bottom of Free Space, High
                STA   HIGHTR+1        ;Set as new Top-End of Arrays, High
; ----------------------------------- ;Set High End Destination:
                LDA   FRETOP          ;Get Top of Free Space, Low
                LDX   FRETOP+1        ;Get Top of Free Space, High
;                                     ;^(AKA: Bottom or Start of String Space)
                STA   HIGHDS          ;Save as Start of String Space, Low
                STX   HIGHDS+1        ;Save as Start of String Space, High
; ----------------------------------- ;Move String Up:
;                                     ;(HIGHDS) = Highest Destination Address +1
;                                     ; (LOWTR) = Lowest Source Address
;                                     ;(HIGHTR) = Highest Source Address +1
                JSR   MVBLKUP2        ;Move Memory Block Upward
; ----------------------------------- ;Fix String's Descriptor:
                LDY   GARLEN          ;Retrieve to Set Y-Index into Variable
                INY                   ;Point at Descriptor String Pointer, Low
;                                     ;Store New Address:
                LDA   HIGHDS          ;Get Start of String Space, Low
                STA   (FNCNAM),Y      ;Set Descriptor String Pointer, Low
                TAX                   ;Save Pointer to Moved String, Low
; ----------------------------------- ;Correct MVBLKUP2's Overshoot:
                INC   HIGHDS+1        ;Advance Start of String Space, High
                LDA   HIGHDS+1        ;Get Start of String Space, High
                INY                   ;Point at Descriptor String Pointer, High
                STA   (FNCNAM),Y      ;Set Descriptor String Pointer, High
;                                     ;[(X,A)={Low,High}] Points at Moved String
                JMP   FNDVAR          ;Find Next Variable to Collect

; ==============================================================================
; Concatenate Two Strings
; ==============================================================================
; 
; ----------------------------------- ;Save 1st String's Descriptor Address:
CAT             LDA   TMPVPTR+1       ;Get Temp Variable Pointer, High (FAC+4)
                PHA                   ;Push Address of 1st Descriptor, High
                LDA   TMPVPTR         ;Get Temp Variable Pointer, Low  (FAC+3)
                PHA                   ;Push Address of 1st Descriptor, Low
; ----------------------------------- ;Save 2nd String's Descriptor Address:
                JSR   GETVAL          ;Put Pointer to String Descriptor in FAC
                JSR   CHKSTR          ;Assure (FAC) Type is String (VALTYP=$FF)
; ----------------------------------- ;Retrieve 1st String's Descriptor Address:
                PLA                   ;Pull Address of 1st Descriptor, Low
                STA   STRNG1          ;Set Pointer to 1st String, Low
                PLA                   ;Pull Address of 1st Descriptor, High
                STA   STRNG1+1        ;Set Pointer to 1st String, High
; ----------------------------------- ;Get Concatenated Size, Add Lenghts: 
                LDY   #0              ;Clear Indirect Addressing Index
                LDA   (STRNG1),Y      ;Get Length of 1st String
                CLC                   ;Prepare for Add with Carry
                ADC   (TMPVPTR),Y     ;Add Length of 2nd String (FAC+3,4)
                BCC   CAT1            ;Branch if < $100; Total Length is OK
; ----------------------------------- ;User-Callable Error Entry Point:
STR2LGERR       LDX   #ERR_STRLONG    ;Throw a "?String Too Long" Error
                JMP   ERROR           ;Print Error based on X-Reg

; ------------------------------------------------------------------------------
; Concatenate the Two Strings 
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Get Space for Concatenated Strings
CAT1            JSR   STRINI          ;Initialize String Space & Descriptors
                JSR   MOVINS          ;Move in 1st String
; ----------------------------------- ;Free up 2nd String:
                LDA   DSCPTR          ;Get String Descriptor Pointer, Low
                LDY   DSCPTR+1        ;Get String Descriptor Pointer, High
                JSR   FRETMP          ;Free up a Temporary String
                JSR   MOVSTR1         ;Move in 2nd String
; ----------------------------------- ;Free up 1st String:
                LDA   STRNG1          ;Get String Descriptor Pointer, Low
                LDY   STRNG1+1        ;Get String Descriptor Pointer, High
                JSR   FRETMP          ;Free up a Temporary String
                JSR   PUTNEW          ;Setup Descriptor
                JMP   FRMEVL2         ;Finish Expression Evaluation

; ------------------------------------------------------------------------------
; Get String Descriptor at (STRNG1) & Move Described String to (FRESPC)
; ------------------------------------------------------------------------------
; 
MOVINS          LDY   #0              ;Point at String Length
                LDA   (STRNG1),Y      ;Get String Length (* from its Descriptor)
                PHA                   ;Push String Length
                INY                   ;Point at String Pointer, Low
                LDA   (STRNG1),Y      ;Get String Pointer, Low (*)
                TAX                   ;Save String Pointer, Low
                INY                   ;Point at String Pointer, High
                LDA   (STRNG1),Y      ;Get String Pointer, High (*)
                TAY                   ;Save String Pointer, High
                PLA                   ;Pull String Length
; 
; ------------------------------------------------------------------------------
; Move String at [(X,Y)={Low,High}] w/ Length in (A) to Destination at (FRESPC)
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Put Pointer in INDEX:
MOVSTR          STX   INDEX           ;Save String Pointer, Low
                STY   INDEX+1         ;Save String Pointer, High
; ----------------------------------- ;Move String (2nd Entry Point):
MOVSTR1         TAY                   ;Save String Length as Count Down Index
                BEQ   MOVSTR2         ;Done if Count Down Index is Zero
                PHA                   ;Push String Length
; ----------------------------------- ;Move String (Loop):
MOVESTR         DEY                   ;Reduce String Length Count Down Index
                LDA   (INDEX),Y       ;Get Old String Character Byte
                STA   (FRESPC),Y      ;Set New String Character Byte
;                                     ;Test if any more Bytes to Move:
                TYA                   ;Get String Length Count Down Index
                BNE   MOVESTR         ;Loop-Back if Not Done
; ----------------------------------- ;Get Length & Add to FRESPC [Point to Next
;                                     ; Higher Byte (for use by Concatenation)]:
                PLA                   ;Pull String Length
MOVSTR2         CLC                   ;Prepare for Add with Carry
                ADC   FRESPC          ;Add Temporary String Pointer, Low
                STA   FRESPC          ;Set Temporary String Pointer, Low
                BCC   MOVSTR3         ;Skip Advancing High Byte if NO Carryover
                INC   FRESPC+1        ;Add Carry & Set Temp String Pointer, High
MOVSTR3         RTS                   ;Return to Caller

; ==============================================================================
; Release Temporary String Descriptor (in FAC)
; ==============================================================================
; 
; =================================== ;[1st Entry Pt: from "LEN" Statement S/R]
; Release String Descriptor if String is a Temporary String & is Lowest in RAM:
; ----------------------------------- ;Assure (FAC) Points to a Str Descriptor:
FRESTR          JSR   CHKSTR          ;Assure (FAC) Type is String (VALTYP=$FF)
; =================================== ;[2nd Entry Pt: from STRPRT|STRCMP|FRE]
; Free up String Descriptor [(TMPVPTR)=(FAC+3,4)] & a Temp String if Lowest:
; ----------------------------------- ;Get String Descriptor Pointer:
FREFAC          LDA   TMPVPTR         ;Get Temp Variable Pointer, Low (FAC+3)
                LDY   TMPVPTR+1       ;Get Temp Variable Pointer, High (FAC+4)
; ================================= ;[3rd Entry Pt: from STRCMP|CAT1|LEFTSTR]
; Free up a Temporary String if it is Lowest in RAM (Highest on String Stack):
; ----------------------------------- ;Put String Descriptor Pointer in INDEX:
FRETMP          STA   INDEX           ;Save Pointer to String Descriptor, Low
                STY   INDEX+1         ;Save Pointer to String Descriptor, High
                JSR   FRETMS          ;Free Temp Descriptor w/o Freeing up String
                PHP                   ;Push Status: Remember if Temp (Z=1) or Not
; ----------------------------------- ;Get Descriptor Data:
                LDY   #0              ;Point at String Length in Descriptor
                LDA   (INDEX),Y       ;Get String Length
                PHA                   ;Push String Length
                INY                   ;Point at String Pointer, Low
                LDA   (INDEX),Y       ;Get String Pointer, Low
                TAX                   ;Save String Pointer, Low
                INY                   ;Point at String Pointer, High
                LDA   (INDEX),Y       ;Get String Pointer, High
                TAY                   ;Save String Pointer, High
                PLA                   ;Pull String Length
;                                     ;Now: String Length is in Accumulator (A)
;                                     ;& String Pointer is in [(X,Y)={Low,High}]
; ----------------------------------- ;Free up Space if String is Temp & Lowest:
                PLP                   ;Pull Status: Retrieve if Temp (Z=1) or Not
                BNE   FRETMP2         ;Branch if Not Temporary String (Z=0)
; ----------------------------------- ;Is it THE Lowest String?
;                                     ;Compare to Bottom/Start of String Space:
                CPY   FRETOP+1        ;Compare to Top of Free Space, High
                BNE   FRETMP2         ;NO: Branch if Not Lowest String
                CPX   FRETOP          ;Compare to Top of Free Space, Low
                BNE   FRETMP2         ;NO: Branch if Not Lowest String
;                                     ;YES, it is THE Lowest String
; ----------------------------------- ;Delete Lowest String (Move FRETOP Up):
                PHA                   ;Push String Length
                CLC                   ;Prepare for Add with Carry
                ADC   FRETOP          ;Add Top of Free Space, Low
                STA   FRETOP          ;Set Top of Free Space, Low
                BCC   FRETMP1         ;Skip Advancing High Byte if NO Carryover
                INC   FRETOP+1        ;Add Carry & Set Top of Free Space, High
FRETMP1         PLA                   ;Pull String Length
; ----------------------------------- ;Put String Pointer in INDEX:
FRETMP2         STX   INDEX           ;Set as Address of String, Low
                STY   INDEX+1         ;Set as Address of String, High
; ----------------------------------- ;Return String's New Descriptor Data:
;                                     ;String Length in Accumulator (A)
;                                     ;String Ptr in INDEX=[(X,Y)={Low,High}]
                RTS                   ;Return to Caller

; ==============================================================================
; Free Temp Descriptor w/o Freeing up String
; ==============================================================================
; 
; Release TD from SD Stack if [(A,Y)={Low,High}]=(LASTPT):
; 
FRETMS          CPY   LASTPT+1        ;Compare to SD Stack: Last TD Pointer, High
                BNE   FRETMS1         ;Cannot Release if NOT Same One
                CMP   LASTPT          ;Compare to SD Stack: Last TD Pointer, Low
                BNE   FRETMS1         ;Cannot Release if NOT Same One
                STA   TEMPPT          ;Set SD Stack: Next TD Pointer
                SBC   #3              ;Reduce SD Stack: Last TD Pointer, Low
                STA   LASTPT          ;Set SD Stack: Last TD Pointer, Low
                LDY   #0              ;Set SD Stack: Last TD Pointer, High
FRETMS1         RTS                   ;Return to Caller

; ==============================================================================
; ** Unary String Operator Functions (CHR$, LEFT$, RIGHT$, & MID$) Start Here **
; ==============================================================================
; 
; 
; ==============================================================================
; "CHR$" Character String Function:
;      Immediate & Deferred; Parameters: CHR$ (Aexpr);
;      Returns ASCII Character of an Integer Number (from 0 to 255)
;      (Real Numbers are Converted to Integer Numbers)
; ==============================================================================
; 
CHRSTR          JSR   CONINT          ;Evaluate Formula at TXTPTR into (X) & FAC
                TXA                   ;Get Result; ^[Real]-->[Integer (0..255)]
                PHA                   ;Push Result
                LDA   #1              ;Get Space for a Single-Character String 
                JSR   STRSPC          ;Make String Space & Set Temp Descriptor
                PLA                   ;Pull Result
                LDY   #0              ;Clear Indirect Addressing Index
                STA   (DSCTMPL),Y     ;Set Temp Descriptor, Str Adrs, Low (FAC+1)
; ----------------------------------- ;Pop/Discard Return Address:
;                                     ;(NO Return to UNARY2 for CHR$)
                PLA                   ;Pull/Discard UNARY2 Return Address, Low
                PLA                   ;Pull/Discard UNARY2 Return Address, High
                JMP   PUTNEW          ;Make it a Temporary String

; ==============================================================================
; "LEFT$" Left String Function:
; ==============================================================================
; Immediate & Deferred; Parameters: LEFT$ (Sexpr, Aexpr);
; Returns first (Numeric Expression) Characters of (String Expression)
; (Real Numbers are Converted to Integer Numbers)
; ==============================================================================
; 
LEFTSTR         JSR   INSTRING        ;Do Common Setup for LEFT$|RIGHT$|MID$
;                        Returns -->  ;(Y=0) & (A=X)=(2nd Parmeter of Function)=
;                                     ; [Specified Length of Substring (Aexpr)]=
                CMP   (DSCPTR),Y      ;[(2nd Parameter)<(Original Length)]?
                TYA                   ;Clear (A)=[(Y=0): Start Point in String]
; 
; ==============================================================================
; Routine End Code for LEFT$, RIGHT$, & MID$ Functions
; ==============================================================================
; 
; ----------------------------------- ;Drop-Down Entry-Pt from LEFT$ Function &
;                                     ;Jump-Back Entry-Pt from RIGHT$ Function:
;                                     ;Now: (A)=[Starting Point in String]
RGHTSTR         BCC   INSTR           ;BLT: 2nd Parameter is Smaller, Use It
                LDA   (DSCPTR),Y      ;Else, Original Length is Smaller, Use It
                TAX                   ;Save Original String Length
                TYA                   ;Clear (A)=[(Y=0): Start Point in String]
INSTR           PHA                   ;Push Starting Point in Original String 
; ----------------------------------- ;2 Branch-Bak Entry-Pts frm MID$ Function:
;                                     ;Entry Point for Offset > Original Length:
MIDSTR2         TXA                   ;Retrieve Length (or Width) of Substring
;                                     ;Entry Point for using Smallest Length:
MIDSTR3         PHA                   ;Push Length (or Width) of Substring
                JSR   STRSPC          ;Make String Space & Set Temp Descriptor
                LDA   DSCPTR          ;Get String Descriptor Pointer, Low
                LDY   DSCPTR+1        ;Get String Descriptor Pointer, High
                JSR   FRETMP          ;Release Parameter String if Temporary
                PLA                   ;Pull Length (Width) of Substring
                TAY                   ;Save Length (Width) of Substring
;              ---------------------- ;Add Offset to Move Strings INDEX Pointer:
                PLA                   ;Pull Starting Point in Original String,
;                                     ;for LEFT$ & RIGHT$ Functions, or Offset
;                                     ;[(Specified Start)-1] for MID$ Function
                CLC                   ;Prepare for Add with Carry
                ADC   INDEX           ;Add Move Strings Index Pointer
                STA   INDEX           ;Set Move Strings Index Pointer
                BCC   INSTRSKP        ;Skip Advancing High Byte if NO Carryover
                INC   INDEX+1         ;Add Carry to Move Strings Index Ptr, High
INSTRSKP        TYA                   ;Retrieve Length (Width) of Substring
                JSR   MOVSTR1         ;Move Substring to String Space
                JMP   PUTNEW          ;Go Make it a Temporary String

; ==============================================================================
; "RIGHT$" Right String Function:
; ==============================================================================
; Immediate & Deferred; Parameters: RIGHT$ (Sexpr, Aexpr);
; Returns last (Numeric Expression) Characters of (String Expression)
; (Real Numbers are Converted to Integer Numbers)
; ==============================================================================
; 
RIGHTSTR        JSR   INSTRING        ;Do Common Setup for LEFT$|RIGHT$|MID$
;                        Returns -->  ;(Y=0) & (A=X)=(2nd Parmeter of Function)=
;                                     ; [Specified Length of Substring (Aexpr)]=
; ----------------------------------- ;Compute (Length)-(Width of SubString)
;                                     ;to get Starting Point in String:
                CLC                   ;Prepare to Subtract w/ Borrow [A-Data-!C]
                SBC   (DSCPTR),Y      ;Subtract Original String Length [A-Len-1]
                EOR   #%11111111      ;Invert Bits [Negate(A-Len-1)=(Len+1-A)]
;                                     ;      [(Length of Remainder)=(Len+1-A)]
;                                     ; [(Starting Point in String)=(Len+1-A)]
                JMP   RGHTSTR         ;Goto End Code for RIGHT$

; ==============================================================================
; "MID$" Middle String Function:
; ==============================================================================
; Immediate & Deferred; Parameters: MID$ (Sexpr, Aexpr1 [, Aexpr2]);
; Returns (Numeric Expression 2) Middle Characters of (String Expression)
; from the (Numeric Expression 1) Character to the Right
; (Real Numbers are Converted to Integer Numbers)
; ==============================================================================
; 
MIDSTR          LDA   #$FF            ;Setup Large Fake Length for 3rd Parameter
                STA   FAC+4           ;Set FAC Mantissa, Low
                JSR   CHRGOT          ;Get Last Char/Token Got
                CMP   #')'            ;Was it a Closing Parenthsis [")"]?
                BEQ   MIDSTR1         ;YES, Then there is No 3rd Parameter
                JSR   CHKCOM          ;NO, Then a Comma is Required
;                                     ;(between 2nd & 3rd Parameters)
                JSR   GETBYT          ;Evaluate 3rd Parameter into FAC+4
;                                     ;^[Specified Length of Substring (Aexpr2)]
MIDSTR1         JSR   INSTRING        ;Do Common Setup for LEFT$|RIGHT$|MID$
;                        Returns -->  ;(Y=0) & (A=X)=(2nd Parmeter of Function)=
;                                     ; [Specified Start of Substring (Aexpr1)]=
                DEX                   ;Reduce 2nd Parameter [(Specified Start)-1]
                TXA                   ;Get it as Specified Offset  [^]
                PHA                   ;Push it as Specified Offset [^]
; ----------------------------------- ;Compute (Length)-[(Specified Start)-1]
;                                     ;to get Length of Remainder of String:
                CLC                   ;Prepare to Subtract w/ Borrow [A-Data-!C]
                LDX   #0              ;Clear X-Reg (before Branch-Backs occur)
                SBC   (DSCPTR),Y      ;Subtract Original String Length [A-Len-1]
                BCS   MIDSTR2         ;BGE: Branch if Offset > Original Length
;                                     ;Exit: Goto End Code for MID$
;                                     ;Else: Use Smaller of Two Lengths:
                EOR   #%11111111      ;Invert Bits [Negate(A-Len-1)=(Len+1-A)]
;                                     ;      [(Length of Remainder)=(Len+1-A)]
                CMP   FAC+4           ;[(Remainder Length)<(Specified Length)]?
                BCC   MIDSTR3         ;BLT: Goto End Code for MID$ if So
                LDA   FAC+4           ;Retrieve 2nd Parameter, Specified (Aexpr1)
                BCS   MIDSTR3         ;Goto End Code for MID$; Always Taken

; ==============================================================================
; Common Setup Routine for LEFT$, RIGHT$, & MID$ Functions:
; ==============================================================================
; 
INSTRING        JSR   CHKCLS          ;Require Closing Parenthsis [")"] at TXTPTR
; ----------------------------------- ;Save Return Address [in (Y,GARLEN)]:
                PLA                   ;Pull Return Address, Low
                TAY                   ;Save Return Address, Low
                PLA                   ;Pull Return Address, High
                STA   GARLEN          ;Save Return Address, High
; ----------------------------------- ;Pop/Discard previous Return Address:
;                                     ;(NO Rtn to UNARY2 for LEFT$|RIGHT$|MID$)
                PLA                   ;Pull/Discard UNARY2 Return Address, Low
                PLA                   ;Pull/Discard UNARY2 Return Address, High
; ----------------------------------- ;Retrieve 2nd Parameter of Command:
;                                     ;^[Pushed at $DF36 in UNARY Op's Routine]
;                                     ;^[2ndParm is Specified [Aexpr(1)]: Length
;                                     ;of Substring for LEFT$ & RIGHT$ Functions
;                                     ;& Start of Substring for MID$ Function]
                PLA                   ;Pull 2nd Parameter of Command
                TAX                   ;Save 2nd Parameter of Command
; ----------------------------------- ;Restore String Descriptor Pointer:
;                                     ;^[Pushed at $DF2A,2D in UNARY Op's S/R]
;                                     ;^[String Descriptor Adrs (from TMPVPTR)]
;                                     ;^[Usually Pts at FAC for TmpStrDsc (3B)]
                PLA                   ;Get String Descriptor Address, Low
;                                     ;^[This was from (FAC+3) TMPVPTR, Low]
                STA   DSCPTR          ;Set String Descriptor Pointer, Low
                PLA                   ;Get String Descriptor Address, High
;                                     ;^[This was from (FAC+4) TMPVPTR, High]
                STA   DSCPTR+1        ;Set String Descriptor Pointer, High
; ----------------------------------- ;Restore Return Address [from (Y,GARLEN)]:
                LDA   GARLEN          ;Get Return Address, High
                PHA                   ;Push Return Address, High
                TYA                   ;Get Return Address, Low
                PHA                   ;Push Return Address, Low
; ----------------------------------- ;Setup for Return to Caller:
                LDY   #0              ;Clear Indirect Addressing Index
                TXA                   ;Retrieve 2nd Parameter of Command
                BEQ   GOIQ            ;If Zero, Throw "?Illegal Quantity" Error 
                RTS                   ;Else, Return to Caller

; ==============================================================================
; "LEN" String Length Function: Imediate & Deferred; Parameter: LEN (Aexpr);
;       Returns the Number of Characters in a String
; ==============================================================================
; 
LEN             JSR   GETSTR          ;Get Length in Y-Reg, Make FAC Numeric
; ----------------------------------- ;Convert Y-Reg to Real/FP Number in FAC:
                JMP   SNGFLT          ;Float Unsigned Integer & Flag as a Number

; ------------------------------------------------------------------------------
; Get String Length (GETSTR): If Last Result is a Temporary String, Free It;
; Make Valtyp Numeric; & Return String Length In Y-Reg.
; ------------------------------------------------------------------------------
GETSTR          JSR   FRESTR          ;If Last Result is a Temp String, Free It
                LDX   #0              ;Clear X-Reg
                STX   VALTYP          ;Make Variable Type Numeric
                TAY                   ;Return Length In Y-Reg
                RTS                   ;Return to Caller

; ==============================================================================
; "ASC" ASCII Character Function
; ==============================================================================
; 
ASC             JSR   GETSTR          ;Put String Pointer in INDEX, Length in (A)
                BEQ   GOIQ            ;If Zero, Throw "?Illegal Quantity" Error 
                LDY   #0              ;Clear Indirect Addressing Index
                LDA   (INDEX),Y       ;Get 1st Character of String
                TAY                   ;Prepare to Float 1st Character of String
; ----------------------------------- ;Convert Y-Reg to Real/FP Number in FAC:
                JMP   SNGFLT          ;Float Unsigned Integer & Flag as a Number

; ==============================================================================
; Print "Illegal Quantity" Error Message
; ==============================================================================
; 
; ----------------------------------- ;Error Entry Point; Also User-Callable:
GOIQ            JMP   IQERR           ;Print "?Illegal Quantity" Error Message

; ==============================================================================
; Evaluate Formula at TXTPTR into FAC; 
; Then Convert FAC to a Single Byte, Integer (0-255), in X-Reg:
; ==============================================================================
; 
; Scan to Next Character, Evaluate Expression at TXTPTR, Assure its Numeric, 
; Put it in FAC, & Convert FAC to a Single Byte, Integer (0-255), in X-Reg:
; 
GTBYTC          JSR   CHRGET          ;Get Next Char/Token
; 
; Evaluate Expression at TXTPTR, Assure its Numeric, Put it in FAC, 
; & Convert FAC to a Single Byte, Integer (0-255), in X-Reg:
; 
GETBYT          JSR   FRMNUM          ;Eval & Assure: Put in FAC if it's a Number
; 
; Convert FAC to a Single-Byte, Integer (0-255), in X-Reg:
; 
CONINT          JSR   MKINT           ;Convert FAC to Integer in (FAC+3,4) & (X)
;                                     ;^[# Must be Positive & less than 32768]
                LDX   FAC+3           ;FAC Mantissa, Middle (FAC+3) must be Zero!
;                                     ;^[So, really, Number Must be 0-255 !]
                BNE   GOIQ            ;Print "?Illegal Quantity" Error Message
                LDX   FAC+4           ;Get FAC Mantissa, Low (FAC+4)
                JMP   CHRGOT          ;Get Last Char/Token Got

; ==============================================================================
; "VAL" Value Function: Immediate & Deferred; Parameter: VAL (Sexpr); Attempts
; to convert a String into a Number
; ==============================================================================
; 
VAL             JSR   GETSTR          ;Put String Pointer in INDEX, Length in (A)
                BNE   VALGO           ;Branch if [(A)=(String Length)]<>(0)
;                                     ;Else, Return [(A)=(String Length)]=(0):
                JMP   ZFACEXPSGN      ;Goto Zero FAC Signed Exponent & Sign

; ----------------------------------- ;Save CHRGET's TXTPTR Now:
VALGO           LDX   TXTPTR          ;Get Next Char/Token Pointer, Low
                LDY   TXTPTR+1        ;Get Next Char/Token Pointer, High
                STX   STRNG2          ;Set String Pointer #2, Low
                STY   STRNG2+1        ;Set String Pointer #2, High
; ----------------------------------- ;Point TXTPTR to Start of String, Low:
                LDX   INDEX           ;Get String Pointer, Low
                STX   TXTPTR          ;Set Next Char/Token Pointer, Low
;              ---------------------- ;Add Start of String, Low to Str Length:
                CLC                   ;Prepare for Add with Carry
                ADC   INDEX           ;Add String Pointer, Low
;              ---------------------- ;Point DSTPTR to End of String +1, Low:
                STA   DSTPTR          ;Set Move Strings Destination Pointer, Low
; ----------------------------------- ;Point TXTPTR to Start of String, High:
                LDX   INDEX+1         ;Get String Pointer, High
                STX   TXTPTR+1        ;Set Next Char/Token Pointer, High
;              ---------------------- ;Add Start of String, High to Str Length:
                BCC   VALSKP          ;Skip Advancing High Byte if NO Carryover
                INX                   ;Add String Pointer, High
;              ---------------------- ;Point DSTPTR to End of String +1, High:
VALSKP          STX   DSTPTR+1        ;Set Move Strings Destination Pointer, High
; ----------------------------------- ;Save Byte after Str & Replace with Zero:
                LDY   #0              ;Clear Indirect Addressing Index
                LDA   (DSTPTR),Y      ;Get Byte after String
                PHA                   ;Push Byte after String
                LDA   #0              ;Clear Accumulator
                STA   (DSTPTR),Y      ;Clear Byte after String
; ----------------------------------- ;No BUG here!  Strings start at HIMEM-1 &
;                                     ;build downward!  HIMEM=$BFFF IS the Byte
;                                     ;above the 1st String, NOT KBD=$C000!
; ----------------------------------- ;Setup 6502 Registers & Evaluate String:
                JSR   CHRGOT          ;Get Last Char/Token Got (Does the Setup)
                JSR   FIN             ;Evaluate String to FP Value in FAC
; ----------------------------------- ;Retrieve & Restore Byte after String:
                PLA                   ;Pull Byte after String
                LDY   #0              ;Clear Indirect Addressing Index
                STA   (DSTPTR),Y      ;Set Byte after String
; ----------------------------------- ;Retrieve & Restore CHRGET's TXTPTR Saved:
;                                     ;**(Copy STRNG2 into TXTPTR Subroutine)**
POINT           LDX   STRNG2          ;Get String Pointer #2, Low
                LDY   STRNG2+1        ;Get String Pointer #2, High
                STX   TXTPTR          ;Set Next Char/Token Pointer, Low
                STY   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Finished:
                RTS                   ;Return to Caller

; <<< BUG if KBD ? >>>                                                      
; ==============================================================================
; <<<  Another mistake(?) here in Billy-Boy's (Microsoft?/Applesoft!) BASIC  >>>
; ==============================================================================
; E730:          STA     (DSTPTR),Y ;Set Byte after String  <<< BUG if KBD >>>
; ------------------------------------------------------------------------------
; <<< That causes a BUG if HIMEM = $BFFF, because storing $00 at $C000 is no
; use; $C000 will always be last char typed, so FIN won't terminate until it
; sees a zero at $C010! >>>
; ------------------------------------------------------------------------------
; Raises the quesion: Can HIMEM ever actually be $BFFF?
; ==============================================================================
; That's all Nonsense!  Strings start at HIMEM-1 & build downward!
; HIMEM=$BFFF IS the Byte above the 1st String, NOT KBD=$C000!
; ==============================================================================
; 
; 
; ==============================================================================
; Evalute "EXP1,EXP2": Convert EXP1 to 16-bit Number in LINNUM;
;                      Convert EXP2 to  8-bit Number in X-Index Register
; ==============================================================================
; 
GTNUM           JSR   FRMNUM          ;Eval Syntax & Assure Expression is Numeric
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
; 
; ==============================================================================
; Evalute ",Expression": Convert Expression to Single Byte in X-Index Register
; ==============================================================================
; 
COMBYTE         JSR   CHKCOM          ;Require a (Data Separator) Comma 1st
                JMP   GETBYT          ;Convert Expression to a Byte in X-Reg

; ==============================================================================
; Convert FAC to a 16-bit Value in LINNUM
; ==============================================================================
; 
GETADR          LDA   FAC             ;Get FAC Exponent
                CMP   #$91            ;[(FACX)<=($FFFF)<(2^16)]?
;                     ^^^^^---------- ;Get Exponent to 2^16=65,536=%0001,0000
;                                     ;Add 1 for Branch Greater Than or Equal To
;                                     ;FAC FP#, So Set High Bit: $91=%1001,0001
;                                     ;(Shifts Decimal Pt 16-bits to the Right)
; ----------------------------------- ;Error if Not Less Than:
                BCS   GOIQ            ;Print "?Illegal Quantity" Error Message
; ----------------------------------- ;Convert FAC to a 16-bit Value in LINNUM:
                JSR   QINT            ;Convert FAC to (4 Byte) Integer
                LDA   FAC+3           ;Get FAC Mantissa, Middle (FAC+3)
                LDY   FAC+4           ;Get FAC Mantissa, Low (FAC+4)
                STY   LINNUM          ;Set Line Number Pointer, Low
                STA   LINNUM+1        ;Set Line Number Pointer, High
                RTS                   ;Return to Caller

; ==============================================================================
; "PEEK" Function: Immediate & Deferred; Parameter: PEEK (Aexpr); Returns the
; decimal content of the byte at the address of the numeric expression (Aexpr)
; ==============================================================================
; 
; ----------------------------------- ;Save LINNUM on Stack during PEEK:
PEEK            LDA   LINNUM          ;Get Line Number Pointer, Low
                PHA                   ;Push Line Number Pointer, Low
                LDA   LINNUM+1        ;Get Line Number Pointer, High
                PHA                   ;Push Line Number Pointer, High
; ----------------------------------- ;Get the Address we're PEEKing at:
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
; ----------------------------------- ;PEEK at the Address:
                LDY   #0              ;Clear Indirect Addressing Index
                LDA   (LINNUM),Y      ;Get Value at the PEEK Address
                TAY                   ;Set with Value from the PEEK Address
; ----------------------------------- ;Retrieve LINNUM from Stack after PEEK:
                PLA                   ;Pull Line Number Pointer, High
                STA   LINNUM+1        ;Set Line Number Pointer, High
                PLA                   ;Pull Line Number Pointer, Low
                STA   LINNUM          ;Set Line Number Pointer, Low
; ----------------------------------- ;Convert Y-Reg to Real/FP Number in FAC:
                JMP   SNGFLT          ;Float Unsigned Integer & Flag as a Number

; ==============================================================================
; "POKE" Statement: Immediate & Deferred; Parameters: POKE Aexpr1, Aexpr2;
; Stores an 8-bit Byte Value (Aexpr2) into a 16-bit Memory Location (Aexpr1)
; ==============================================================================
; 
POKE            JSR   GTNUM           ;Get Address in LINNUM & Value in X-Reg
                TXA                   ;Set (A)=(X)=(Byte Value to Store)
                LDY   #0              ;Clear Indirect Addressing Index
                STA   (LINNUM),Y      ;Set Value at the POKE Address
                RTS                   ;Return to Caller

; ==============================================================================
; "WAIT" (Conditional Pause) Statement: Immediate & Deferred; 
;                           Parameters: WAIT Aexpr1, Aexpr2 [, Aexpr3]
; ==============================================================================
; 
; ----------------------------------- ;Only a Reset can Interupt a WAIT!
WAIT            JSR   GTNUM           ;Get Address in LINNUM & AND-Mask in X-Reg
                STX   FORPTR          ;Store AND-Mask in FORPTR, Low
                LDX   #0              ;Clear XOR-Mask (Default Value = %00000000)
                JSR   CHRGOT          ;Is an XOR-Mask Specified?
                BEQ   WAITSKIP        ;NO, Skip Getting It
                JSR   COMBYTE         ;YES, Get Specified XOR-Mask in X-Reg
WAITSKIP        STX   FORPTR+1        ;Store XOR-Mask in FORPTR, High
                LDY   #0              ;Clear Indirect Addressing Index
; ----------------------------------- ;Do WAIT Address, AND-Mask, XOR-Mask:
WAITLOOP        LDA   (LINNUM),Y      ;Get Byte at Specified Address
                EOR   FORPTR+1        ;Invert Specified Bits by XOR-Mask
                AND   FORPTR          ;Select Specified Bits by AND-Mask
                BEQ   WAITLOOP        ;Loop Until Bits NOT %00000000
BAS_RTS15       RTS                   ;Return to Caller

; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft - Part C, $E7A0-$F1D4: Floating Point Math Routines
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; ==============================================================================
; To see: "How Applesoft BASIC Program Varables* Are Structured"
;         *(Reals {Floating Point}, Integers, Strings, Functions, and Arrays),
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 21 to 24
; ==============================================================================
; YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
; 
; 
; ==============================================================================
; Add 0.5 to FAC                      ;FAC+[(1/2):(Packed FAC Constant)] -> FAC:
; ==============================================================================
; 
FADDH           LDA   #<CON_HALF      ;Get Low  Address of (The Number One Half)
                LDY   #>CON_HALF      ;Get High Address of (The Number One Half)
                JMP   FADD            ;Go Add 0.5 to FAC

; ==============================================================================
; "SUBTRACT" ("-") Function: 
; ==============================================================================
; 
; ----------------------------------- ;Subtract FAC frm (A,Y) & Put Back in FAC:
FSUB            JSR   UPAY2ARG        ;Unpack FP# at [(A,Y)={Low,High}] into ARG
; ------------------------------------------------------------------------------
; FSUBT is Main Entry Point:          ;(Math Operator Table Branch Address +1)
; ----------------------------------- ;Subtract FAC from ARG & Put back in FAC
;                                     ;(Complement FAC & Add):
FSUBT           LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FACSIGN         ;Set FAC Unpacked Sign (msb)
                EOR   ARGSIGN         ;XOR ARG Unpacked Sign (msb)
                STA   SGNCPR          ;Set Sign Comparison Flag
;                                     ;Make Status Show FAC Exponent:
                LDA   FAC             ;Get FAC Exponent (Status if FACX=0)
                JMP   FADDT           ;Go Add ARG to -FAC; Result: FAC=ARG-FAC

; ==============================================================================
; "ADD" ("+") Function:
; ==============================================================================
; 
; ----------------------------------- ;Shift Smaller Argument More Than 7 Bits:
FADD1           JSR   SHFTRGHT        ;Align Radix (Bits) by Shifting Byte Right
;                                     ;^[Radix = Number System Base (Binary =2)]
                BCC   FADD3           ;Always Taken
; 
; ----------------------------------- ;Add FAC to (A,Y) & Put back in FAC:
FADD            JSR   UPAY2ARG        ;Unpack FP# at [(A,Y)={Low,High}] into ARG
; ------------------------------------------------------------------------------
; FADDT is Main Entry Point:          ;(Math Operator Table Branch Address +1)
; ----------------------------------- ;Add FAC to ARG & Put back in FAC:
FADDT           BNE   FADDFAC         ;Branch if FAC is Not Zero (FAC<>0)
                JMP   CPYARG2FAC      ;Else, Go Copy ARG into FAC (FAC=0+ARG)

; ----------------------------------- ;Add Non-Zero FAC to ARG & Put Bak in FAC:
FADDFAC         LDX   FACEXT          ;Get FAC Extra Precision Byte for FP Op's
                STX   ARGEXT          ;Set ARG Extra Precision Byte for FP Op's
                LDX   #ARG            ;Get Set to Shift ARG
                LDA   ARG             ;Get ARG Exponent (ARGX)
FADD2           TAY                   ;Set Y-Reg = ARG Exponent (ARGX)
                BEQ   BAS_RTS15       ;EXIT if ARG=0 (FAC=FAC+0)
;                                     ;^[Mantissas Ignored if FAC|ARG Exp's=0]
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   FAC             ;Subtract FACX from ARGX
                BEQ   FADD3           ;Go Add if Exponents Equal (FACX=ARGX)
                BCC   FARGLESS        ;Branch if ARG has Smaller Exponent
;                                     ;Else, FAC has Smaller Exponent:
                STY   FAC             ;Set FAC Exponent = ARG Exponent
                LDY   ARGSIGN         ;Get ARG Unpacked Sign (msb)
                STY   FACSIGN         ;Set FAC Unpacked Sign (msb)
;                                     ;Complement Shift Count (FACSIGN):
                EOR   #%11111111      ;Invert Bits (Negate)
                ADC   #0              ;Add with Carry still Set, Adds 1
                LDY   #0              ;Clear Y-Reg
                STY   ARGEXT          ;Clear ARG Extra Precision Byte for FP Op's
                LDX   #FAC            ;Get Set to Shift FAC
                BNE   FBITSHFT        ;Always Taken

;                                     ;ARG has Smaller Exponent:
FARGLESS        LDY   #0              ;Clear Y-Reg
                STY   FACEXT          ;Clear FAC Extra Precision Byte for FP Op's
;                                     ;Determine How Many Bits to Shift:
FBITSHFT        CMP   #$F9            ;=(-7); Shifting more than 7 bits?
;                                     ;^[Negative of Shift Count]
                BMI   FADD1           ;Branch if Shifting more than 7 bits
                TAY                   ;Set Number of Shifts Index (Counter)
                LDA   FACEXT          ;Get FAC Extra Precision Byte for FP Op's
; ----------------------------------- ;Shift Right Smaller of FAC & ARG:
;                                     ;SHFTPTR=(Base Address for FAC & ARG)=LOC1
;                                     ;(X)=(Address of Smaller of FAC & ARG)
                LSR   LOC1,X          ;Start Shifting...  [(LOC1..LOC4) then (A)]
                JSR   SHFTRGHT4       ;...Complete Shifting  [(LOC2..LOC4) & (A)]
; ----------------------------------- ;What to do next:
FADD3           BIT   SGNCPR          ;Do FAC & ARG Have Same Signs?
                BPL   ADDMANTS        ;YES, Go Add Mantissas
                LDY   #FAC            ;NO, Subtract Smaller from Larger
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($E800-$EFFF): ROM Socket $E8 on a real Apple II Plus.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
                CPX   #ARG            ;[(X)=(#FAC)]  Which was Shifted Right?  
                BEQ   SUBMANTS        ;If ARG was Shifted Right, Do FAC-ARG
                LDY   #ARG            ;If FAC was Shifted Right, Do ARG-FAC
; ----------------------------------- ;Subtract Smaller from Larger [might be
;                                     ;Larger from Smaller if Exponents Equal];
;              ---------------------- ;1st, Subtr Smaller Extra Precision Byte:
;                                     ;(A)=(Extra Precision Byte from SHFTRGHT4)
SUBMANTS        SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
;                                     ;or to Add with Carry Set (Adds 1)
                EOR   #%11111111      ;Invert Bits [Negate (A)]
                ADC   ARGEXT          ;Add ARG Extra Precision Byte for FP Op's
                STA   FACEXT          ;Set FAC Extra Precision Byte for FP Op's
;                                     ;^[Remember: It all gets put back in FAC]
;              ---------------------- ;2nd, Subtract Smaller Mantissa:
;                                     ;SHFTPTR=(Base Addrs for FAC & ARG)=LOC1
;                                     ;(Y)=(Address of Larger  of FAC & ARG)
;                                     ;(X)=(Address of Smaller of FAC & ARG)
                LDA   LOC4,Y          ;Get Larger Mantissa, Low
                SBC   LOC4,X          ;Subtract Smaller Mantissa, Low
                STA   FAC+4           ;Set FAC Mantissa, Low
                LDA   LOC3,Y          ;Get Larger Mantissa, Middle
                SBC   LOC3,X          ;Subtract Smaller Mantissa, Middle
                STA   FAC+3           ;Set FAC Mantissa, Middle
                LDA   LOC2,Y          ;Get Larger Mantissa, High
                SBC   LOC2,X          ;Subtract Smaller Mantissa, High
                STA   FAC+2           ;Set FAC Mantissa, High
                LDA   LOC1,Y          ;Get Larger Mantissa, Top
                SBC   LOC1,X          ;Subtract Smaller Mantissa, Top
                STA   FAC+1           ;Set FAC Mantissa, Top
; ----------------------------------- ;Normalize Value in FAC:
NRMLZFAC1       BCS   NRMLZFAC2       ;Branch if Different Position Values
                JSR   TWSCMPFAC       ;Else, Two's Compliment FAC
NRMLZFAC2       LDY   #0              ;Clear Y-Reg
                TYA                   ;Clear Shift Up Counter (A-Reg)
                CLC                   ;Prepare for Add with Carry
NRMLZLOOP       LDX   FAC+1           ;Get FAC Mantissa, Top
                BNE   FNRMLZFAC       ;Finish Normalizing FAC if any 1-Bits here
;              ---------------------- ;Else, Zero, So Do a Fast 8-Bit Shuffle:
                LDX   FAC+2           ;Get FAC Mantissa, High
                STX   FAC+1           ;Set FAC Mantissa, Top
                LDX   FAC+3           ;Get FAC Mantissa, Middle
                STX   FAC+2           ;Set FAC Mantissa, High
                LDX   FAC+4           ;Get FAC Mantissa, Low
                STX   FAC+3           ;Set FAC Mantissa, Middle
                LDX   FACEXT          ;Get FAC Extra Precision Byte for FP Op's
                STX   FAC+4           ;Set FAC Mantissa, Low
                STY   FACEXT          ;Zero FAC Extra Precision Byte for FP Op's
                ADC   #8              ;Advance Shift Count (Add 8 Bits)
                CMP   #32             ;Done 4 times yet? [(4*(8 Bits))=(4 Bytes)]
                BNE   NRMLZLOOP       ;NO, Still might be some 1's; LOOP-Back
; ----------------------------------- ;Zero FAC: (Only need do Exponent & Sign):
ZFACEXPSGN      LDA   #0              ;Clear Accumulator
ZFACSGNEXP      STA   FAC             ;Set FAC Signed Exponent
ZFACSGN         STA   FACSIGN         ;Set FAC Sign
                RTS                   ;Return to Caller

; ----------------------------------- ;Add Mantissas of FAC & ARG into FAC:
;                                     ;(A) FAC Extra Precision Byte for FP Op's
ADDMANTS        ADC   ARGEXT          ;Add ARG Extra Precision Byte for FP Op's
                STA   FACEXT          ;Set FAC Extra Precision Byte for FP Op's
                LDA   FAC+4           ;Get FAC Mantissa, Low
                ADC   ARG+4           ;Add ARG Mantissa, Low
                STA   FAC+4           ;Set FAC Mantissa, Low
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                ADC   ARG+3           ;Add ARG Mantissa, Middle
                STA   FAC+3           ;Set FAC Mantissa, Middle
                LDA   FAC+2           ;Get FAC Mantissa, High
                ADC   ARG+2           ;Add ARG Mantissa, High
                STA   FAC+2           ;Set FAC Mantissa, High
                LDA   FAC+1           ;Get FAC Mantissa, Top
                ADC   ARG+1           ;Add ARG Mantissa, Top
                STA   FAC+1           ;Set FAC Mantissa, Top
                JMP   FRBCC           ;Go See if Matissa Carried

; ----------------------------------- ;Finish Normalizing FAC:
FRLOOP          ADC   #1              ;Count Bits Shifted
                ASL   FACEXT          ;Shift Left: FAC Extra Precision Byte
                ROL   FAC+4           ;Shift Left: FAC Mantissa, Low
                ROL   FAC+3           ;Shift Left: FAC Mantissa, Middle
                ROL   FAC+2           ;Shift Left: FAC Mantissa, High
                ROL   FAC+1           ;Shift Left: FAC Mantissa, Top
FNRMLZFAC       BPL   FRLOOP          ;Repeat until FAC-Top becomes Negative
; ----------------------------------- ;Two's Complement FAC
;                                     ;(Adjust Exponent by Bits Shifted):
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   FAC             ;Subtract FAC Exponent from Bits Shifted
                BCS   ZFACEXPSGN      ;Branch if Underflow; Return FAC Zeroed
                EOR   #%11111111      ;Invert Bits (Negate)
                ADC   #1              ;Two's Complement (A)
                STA   FAC             ;Set FAC Exponent (Two's Complemented)
; ----------------------------------- ;Carry is Clear here; Return to Caller
FRBCC           BCC   BAS_RTS16       ;Return to Caller if Carry is Clear
;                                     ;Else, Carry is Set, So Mantissa Carried:
FROUND          INC   FAC             ;Advance FAC Exponent; Add Carry (+1)
                BEQ   OVERFLOW        ;Throw Overflow Error if Exponent Too Big
; ----------------------------------- ;Shift FAC Mantissa Right:
                ROR   FAC+1           ;Shift Right: FAC Mantissa, Top
                ROR   FAC+2           ;Shift Right: FAC Mantissa, High
                ROR   FAC+3           ;Shift Right: FAC Mantissa, Middle
                ROR   FAC+4           ;Shift Right: FAC Mantissa, Low
                ROR   FACEXT          ;Shift Right: FAC Extra Precision Byte
BAS_RTS16       RTS                   ;Return to Caller

; ----------------------------------- ;Two's Complement FAC:
;                                     ;1st, One's Complement FAC:
TWSCMPFAC       LDA   FACSIGN         ;Get FAC Sign
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FACSIGN         ;Set FAC Sign
;              ---------------------- ;Two's Complement FAC Mantissa (only):
;                                     ;1st, One's Complement FAC Mantissa:
TCFACMANT       LDA   FAC+1           ;Get FAC Mantissa, Top
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FAC+1           ;Set FAC Mantissa, Top
                LDA   FAC+2           ;Get FAC Mantissa, High
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FAC+2           ;Set FAC Mantissa, High
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FAC+3           ;Set FAC Mantissa, Middle
                LDA   FAC+4           ;Get FAC Mantissa, Low
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FAC+4           ;Set FAC Mantissa, Low
                LDA   FACEXT          ;Get FAC Extra Precision Byte
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FACEXT          ;Set FAC Extra Precision Byte
; ----------------------------------- ;2nd, Add a Bit to get Two's Complement:
;                                     ;(Start Advancing FAC Mantissa):
                INC   FACEXT          ;Advance FAC Extra Precision Byte
                BNE   BAS_RTS17       ;Return to Caller if No Carryover
;              ---------------------- ;Advance FAC Mantissa:
;                                     ;(Add Carry frm FAC Extra Precision Byte):
INCFACMAN       INC   FAC+4           ;Advance FAC Mantissa, Low
                BNE   BAS_RTS17       ;Return to Caller if No Carryover
                INC   FAC+3           ;Advance FAC Mantissa, Middle
                BNE   BAS_RTS17       ;Return to Caller if No Carryover
                INC   FAC+2           ;Advance FAC Mantissa, High
                BNE   BAS_RTS17       ;Return to Caller if No Carryover
                INC   FAC+1           ;Advance FAC Mantissa, Top
BAS_RTS17       RTS                   ;Return to Caller

; ----------------------------------- ;Error Entry Point; Also User-Callable: 
OVERFLOW        LDX   #ERR_OVERFLOW   ;Throw an "?Overflow" Error:
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Shift Right (Subroutine)
; ==============================================================================
; SHFTRGHT1 is Auxiliary Entry Point: Entered from FMULT Function
; ------------------------------------------------------------------------------
;                                     ;Shift RESULT Right [(LOC1..LOC4),X]:
; Entry from "MULTIPLY" Function:     ;Carry should be Set!
;                                     ;A-Reg = Negative Shift Count [+0 <-- $F9]
;                                     ;X-Reg = Pointer to Bytes to be Shifted
;                                     ;Returns: Y=0, Carry=0, A=(Extension Bits)
; ------------------------------------------------------------------------------
SHFTRGHT1       LDX   #RESULT-1       ;Get Pointer to Bytes to be Shifted
SR1LOOP         LDY   LOC4,X          ;Get RESULT Mantissa, Low
                STY   FACEXT          ;Set FAC Extra Precision Byte
                LDY   LOC3,X          ;Get RESULT Mantissa, Middle
                STY   LOC4,X          ;Set RESULT Mantissa, Low
                LDY   LOC2,X          ;Get RESULT Mantissa, High
                STY   LOC3,X          ;Set RESULT Mantissa, Middle
                LDY   LOC1,X          ;Get RESULT Mantissa, Top
                STY   LOC2,X          ;Set RESULT Mantissa, High
                LDY   SHFTSGNX        ;Get FAC Right Shift Sign Extension
;                                     ;^[$00 if Positive, $FF if Negative]
;                                     ;^[Also Negative ($FF) if from QINT]
                STY   LOC1,X          ;Set RESULT Mantissa, Top ($00 or $FF)
; ------------------------------------------------------------------------------
; SHFTRGHT is Main Entry Point: Entered from FADDT & QINT Functions
; ------------------------------------------------------------------------------
;                                     ;Shift Right [(LOC1..LOC4),X then (A)]:
; Entry from "ADD" Function:          ;SHFTPTR=(Base Address for FAC & ARG)=LOC1
;                                     ;(X)=(Address of Smaller of FAC & ARG)
; ------------------------------------------------------------------------------
;                                     ;Shift Rght [($100)-(A)] Bits, Long (>7b):
SHFTRGHT        ADC   #8              ;Reduce Negative Shift Count (Add 8 Bits)
                BMI   SR1LOOP         ;Repeat if Neg Shift Count < 0 still
;                                     ;^(Still more than 8 Bits to go)
                BEQ   SR1LOOP         ;Repeat if Neg Shift Count = 0 also
;                                     ;^(Exactly 8 more Bits to go)
                SBC   #8              ;Advance Neg Shift Count (Subtract 8 Bits)
;                                     ;^(Undoes Reduction Above)
                TAY                   ;Save Remaining Negative Shift Count
                LDA   FACEXT          ;Get FAC Extra Precision Byte
                BCS   SHFTRGHT5       ;EXIT if Shift Right Finished
; ----------------------------------- ;Shift Right (LOOP) [Lower 7 Bits Only]:
;                                     ;1st, Get Sign of RESULT into Carry Flag:
SRLOOP          ASL   LOC1,X          ;Shift Left: RESULT Mantissa, Top
;                                     ;^[Puts Sign in (C) {Sign Extension Bit}]
                BCC   SRSKP           ;Skip Advancing Top Byte if NO Carry
                INC   LOC1,X          ;Advance (+1) Result, Top; Adds Carry
;                                     ;^[Puts Sign Extension Bit into LSB]
;                                     ;^[Forces next OP to Set Carry Flag]
SRSKP           ROR   LOC1,X          ;Shift Right: RESULT Mantissa, Top (1st)
;                                     ;^[Restores Value w/ Sign still in Carry]
; ----------------------------------- ;Shift Right [(LOC1..LOC4),X then (A)]:
                ROR   LOC1,X          ;Shift Right: RESULT Mantissa, Top (2nd)
;                                     ;^[Start Right Shift, inserting Sign]
; ------------------------------------------------------------------------------
; SHFTRGHT4 is Auxiliary Entry Point: Also Entered from FADDT & QINT Functions;
; Enter Here for Short Shifts with No Sign Extension:
; ------------------------------------------------------------------------------
SHFTRGHT4       ROR   LOC2,X          ;Shift Right: RESULT Mantissa, High
                ROR   LOC3,X          ;Shift Right: RESULT Mantissa, Middle
                ROR   LOC4,X          ;Shift Right: RESULT Mantissa, Low
                ROR   A               ;Shift Right: Extension Byte (A)
                INY                   ;Reduce Negative Shift Count (Add a Bit)
                BNE   SRLOOP          ;LOOP: Shift Right Until All Bits Done
; ------------------------------------------------------------------------------
SHFTRGHT5       CLC                   ;Return with Carry Clear
                RTS                   ;Return to Caller

; ==============================================================================
; The Number One (1)                                       (Packed FAC Constant)
; ==============================================================================
; 
CON_ONE         HEX   8100000000      ;<-[Normalized]; The Number One (1)
; 
; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ONE  HEX 8100000000 |(00) |$81-$80=$01= +1 |$.00000000 |+1.00000000E+0
; (!) POS_ONE  HEX 8180000000 |(00) |$81-$80=$01= +1 |$.80000000 |+1.00000000E+0
; (!) NEG_ONE  HEX 8180000000 |(FF) |$81-$80=$01= +1 |$.80000000 |-1.00000000E+0
; ------------------------------------------------------------------------------
; <<< Plugging CON_ONE into & Printing FAC ($ED2EG) results in BLANK LINE, not 1
; --Seems that when the mantissa is zero there's a problem printing numbers! >>>
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; Polynomial Log Coefficients       (Packed FAC Constants adjusted for accuracy)
; ==============================================================================
; Logarithm Formulas:
; ------------------------------------------------------------------------------
;      Log (base b) N = ln(N) / ln(b)
;      Log (base 2) N = ln(N) / ln(2)
; ==============================================================================
; How do these "*X^N+" Poly Logs work?  We're not talking about baby frogs here!
; ------------------------------------------------------------------------------
; According to Michael Pohoreski (AppleWin Debugger Developer), "Applesoft uses
; Horner's Rule [a polynomial evaluation method] when it calculates a partial
; Taylor Series.  See: <https://en.wikipedia.org/wiki/horner's_method>"
; ------------------------------------------------------------------------------
; According to Kent Dicky, "A useful approximation to many functions over
; limited ranges is something like: f(x) = A*x + B*x^2 + C*x^3 + D*x^4, etc.
; where 'x' is the input number, and A,B,C,D are constants that depend on the
; function being evaluated.  [Which seems to fit here.]  For example, the Taylor
; series: sin(x) = [x=(x^1)/(1!)] - (x^3)/(3!) + (x^5)/(5!) - (x^7)/(7!) + ...."
; ==============================================================================
; 
POLY_LOG        DFB   $03             ;Number of Log Coefficients - 1
; NOTE: Packed FAC Constants or Not?  Still a Mystery!
POLY_LOG_7      HEX   7F5E56CB79      ;* X^7 +              :[10^7 = 10,000,000]
POLY_LOG_5      HEX   80139B0B64      ;* X^5 +              :[10^5 =    100,000]
POLY_LOG_3      HEX   8076389316      ;* X^3 +              :[10^3 =      1,000]
POLY_LOG_1      HEX   8238AA3B20      ;* X^1 +              :[10^1 =         10]
; 
;    [Packed FAC Constants or Not?  These do NOT print the numbers expected!]
; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit: 
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; NRM_PLOG_7   HEX 7F5E56CB79 |(00) |$7F-$80=$FF= -1 |$.5E56CB79 |+1.84255942E-1
; POS_PLOG_7   HEX 7FDE56CB79 |(00) |$7F-$80=$FF= -1 |$.DE56CB79 |+4.34255942E-1
; NEG_PLOG_7   HEX 7FDE56CB79 |(FF) |$7F-$80=$FF= -1 |$.DE56CB79 |-4.34255942E-1
; ----------------------------|-----|----------------|-----------|--------------
; NRM_PLOG_5   HEX 80139B0B64 |(00) |$80-$80=$00= +0 |$.139B0B64 |+7.65845413E-2
; POS_PLOG_5   HEX 80939B0B64 |(00) |$80-$80=$00= +0 |$.939B0B64 |+5.76584541E-1
; NEG_PLOG_5   HEX 80939B0B64 |(FF) |$80-$80=$00= +0 |$.939B0B64 |-5.76584541E-1
; ----------------------------|-----|----------------|-----------|--------------
; NRM_PLOG_3   HEX 8076389316 |(00) |$80-$80=$00= +0 |$.76389316 |+4.61800759E-1
; POS_PLOG_3   HEX 80F6389316 |(00) |$80-$80=$00= +0 |$.F6389316 |+9.61800759E-1
; NEG_PLOG_3   HEX 80F6389316 |(FF) |$80-$80=$00= +0 |$.F6389316 |-9.61800759E-1
; ----------------------------|-----|----------------|-----------|--------------
; NRM_PLOG_1   HEX 8238AA3B20 |(00) |$82-$80=$02= +2 |$.38AA3B20 |+8.85390073E-1
; POS_PLOG_1   HEX 82B8AA3B20 |(00) |$82-$80=$02= +2 |$.B8AA3B20 |+2.88539007E+0
; NEG_PLOG_1   HEX 82B8AA3B20 |(FF) |$82-$80=$02= +2 |$.B8AA3B20 |-2.88539007E+0
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; Miscellaneous Coefficients                              (Packed FAC Constants)
; ==============================================================================
; 
CON_SQRHALF     HEX   803504F334      ;SQR(1/2) = 0.707106781
CON_SQRTWO      HEX   813504F334      ;  SQR(2) = 1.414213562
CON_NEGHALF     HEX   8080000000      ;   -1/2  = -.500000000
CON_LOGTWO      HEX   80317217F8      ;   ln(2) = 0.693147181; {<> POLY_EXP_LN2}

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit: 
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_SQRH HEX 803504F334 |(00) |$80-$80=$00= +0 |$.3504F334 |+2.07106781E-1
; (!) POS_SQRH HEX 80B504F334 |(00) |$80-$80=$00= +0 |$.B504F334 |+7.07106781E-1
; (!) NEG_SQRH HEX 80B504F334 |(FF) |$80-$80=$00= +0 |$.B504F334 |-7.07106781E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_SQR2 HEX 813504F334 |(00) |$81-$80=$01= +1 |$.3504F334 |+0.41421356E+0
; (!) POS_SQR2 HEX 81B504F334 |(00) |$81-$80=$01= +1 |$.B504F334 |+1.41421356E+0
; (!) NEG_SQR2 HEX 81B504F334 |(FF) |$81-$80=$01= +1 |$.B504F334 |-1.41421356E+0
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_HALF HEX 8000000000 |(00) |$80-$80=$00= +0 |$.00000000 |+5.00000000E-1
; (!) POS_HALF HEX 8080000000 |(00) |$80-$80=$00= +0 |$.80000000 |+5.00000000E-1
; (!) NEG_HALF HEX 8080000000 |(FF) |$80-$80=$00= +0 |$.80000000 |-5.00000000E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_LN2  HEX 80317217F8 |(00) |$80-$80=$00= +0 |$.317217F8 |+1.93147181E-1
; (!) POS_LN2  HEX 80B17217F8 |(00) |$80-$80=$00= +0 |$.B17217F8 |+6.93147181E-1
; (!) NEG_LN2  HEX 80B17217F8 |(FF) |$80-$80=$00= +0 |$.B17217F8 |-6.93147181E-1
; ==============================================================================
; 
; 
; ==============================================================================
; "LOG" Function: Immediate & Deffered; Parameter: LOG (Aexpr);
;       Returns the Natural Logarithm (ln) of a Positive Number (Aexpr)
;       [(e=2.71828183...) is Euler's Constant, the Base for Natural Logarithms]
; ==============================================================================
; 
LOG             JSR   SIGN            ;FAC Sign (Neg|0|Pos) Returns (A)=(-1|0|1)
                BEQ   GIQ             ;Do Illegal Quantity Error if Not Positive
                BPL   LOG2            ;Do Natural Logarithm if Number is Positive
GIQ             JMP   IQERR           ;Print "?Illegal Quantity" Error Message

; ------------------------------------------------------------------------------
; Compute Natural Logarithm via Series of Odd Powers of (SQR(2)X-1)/(SQR(2)X+1):
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;AHA! So this is how Normalization is done
LOG2            LDA   FAC             ;Get FAC Exponent [Log (base 2)]
                SBC   #$7F            ;Subtract with Borrow [A-Data-!C]:(!C=1)
                PHA                   ;Push FAC Exponent [Unbiased (FACX-$80)]
                LDA   #$80            ;Normalize between .5 & 1
                STA   FAC             ;Set FAC Exponent [Normalized]
; ----------------------------------- ;Compute Natural Logarithm:
;                                     ;[(A,Y)={Low,High}] in these OPs:
                LDA   #<CON_SQRHALF   ;Get Address of Constant [SQR(1/2)], Low
                LDY   #>CON_SQRHALF   ;Get Address of Constant [SQR(1/2)], High
                JSR   FADD            ;Add FAC to (A,Y) & Put back in FAC
                LDA   #<CON_SQRTWO    ;Get Address of Constant [SQR(2)], Low
                LDY   #>CON_SQRTWO    ;Get Address of Constant [SQR(2)], High
                JSR   FDIV            ;Divide FAC into (A,Y) & Put back in FAC
                LDA   #<CON_ONE       ;Get Address of Constant [One (1)], Low
                LDY   #>CON_ONE       ;Get Address of Constant [One (1)], High
                JSR   FSUB            ;Subtract FAC from (A,Y) & Put back in FAC
                LDA   #<POLY_LOG      ;Get Address of Log Coefficients, Low
                LDY   #>POLY_LOG      ;Get Address of Log Coefficients, High
                JSR   POLY_ODD        ;Compute [LOG (base 2) of (+.5)]:
;                                     ;Computes ax+bx^3+cx^5+... where
;                                     ;(A,Y) points to Coeficients ...c,b,a
                LDA   #<CON_NEGHALF   ;Get Address of Constant [(-.5)], Low
                LDY   #>CON_NEGHALF   ;Get Address of Constant [(-.5)], High
                JSR   FADD            ;Add FAC to (A,Y) & Put back in FAC
                PLA                   ;Pull FAC Exponent [Unbiased (FACX-$80)]
                JSR   ADDACC          ;Add FAC to (A) & Put back in FAC
;                                     ;Multiply by LOG(2) to get Natural Log
                LDA   #<CON_LOGTWO    ;Get Address of Constant [ln(2)], Low
                LDY   #>CON_LOGTWO    ;Get Address of Constant [ln(2)], High
; 
; ==============================================================================
; "MULTIPLY" ("*") Function:
; ==============================================================================
; 
; ----------------------------------- ;Multiply FAC by (A,Y) & Put back in FAC:
FMULT           JSR   UPAY2ARG        ;Unpack FP# at [(A,Y)={Low,High}] into ARG
; ------------------------------------------------------------------------------
; FMULTT is Main Entry Point:         ;(Math Operator Table Branch Address +1):
; ----------------------------------- ;Multiply FAC by ARG & Put back in FAC:
FMULTT          BNE   FMULTT1         ;Branch if FAC is Not Zero (FAC<>0)
; <<< Could be RTS here! >>>          ;Else: Multiplying by Zero produces Zero!
                JMP   BAS_RTS18       ;So, just Return if FAC is Zero (FAC=0)

FMULTT1         JSR   ADDEXPS         ;Add ARG & FAC Exponents [FACX=ARGX+FACX]
;                                     ;^[Checks for Overflow & Sets RESULT Sign]
                LDA   #0              ;Initialize Product = 0
; ----------------------------------- ;Clear/Zero FP RESULT of Last Mult or Div:
                STA   RESULT          ;Set RESULT Mantissa, Top
                STA   RESULT+1        ;Set RESULT Mantissa, High
                STA   RESULT+2        ;Set RESULT Mantissa, Middle
                STA   RESULT+3        ;Set RESULT Mantissa, Low
; ----------------------------------- ;Multiply FAC by ARG & Add to RESULT:
                LDA   FACEXT          ;Get FAC Extra Precision Byte
                JSR   MULT1           ;Multiply (A) by ARG & Add to RESULT
                LDA   FAC+4           ;Get FAC Mantissa, Low
                JSR   MULT1           ;Multiply (A) by ARG & Add to RESULT
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                JSR   MULT1           ;Multiply (A) by ARG & Add to RESULT
                LDA   FAC+2           ;Get FAC Mantissa, High
                JSR   MULT1           ;Multiply (A) by ARG & Add to RESULT
                LDA   FAC+1           ;Get FAC Mantissa, Top
                JSR   MULT2           ;Multiply ARG by (A) & Add to RESULT
;                                     ;^[Assumes Multipliand is Not Zero (A<>0)]
                JMP   CPY2FAC         ;Go Move RESULT into FAC & Normalize

; ----------------------------------- ;Multiply (A) by ARG & Add to RESULT:
MULT1           BNE   MULT2           ;Branch if Multipliand is Not Zero (A<>0)
;                                     ;^[Do 8-Bit Multiply if (A) is Not Zero]
;                                     ;Else: Multiplying by Zero produces Zero!
; <<< ---------------------------------------------------------------------- >>>
; BUG: There should be a SEC here.  Usually it is set since MULT2 leaves it that
; way, but SHFTRGHT1 leaves it clear.  Using SHFTRGHT1 from the MULT1 entry
; assumes carry set.  Thus, if SHFTRGHT1 is used twice in a row, the calculation
; will be off in the last 8 bits!  This happens when FAC+2 & FAC+3 are both 0
; but FAC+4 is not 0. For example, try PRINT 1.998244415 or PRINT 1*10.0000009
; <<< ---------------------------------------------------------------------- >>>
                JMP   SHFTRGHT1       ;Go Shift RESULT Right 1 Byte (Speedier!)

; ------------------> SHFTRGHT1 <---- ;^[Shifts Low to FAC Extra Precision Byte]
;                     ^^^^^^^^^------ ;<<< Because of bug in FMULT, ... >>>
; 
; ----------------------------------- ;Multiply ARG by (A) & Add to RESULT:
;                                     ;^[Assumes Multipliand is Not Zero (A<>0)]
;                                     ;^[This S/R Does an 8-Bit Multiply]
MULT2           LSR   A               ;Shift Multipliand LS-Bit into Carry
                ORA   #%10000000      ;Supply a Guard MS-Bit (to LOOP 8 times)
M2ADDLOOP       TAY                   ;Save Remaining Multipliand with Guard Bit
                BCC   MULT2SHFT       ;Branch if Multipliand LS-Bit is Zero (C=0)
;              ---------------------- ;Else (C=1), So Mult Bit by ARG to RESULT;
;                                     ;(or put simply) Add ARG (once) to RESULT:
                CLC                   ;Prepare for Add with Carry
                LDA   RESULT+3        ;Get RESULT Mantissa, Low
                ADC   ARG+4           ;Add ARG Mantissa, Low
                STA   RESULT+3        ;Set RESULT Mantissa, Low
                LDA   RESULT+2        ;Get RESULT Mantissa, Middle
                ADC   ARG+3           ;Add ARG Mantissa, Middle
                STA   RESULT+2        ;Set RESULT Mantissa, Middle
                LDA   RESULT+1        ;Get RESULT Mantissa, High
                ADC   ARG+2           ;Add ARG Mantissa, High
                STA   RESULT+1        ;Set RESULT Mantissa, High
                LDA   RESULT          ;Get RESULT Mantissa, Top
                ADC   ARG+1           ;Add ARG Mantissa, Top
                STA   RESULT          ;Set RESULT Mantissa, Top
;              ---------------------- ;Shift Right: RESULT (Product) 1 Bit:
MULT2SHFT       ROR   RESULT          ;Shift Right: RESULT Mantissa, Top
                ROR   RESULT+1        ;Shift Right: RESULT Mantissa, High
                ROR   RESULT+2        ;Shift Right: RESULT Mantissa, Middle
                ROR   RESULT+3        ;Shift Right: RESULT Mantissa, Low
                ROR   FACEXT          ;Shift Right: FAC Extra Precision Byte
                TYA                   ;Retrieve Remaining Multipliand & Guard Bit
                LSR   A               ;Shift Multipliand LS-Bit into Carry & ...
;                                     ;Shift Zero into MSB, to Left of Guard Bit
                BNE   M2ADDLOOP       ;LOOP if Multipliand is Not Zero (A<>0) YET
;                                     ;^[Loops 8 times (via Guard Bit)]
;                                     ;<<< Does Guard Bit cause Extra ADD? >>>
BAS_RTS18       RTS                   ;Return to Caller

; ==============================================================================
; Unpack Floating Point Number at [(A,Y)={Low,High}] 
; into ARG (Secondary Floating Point Accumulator)
; ==============================================================================
; [Wouldn't a general purpose copier S/R (using pointers & loops) be better?
;  --Especially for all the Applesoft S/R's that move things like this one?]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Unpack FP# at [(A,Y)={Lo,Hi}] into ARG:
UPAY2ARG        STA   INDEX           ;Set as NUMBER Pointer, Low
                STY   INDEX+1         ;Set as NUMBER Pointer, High
                LDY   #4              ;Set Y-Index [=4] to Count Down Moves
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Low
                STA   ARG+4           ;Set ARG Mantissa, Low
                DEY                   ;Reduce Y-Index [=3]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Middle
                STA   ARG+3           ;Set ARG Mantissa, Middle
                DEY                   ;Reduce Y-Index [=2]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, High
                STA   ARG+2           ;Set ARG Mantissa, High
                DEY                   ;Reduce Y-Index [=1]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Top
;                                     ;Setup Combined Sign for Multiply/Divide:
                STA   ARGSIGN         ;Set ARG Unpacked Sign (msb), too
                EOR   FACSIGN         ;XOR with FAC Unpacked Sign (msb)
                STA   SGNCPR          ;Set Sign Flag for Comparing as M/D Sign 
;                                     ;Complete ARG Mantissa, Top:
                LDA   ARGSIGN         ;Get ARG Unpacked Sign (msb) to...
                ORA   #%10000000      ;Set Normalized Invisible Bit (msb)
                STA   ARG+1           ;Set ARG Mantissa, Top
                DEY                   ;Reduce Y-Index [=0]
                LDA   (INDEX),Y       ;Get NUMBER Exponent
                STA   ARG             ;Set ARG Exponent
                LDA   FAC             ;Get FAC Exponent (to Check Zero Status)
;                                     ;^[Users: FADDT, FMULTT, FDIVT, Not FSUBT]
                RTS                   ;Return [(A)=(FAC Exponent)] to Caller

; ==============================================================================
; Add Exponents of ARG and FAC (called by FMULT and FDIV)
; ==============================================================================
; Also check for overflow, and set result sign
; ==============================================================================
ADDEXPS         LDA   ARG             ;Get ARG Exponent
ADDEXPS1        BEQ   ZERO            ;Branch if ARG=0, Result is Zero
                CLC                   ;Prepare for Add with Carry
                ADC   FAC             ;Add FAC Exponent
                BCC   ADDEXPS2        ;Branch if In Range
                BMI   JOV             ;Branch if Overflow
                CLC                   ;Prepare for Add with Carry
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

ADDEXPS2        BPL   ZERO            ;Branch if Underflow, Result is Zero
                ADC   #$80            ;Add to Re-Bias Exponent
;                                     ;^[Correct for $80 Displacement]
                STA   FAC             ;Set FAC Exponent with Result
                BNE   ADDEXPS3        ;Branch if FAC<>0, Result is In Range
                JMP   ZFACSGN         ;GO Zero FAC Sign

; ==============================================================================
; <<<  Another mistake(?) here in Billy-Boy's (Microsoft?/Applesoft!) BASIC  >>>
; ------------------------------------------------------------------------------
; About code above: <<< Crazy to jump way back there!  Same identical code is
; below! Instead of BNE ADDEXPS3 & JMP ZFACSGN, only need BEQ ADDEXPS4 *     >>>
; ------------------------------------------------------------------------------
; EA21: D0 03     BNE  ADDEXPS3 ;<* Instead of this, replace w/ following line,>
; EA21: F0 02     BEQ  ADDEXPS4 ;Branch if Result is Zero           <* Do this!>
; EA23: 4C 52 E8  JMP  ZFACSGN  ;Result is Zero          <* & Remove this line!>
; ------------------------------------------------------------------------------
; <<<<<<<< * You can change it in (Apple II Plus) Emulator ROM images!  >>>>>>>>
; ==============================================================================
; 
ADDEXPS3        LDA   SGNCPR          ;Get Sign Flag for Comparing
ADDEXPS4        STA   FACSIGN         ;Use it to Set Sign of Result in FAC
                RTS                   ;Return to Caller <* from here, not via JMP>

; ==============================================================================
; OUT OF RANGE; Called from EXP Function
; ==============================================================================
; If (FAC) is Positive, Give OVERFLOW Error
; If (FAC) Is Negative, Set FAC=0, POP one Return, and RTS
; ==============================================================================
OUTOFRNG        LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                EOR   #%11111111      ;Invert Bits (Negate)
                BMI   JOV             ;Overflow Error if was Positive Number
ZERO            PLA                   ;Pull/Discard Return Address, Low
                PLA                   ;Pull/Discard Return Address, High
                JMP   ZFACEXPSGN      ;Return Zero if was Negative Number

JOV             JMP   OVERFLOW        ;Go Throw an "?Overflow" Error

; ==============================================================================
; Multiply FAC by Ten (10):
; ==============================================================================
; Using FAC & ARG Exponents (FACX & ARGX): Adding Powers Multiplies Values; 
; Adding 1 Power Multiplies a Value by its Power Base (e.g., Binary = Base 2);
; Hense, the formula used here: [10x = (2*(5x)) = (2*((4x)+x)) = (2*((2*2x)+x))]
; ==============================================================================
; 
MUL10           JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
                TAX                   ;Test FAC Eponent:
                BEQ   MUL10RTN        ;EXIT if FACX=0
                CLC                   ;Prepare for Add with Carry
                ADC   #2              ;FACX+2 = [(2^2)*FACX] = 4*FACX
                BCS   JOV             ;Throw an "?Overflow" Error if Carry is Set
                LDX   #0              ;Set as Flag for Adding Same Signed Values:
                STX   SGNCPR          ;Set Sign Flag for Comparing
                JSR   FADD2           ;Makes FAC*5: [FACX=(4*FACX)+ARGX]
                INC   FAC             ;Makes FAC*10: [FACX=2*(FACX*5)]
                BEQ   JOV             ;Throw an "?Overflow" Error if FACX=0
MUL10RTN        RTS                   ;Return to Caller

; ==============================================================================
; The Number Ten (10) [or Two (2)!?]                       (Packed FAC Constant)
; ==============================================================================
; 
CON_TEN         HEX   8420000000      ;<-[Normalized]; The Number Ten (10)

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit: 
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_TEN  HEX 8420000000 |(00) |$84-$80=$04= +4 |$.20000000 |+1.00000000E+1
; (!) POS_TEN  HEX 84A0000000 |(00) |$84-$80=$04= +4 |$.A0000000 |+1.00000000E+1
; (!) NEG_TEN  HEX 84A0000000 |(FF) |$84-$80=$04= +4 |$.A0000000 |-1.00000000E+1
; ------------------------------------------------------------------------------
; <<< Plugging NRM_TEN into & Printing FAC ($ED2EG) results in a 2, not a 10 >>>
;     Plugging 84A000000000 into & Printing FAC ($ED2EG) results in +10.
;     Plugging 84A0000000FF into & Printing FAC ($ED2EG) results in -10.
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; Divide ABS(FAC) by Ten (10):
; ==============================================================================
; Using FAC & ARG Exponents (FACX & ARGX): Subtracting Powers Divides Values; 
; Subtracting 1 Power Divides a Value by its Power Base (e.g., Binary = Base 2);
; Hense, the formula used here: [x/10]=[x/(2*5) = x/(2*(4+1)) = x/(2*((2*2)+1))]
; ==============================================================================
; 
DIV10           JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
;                                     ;Setup to Set FAC=10:
                LDA   #<CON_TEN       ;Get Address of Constant Ten (10), Low
                LDY   #>CON_TEN       ;Get Address of Constant Ten (10), High
; ----------------------------------- ;Compute FAC = ARG / [(A,Y)={Low,High}]:
                LDX   #0              ;Set as Flag for Adding Same Signed Values:
DIV             STX   SGNCPR          ;Set Sign Flag for Comparing
NON_SEQUITUR    JSR   UPAY2FAC        ;Unpack #@[(A,Y)={Low,High}] into FAC (=10)
                JMP   FDIVT           ;Divide ARG by FAC

; ------------------------------------------------------------------------------
; NON_SEQUITUR is an address used in the Generic CHRGET/CHRGOT subroutine that
; gets copied to Zero Page.  It changes on ZP, so it has no real meaning here.
; ------------------------------------------------------------------------------
; 
; 
; ==============================================================================
; "DIVIDE" ("/") Function
; ==============================================================================
; 
; Divide (Y,A) by FAC:                ;Compute FAC = (Y,A) / FAC:
FDIV            JSR   UPAY2ARG        ;Unpack FP# at [(A,Y)={Low,High}] into ARG
; ------------------------------------------------------------------------------
; FDIVT is Main Entry Point           ;(Math Operator Table Branch Address +1):
; ------------------------------------------------------------------------------
; Divide ARG by FAC:                  ;Compute FAC = ARG / FAC:
FDIVT           BEQ   DOZDIVERR       ;Throw a "?Division by Zero" Error if FAC=0
                JSR   ROUND_FAC       ;Else, Round FAC using MSB of FACEXT
; ----------------------------------- ;Negate FAC Exponent, so that ...
;                                     ;Add Exponents S/R forms Difference:
                LDA   #0              ;Clear Accumulator
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   FAC             ;Subtract FACX from Zero to get -FACX
                STA   FAC             ;Set FACX = -FACX
; ----------------------------------- ;Divide ARG by FAC [(FACX)=(ARGX)+(-FACX)]
                JSR   ADDEXPS         ;Add ARG & FAC Exponents [FACX=ARGX+FACX]
;                                     ;^[Checks for Overflow & Sets RESULT Sign]
                INC   FAC             ;Advance FAC Exponent [FACX=FACX+1]
                BEQ   JOV             ;Throw an "?Overflow" Error if FACX=0
                LDX   #$FC            ;Get/Set as Loop Index [($FC)=(-4)]
                LDA   #1              ;Get/Set as Bit Count & Partial Quotient
; ----------------------------------- ;Get Answer: Is ARG >= FAC?
;                                     ; (Can FAC Be Subtracted?)
;                                     ; (Can ARG be Divided by FAC?)
FDIVT1          LDY   ARG+1           ;Get ARG Mantissa, Top
                CPY   FAC+1           ;Compare to FAC Mantissa, Top
                BNE   FDIVT2          ;Branch if Not Equal .. (ARGT <> FACT)
                LDY   ARG+2           ;Get ARG Mantissa, High
                CPY   FAC+2           ;Compare to FAC Mantissa, High
                BNE   FDIVT2          ;Branch if Not Equal .. (ARGH <> FACH)
                LDY   ARG+3           ;Get ARG Mantissa, Middle
                CPY   FAC+3           ;Compare to FAC Mantissa, Middle
                BNE   FDIVT2          ;Branch if Not Equal .. (ARGM <> FACM)
                LDY   ARG+4           ;Get ARG Mantissa, Low
                CPY   FAC+4           ;Compare to FAC Mantissa, Low
;                                     ;NO Branch Here!  [for: (ARGL <> FACL)]
; ----------------------------------- ;Postpone Answer to: Is ARG >= FAC?
FDIVT2          PHP                   ;Push Processor Status
;                                     ;^[Carry is Set (C=1) if ARG >= FAC!] or
;                                     ;^[Carry is Set (C=1) if ARG Overflows!]
                ROL   A               ;Shift Left: Bit Count & Partial Quotient
                BCC   FDIVT3          ;Skip Following Until 8 Bits Done (C=1)
; ----------------------------------- ;Do Next Byte? Or, almost completely Done?
                INX                   ;Advance Loop Index
                STA   RESULT+3,X      ;Store a Quotient Byte
                BEQ   FDIVT6          ;Branch if Completed 5 Bytes (32 Bits)
;                                     ;^[Do Left Shfts into FAC Extensiion Byte]
                BPL   FDIVT7          ;EXIT if (X=1): Left Justify Extension Bits
; ----------------------------------- ;Get Answer: Is ARG >= FAC?
;                                     ; (Can FAC Be Subtracted?)
;                                     ; (Can ARG be Divided by FAC?)
                LDA   #1              ;Reset Bit Count & Partial Quotient
FDIVT3          PLP                   ;Pull Processor Status
                BCS   FDIVT5          ;BGE: Branch if ARG >= FAC (C=1)
;                                     ;^[YES, Go Subtract Divisor!]
; ----------------------------------- ;Else, Shift ARG Mantissa Left 1 Bit:
FDIVT4          ASL   ARG+4           ;Shift Left: ARG Mantissa, Low
                ROL   ARG+3           ;Shift Left: ARG Mantissa, Middle
                ROL   ARG+2           ;Shift Left: ARG Mantissa, High
                ROL   ARG+1           ;Shift Left: ARG Mantissa, Top
; ----------------------------------- ;Next, LOOP-Back for More Processing:
                BCS   FDIVT2          ;LOOP if (New) ARG Mantissa Overflows
                BMI   FDIVT1          ;LOOP if Further Comparison Needed
;                                     ;^[No Answer Yet: Is ARG >= FAC?
;                                     ; (Can FAC Be Subtracted?)
;                                     ; (Can ARG be Divided by FAC?)
                BPL   FDIVT2          ;LOOP if No Comparison Needed; Always Taken

; ----------------------------------- ;Subtract Divisor
;                                     ; (Subtract FAC from ARG, Once!)
;                                     ; [(ARG >= FAC) & (C=1)]:
FDIVT5          TAY                   ;Save Bit Count & Partial Quotient
;              ---------------------- ;Subtract w/o Borrow [A-Data-!C]:
                LDA   ARG+4           ;Get ARG Mantissa, Low
                SBC   FAC+4           ;Subtract FAC Mantissa, Low
                STA   ARG+4           ;Set ARG Mantissa, Low
;              ---------------------- ;Subtract with Borrow [A-Data-!C]:
                LDA   ARG+3           ;Get ARG Mantissa, Middle
                SBC   FAC+3           ;Subtract FAC Mantissa, Middle
                STA   ARG+3           ;Set ARG Mantissa, Middle
;              ---------------------- ;Subtract with Borrow [A-Data-!C]:
                LDA   ARG+2           ;Get ARG Mantissa, High
                SBC   FAC+2           ;Subtract FAC Mantissa, High
                STA   ARG+2           ;Set ARG Mantissa, High
;              ---------------------- ;Subtract with Borrow [A-Data-!C]:
                LDA   ARG+1           ;Get ARG Mantissa, Top
                SBC   FAC+1           ;Subtract FAC Mantissa, Top
                STA   ARG+1           ;Set ARG Mantissa, Top
;              ---------------------- ;Do Next:
                TYA                   ;Retrieve Bit Count & Partial Quotient
                JMP   FDIVT4          ;LOOP: Shift ARG Mantissa Left 1 Bit & LOOP

; ----------------------------------- ;Completed 5 Bytes (32 Bits):
FDIVT6          LDA   #%01000000      ;Set Extension Bit Count; (Two Left Shifts
;                                     ;into the FAC Extensiion Byte for the Last
;                                     ;Subtraction to Complete Division [x/4])
                BNE   FDIVT3          ;Always Taken

; ----------------------------------- ;Left Justify Extension Bits [in (Acc)];
;                                     ;(a 6 Bit Shift) [%XX000000<-%000000XX]:
FDIVT7          ASL   A               ;1. Shift Left: Accumulator
                ASL   A               ;2. Shift Left: Accumulator
                ASL   A               ;3. Shift Left: Accumulator
                ASL   A               ;4. Shift Left: Accumulator
                ASL   A               ;5. Shift Left: Accumulator
                ASL   A               ;6. Shift Left: Accumulator
                STA   FACEXT          ;Set FAC Extra Precision Byte
                PLP                   ;Pull Processor Status
; ----------------------------------- ;Finish with Final Quotient:
                JMP   CPY2FAC         ;Copy RESULT into FAC Mantissa, & Normalize

; ----------------------------------- ;Error Entry Point; Also User-Callable:
DOZDIVERR       LDX   #ERR_ZERODIV    ;Throw a "?Division by Zero" Error:
                JMP   ERROR           ;Go Print Error Message based on X-Reg

; ==============================================================================
; Copy RESULT (another Mantissa) into FAC Mantissa, & Normalize
; ==============================================================================
; 
CPY2FAC         LDA   RESULT          ;Get RESULT Mantissa, Top
                STA   FAC+1           ;Set FAC Mantissa, Top
                LDA   RESULT+1        ;Get RESULT Mantissa, High
                STA   FAC+2           ;Set FAC Mantissa, High
                LDA   RESULT+2        ;Get RESULT Mantissa, Middle
                STA   FAC+3           ;Set FAC Mantissa, Middle
                LDA   RESULT+3        ;Get RESULT Mantissa, Low
                STA   FAC+4           ;Set FAC Mantissa, Low
                JMP   NRMLZFAC2       ;Go Normalize Value in FAC

; ==============================================================================
; Unpack Floating Point Number at [(A,Y)={Low,High}]
; into FAC (Primary Floating Point Accumulator)
; ==============================================================================
; [Wouldn't a general purpose copier S/R (using pointers & loops) be better?
;  --Especially for all the Applesoft S/R's that move things like this one?]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Unpack FP# at [(A,Y)={Lo,Hi}] into FAC:
UPAY2FAC        STA   INDEX           ;Set as NUMBER Pointer, Low
                STY   INDEX+1         ;Set as NUMBER Pointer, High
                LDY   #4              ;Set Y-Index [=4] to Count Down Moves
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Low
                STA   FAC+4           ;Set FAC Mantissa, Low
                DEY                   ;Reduce Y-Index [=3]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Middle
                STA   FAC+3           ;Set FAC Mantissa, Middle
                DEY                   ;Reduce Y-Index [=2]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, High
                STA   FAC+2           ;Set FAC Mantissa, High
                DEY                   ;Reduce Y-Index [=1]
                LDA   (INDEX),Y       ;Get NUMBER Mantissa, Top
;                                     ;Unpack Floating Point Number:
                STA   FACSIGN         ;Set FAC Unpacked Sign (msb)
;                                     ;Complete FAC Mantissa, Top:
                ORA   #%10000000      ;Set Normalized Invisible Bit (msb)
                STA   FAC+1           ;Set FAC Mantissa, Top
                DEY                   ;Reduce Y-Index [=0]
                LDA   (INDEX),Y       ;Get NUMBER Exponent
                STA   FAC             ;Set FAC Exponent
                STY   FACEXT          ;Clear FAC Extra Precision Byte
                RTS                   ;Return [(A)=(FAC Exponent)] to Caller

; ==============================================================================
; Pack FAC into TEMP2 [FAC/ARG Save Area ($98~$9B)]: Store FAC Rounded in TEMP2
; ==============================================================================
; 
; ----------------------------------- ;Get Destination Address:
FACRND2TMP2     LDX   #TEMP2          ;Get Zero-Page Address of TEMP2, Low
                DFB   BIT_ABS         ;Fake BIT OpCode to skip next line

; ==============================================================================
; Pack FAC into TEMP1 [FAC/ARG Save Area ($93~$97)]: Store FAC Rounded in TEMP1
; ==============================================================================
; 
; ----------------------------------- ;Get Destination Address:
FACRND2TMP1     LDX   #TEMP1          ;Get Zero-Page Address of TEMP1, Low
                LDY   #>TEMP1         ;Get Zero-Page Address of TEMP1, High
;                                     ;^[(TEMP1, Hi)=(TEMP2, Hi)=(Zero-Page)]
                BEQ   FACRND2XY       ;Always Taken

; ==============================================================================
; Pack FAC into (FORPNT): Store FAC Rounded at (FORPNT)
; ==============================================================================
; 
; ----------------------------------- ;Called by LET & NEXT:
SETFOR          LDX   FORPTR          ;Get Destination Address, Low
                LDY   FORPTR+1        ;Get Destination Address, High
; 
; ==============================================================================
; Pack FAC into [(X,Y)={Low,High}]: Store FAC Rounded at [(X,Y)={Low,High}]
; ==============================================================================
; 
FACRND2XY       JSR   ROUND_FAC       ;Round FAC using MS-Bit of FACEXT
                STX   INDEX           ;Set as Destination Pointer, Low
                STY   INDEX+1         ;Set as Destination Pointer, High
                LDY   #$04            ;Set Y-Index [=4] to Count Down Moves
                LDA   FAC+4           ;Get FAC Mantissa, Low
                STA   (INDEX),Y       ;Set Destination Mantissa, Low
                DEY                   ;Reduce Y-Index [=3]
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                STA   (INDEX),Y       ;Set Destination Mantissa, Middle
                DEY                   ;Reduce Y-Index [=2]
                LDA   FAC+2           ;Get FAC Mantissa, High
                STA   (INDEX),Y       ;Set Destination Mantissa, High
                DEY                   ;Reduce Y-Index [=1]
;              ---------------------- ;Pack Sign into Destination Mantissa, Top:
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                ORA   #%01111111      ;Set (AND Mask msb)=(FACSGN msb)
;                                     ;Pack Sign into FAC Value:
                AND   FAC+1           ;Set in (A): Sign Bit of FAC Mantissa, Top
                STA   (INDEX),Y       ;Set Destination Mantissa, Signed Top
;              ---------------------- ;Do Exponent:
                DEY                   ;Reduce Y-Index [=0]
                LDA   FAC             ;Get FAC Exponent
                STA   (INDEX),Y       ;Set Destination Exponent
                STY   FACEXT          ;Clear FAC Extra Precision Byte
                RTS                   ;Return [(A)=(FAC Exponent)] to Caller

; ==============================================================================
; Copy ARG into FAC
; ==============================================================================
; 
CPYARG2FAC      LDA   ARGSIGN         ;Get ARG Unpacked Sign (msb)
; Entry from "EXPONENT" (POWER) Function [to do Absolute Value (ABS) 1st]:
CPYARGFAC       STA   FACSIGN         ;Set FAC Unpacked Sign (msb)
                LDX   #5              ;Set X-Index [=5] to Count Down Moves
CA2FLOOP        LDA   ARG-1,X         ;Get ARG Value
                STA   FAC-1,X         ;Set FAC Value
                DEX                   ;Count Down Move
                BNE   CA2FLOOP        ;LOOP Until Done (X=0)
                STX   FACEXT          ;Clear FAC Extra Precision Byte
                RTS                   ;Return to Caller

; ==============================================================================
; Copy FAC into ARG (Rounded)
; ==============================================================================
; 
FACRND2ARG      JSR   ROUND_FAC       ;Round FAC using MS-Bit of FACEXT
; Entry from "EXP" (Exponent) Function [to Not Round FAC 1st]:
FAC2ARG         LDX   #6              ;Set X-Index [=6] to Count Down Moves
F2ALOOP         LDA   FAC-1,X         ;Get FAC Value
                STA   ARG-1,X         ;set ARG Value
                DEX                   ;Count Down Move
                BNE   F2ALOOP         ;LOOP Until Done (X=0)
                STX   FACEXT          ;Clear FAC Extra Precision Byte
BAS_RTS19       RTS                   ;Return to Caller

; ==============================================================================
; Round FAC using Most Significant Bit of FAC Extension Byte
; ==============================================================================
; 
; ----------------------------------- ;Round FAC using MS-Bit of FACEXT:
ROUND_FAC       LDA   FAC             ;Get FAC Exponent
                BEQ   BAS_RTS19       ;Branch if FACX=0 (Which means FAC=0 too!)
                ASL   FACEXT          ;Else, Shift Left: FAC Extra Precision Byte
                BCC   BAS_RTS19       ;Return to Caller if No Carryover into FAC
INCMAN          JSR   INCFACMAN       ;Else, Advance FAC Mantissa (Add Carryover)
                BNE   BAS_RTS19       ;Return to Caller if No Carryover
                JMP   FROUND          ;Else, Advance FAC Exponent (Add Carryover)

; ==============================================================================
; FAC Sign (Neg|0|Pos) Returns (A)=(-1|0|1)
; ==============================================================================
; 
SIGN            LDA   FAC             ;Get FAC Exponent
                BEQ   BAS_RTS20       ;Return (A = 0) to Caller if (FAC = 0)
SIGN1           LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
SIGN2           ROL   A               ;Shift Sign (msb) Left into Carry
                LDA   #$FF            ;Get a Negative One (-1) for (FAC < 0)
                BCS   BAS_RTS20       ;Return (A = -1) to Caller if (FAC < 0)
                LDA   #1              ;Get a Positive One (+1) for (FAC > 0)
BAS_RTS20       RTS                   ;Return (A = +1) to Caller (FAC > 0)

; ==============================================================================
; "SGN" (Sign) Function: Immediate & Deferred; Parameter SGN (Aexpr); Returns
; Sign of a Number (Aexpr); Sign of [(Neg|0|Pos) Aexpr], Returns (A)=(-1|0|1)
; ==============================================================================
; 
SGN             JSR   SIGN            ;FAC Sign (Neg|0|Pos) Returns (A)=(-1|0|1)
; ------------------------------------------------------------------------------
; Float Signed Integer in (A) into FAC:
; ------------------------------------------------------------------------------
FLOAT           STA   FAC+1           ;Set FAC Mantissa, Top
                LDA   #0              ;Clear Accumulator
                STA   FAC+2           ;Clear FAC Mantissa, High
                LDX   #$88            ;Use Exponent 2^9 (to Move DP 8 Bits Right)
; ------------------------------------------------------------------------------
; Float Unsigned Value in FAC+1,2:  ;Enter with: X-Reg = Exponent
; ------------------------------------------------------------------------------
;                                     ;Get (-FAC) Sign Bit into Carry Flag:
FLOAT1          LDA   FAC+1           ;Get FAC Mantissa, High
                EOR   #%11111111      ;Invert Bits (Negate)
                ROL   A               ;Set Carry if FAC is a Positive Number
; ------------------------------------------------------------------------------
; Float Unsigned Value in FAC+1,2:  ;Enter with: X-Reg = Exponent,
;                                     ;C=0 to Make Value Negative, or
;                                     ;C=1 to Make Value Positive
; ------------------------------------------------------------------------------
FLOAT2          LDA   #0              ;Clear Accumulator
                STA   FAC+4           ;Clear FAC Mantissa, Low
                STA   FAC+3           ;Clear FAC Mantissa, Middle
                STX   FAC             ;Set FAC Exponent (to Move DP 8 Bits Right)
                STA   FACEXT          ;Clear FAC Extra Precision Byte
                STA   FACSIGN         ;Clear FAC Unpacked Sign (msb)
                JMP   NRMLZFAC1       ;Go Normalize Value in FAC

; ==============================================================================
; "ABS" (Absolute Value) Function:  Immediate & Deferred; Parameter ABS (Aexpr);
;       Returns the Absolute Value of a Number (Aexpr): 
;       Absolute Value of [(Neg|Pos) Aexpr], Returns (A)=[(Pos) Aexpr]
; ==============================================================================
; 
ABS             LSR   FACSIGN         ;Make FAC [Unpacked Sign (msb)] Positive
                RTS                   ;Return to Caller

; ==============================================================================
; Compare FAC with Packed Number at [(A,Y)={Low,High}]; 
; Return (A)=(-1|0|1) as [(A,Y)={Low,High}] is (>|=|<) FAC, respectively
; ==============================================================================
; 
FCOMP           STA   DSTPTR          ;Set as NUMBER Pointer, Low
FCOMP2          STY   DSTPTR+1        ;Set as NUMBER Pointer, High
; ------------------------------------------------------------------------------
; ^^^^ Special Entry from NEXT [with NUMBER Pointer, Low (DSTPTR), already Set
;      to FOR Value STACK Address (in A-Reg) & STACK Page Address (1 in Y-Reg)]:
; ------------------------------------------------------------------------------
; 
; ==============================================================================
; Compare NUMBER to FAC:
; ==============================================================================
; 
                LDY   #0              ;Clear Indirect Addressing Index (=0)
                LDA   (DSTPTR),Y      ;Get NUMBER Exponent
                INY                   ;Advance Indirect Addressing Index (=1)
                TAX                   ;Save NUMBER Exponent (to Compare with FAC)
                BEQ   SIGN            ;Branch if NUMBER Exponent is Zero
;                                     ;^[This means the whole NUMBER = 0, too!]
;                                     ;^(SIGN S/R is Sufficient for Comparison)
;              ---------------------- ;Unpack & Compare Mantissas:
                LDA   (DSTPTR),Y      ;Get NUMBER Mantissa, Top
                EOR   FACSIGN         ;XOR with FAC Unpacked Sign (msb)
                BMI   SIGN1           ;Branch if Signs Not Equal
                CPX   FAC             ;Compare NUMBER to FAC, Exponents
                BNE   FCFINISH        ;Branch if Exponents Not Equal
                LDA   (DSTPTR),Y      ;Get NUMBER Mantissa, Top
                ORA   #%10000000      ;Make NUMBER Negative
                CMP   FAC+1           ;Compare NUMBER to FAC, Mantissa Tops
                BNE   FCFINISH        ;Branch if Mantissa Tops Not Equal
                INY                   ;Advance Indirect Addressing Index (=2)
                LDA   (DSTPTR),Y      ;Get NUMBER Mantissa, High
                CMP   FAC+2           ;Compare NUMBER to FAC, Mantissa Highs
                BNE   FCFINISH        ;Branch if Mantissa Highs Not Equal
                INY                   ;Advance Indirect Addressing Index (=3)
                LDA   (DSTPTR),Y      ;Get NUMBER Mantissa, Middle
                CMP   FAC+3           ;Compare NUMBER to FAC, Mantissa Middles
                BNE   FCFINISH        ;Branch if Mantissa Middles Not Equal
                INY                   ;Advance Indirect Addressing Index (=4)
;              ---------------------- ;Determine Carry for last Compare:
                LDA   #%01111111      ;FAKE Extra Precision Byte (for NUMBER)
                CMP   FACEXT          ;Compare FAKE to FAC, Extra Precision Bytes
;              ---------------------- ;Subtract with|without Borrow [A-Data-!C]:
                LDA   (DSTPTR),Y      ;Get NUMBER Mantissa, Low
                SBC   FAC+4           ;Compare NUMBER to FAC, Mantissa Lows
                BEQ   BAS_RTS21       ;Branch if Mantissa Lows are Equal
;                                     ;^[EXIT]: Both Numbers are Equal!
;                                     ;         (NUMBER=FAC), Return: (A=0)
;              ---------------------- ;^[Else]: The Numbers are Not Equal:
FCFINISH        LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                BCC   FCDONE          ;BLT: ABS(FAC) is Larger: Skip Negation
                EOR   #%11111111      ;Else, ABS(FAC) is Smaller: Invert Bits
; <<< ====================================================================== >>>
; <<< Above three lines can be shortened:                                    >>>
; <<< ---------------------------------------------------------------------- >>>
; <<< FCFINISH ROR                    ;Put Carry into Sign Bit               >>>
; <<<          EOR    FAC_SIGN        ;Toggle with Sign of FAC               >>>
; <<< ====================================================================== >>>
FCDONE          JMP   SIGN2           ;Go Convert (A) to (+1) or (-1)

; ==============================================================================
; Quick Greatest Integer Function: Convert Real in FAC to just its Integer Part!
; ==============================================================================
; Converts FP Value in FAC to an Integer Value in FAC Mantissa (FAC+1,2,3,4), by
; Shifting Right with FAC Sign Extension until all Fractional Bits are outed.
; ------------------------------------------------------------------------------
; Assumes FAC < (2^31 = $8000,0000): FAC Binary Mantissa's Most Significant Bit
; (msb) is Sign Bit, leaving 31 Value Bits, hense FAC's Upper Limit is (2^31).
; ------------------------------------------------------------------------------
; The Initial Exponent (of 2^31) for 32 Bits is [($20)+($80)]=($A0), so the FAC
; Exponent (FACX) must be less than ($A0).  Hense, if (FACX>=$A0) there are NO
; Fractional Bits to Shift Right, but if (FACX<$A0) there are, & (FACX-$A0)
; determines how many there are [as a Single Byte Negative Number; e.g., if
; (FACX=$99), (FACX-$A0)=($F9)=(-7), there are Seven Bits to Shift Right].
; ==============================================================================
; To see: "How Applesoft BASIC Floating Point Math, Constants, & FAC Behave",
;    see: "Call-A.P.P.L.E. In Depth #1: All About Applesoft", pages 52 to 54
; ==============================================================================
; 
QINT            LDA   FAC             ;Get FAC Exponent
                BEQ   QINT3           ;EXIT if FAC Exponent is Zero
;                                     ;^[This means the whole number = 0, too!]
; ----------------------------------- ;Get (-# Fractional Bits) for Shift Count:
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #$A0            ;Subtract #$A0 from FACX for Shift Count
                BIT   FACSIGN         ;Check FAC Unpacked Sign (msb)
                BPL   QINT1           ;Branch if Positive
;                                     ;Else, Negative, So Complement Mantissa
;                                     ; & Set Sign Extension for Shift:
                TAX                   ;Save (-# Fractional Bits) Shift Count
                LDA   #%11111111      ;Set All Bits in Byte (A) [for Shifting]
                STA   SHFTSGNX        ;Set FAC Right Shift Sign Extension
                JSR   TCFACMANT       ;Two's Complement FAC Mantissa (only)
                TXA                   ;Retrieve (-# Fractional Bits) Shift Count
QINT1           LDX   #FAC            ;Point at FAC for Shift Right Subroutine
                CMP   #$F9            ;More than 7 Bits to Shift?
;                                     ; (-# Fractional Bits)>[($F9)=(-7)]
                BPL   QINT2           ;NO: Do Short (<8b) Shift Right Subroutine
                JSR   SHFTRGHT        ;YES: Do Long (>7b) Shift Right Subroutine
                STY   SHFTSGNX        ;Y=0: Clear FAC Right Shift Sign Extension
BAS_RTS21       RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; QINT2: Short (< 8-Bits) Shift Right Subroutine
; ------------------------------------------------------------------------------
QINT2           TAY                   ;Save (-# Fractional Bits) Shift Count
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                AND   #%10000000      ;Get Sign Bit (msb) Only [in (A)]
;                                     ;Start Right Shift & Merge with Sign:
                LSR   FAC+1           ;Shift Right: FAC Mantissa, Top
                ORA   FAC+1           ;Merge with Sign: FAC Mantissa, Top
                STA   FAC+1           ;Set FAC Mantissa, Top
                JSR   SHFTRGHT4       ;Finsh Shifting FAC (Mantissa-H/M/L, etc.)
                STY   SHFTSGNX        ;Y=0: Clear FAC Right Shift Sign Extension
                RTS                   ;Return to Caller

; ==============================================================================
; "INT" Function: Immediate & Deferred; Parameter: INT (Aexpr);
;       Returns largest Integer <= Number (Aexpr) specified
; ==============================================================================
; Uses QINT to Convert FAC to Integer form, & then Floats the Integer again.
; <<< Faster: Why not simply Clear the Fractional Bits by Zeroing them? >>>
; ==============================================================================
; 
INT             LDA   FAC             ;Get FAC Exponent
                CMP   #$A0            ;Is (FACX<$A0) [32 Bit Mantissa Exponent]?
                BCS   BAS_RTS22       ;BGE: EXIT if NOT (FACX<$A0)
;                                     ;^[NO Fractional Bits if (FACX>=$A0)]
                JSR   QINT            ;Else, Convert FAC to (4 Byte) Integer
                STY   FACEXT          ;Y=0: Clear FAC Extra Precision Byte
                LDA   FACSIGN         ;Get [into (A)] FAC Unpacked Sign (msb)
                STY   FACSIGN         ;Y=0: Clear FAC Unpacked Sign (msb)
                EOR   #%10000000      ;Invert [in (A)] Sign Bit (msb) ONLY!
                ROL   A               ;Shift Sign Bit (msb) Left into Carry Flag
                LDA   #$A0            ;Get Initial 32 Bit Mantissa Exponent
                STA   FAC             ;Set FAC Exponent [for NO Fractional Bits]
                LDA   FAC+4           ;Get FAC Mantissa [Integer Form], Low
                STA   CHARAC          ;Save for EXP & POWER (FPWRT) Functions
;                                     ;Finish Conversion:
                JMP   NRMLZFAC1       ;Go Normalize Value in FAC

; ==============================================================================
; Clear FAC Mantissa [& (Y)] to Prepare it for the Integer Form:
; [(A=0); FAC Exponent is Zero, so the whole number is too!]
; ==============================================================================
; 
QINT3           STA   FAC+1           ;Clear FAC Mantissa, Top
                STA   FAC+2           ;Clear FAC Mantissa, High
                STA   FAC+3           ;Clear FAC Mantissa, Middle
                STA   FAC+4           ;Clear FAC Mantissa, Low
                TAY                   ;Clear Y-Index Register
BAS_RTS22       RTS                   ;Return to Caller

; ==============================================================================
; Evaluate Floating Point Number at TXTPTR: Convert String to FP Value in FAC
; ==============================================================================
; String is Pointed to by TXTPTR with its First Char Already Scanned by CHRGET;
; A-Reg = First Char  &  C=0 if Char [in (A)] is a Numeral
; ==============================================================================
; 
FIN             LDY   #0              ;Clear Y-Index Register
                LDX   #10             ;Get Range to Clear Working Area ($99..A3):
FINLOOP         STY   TMPEXP,X        ;TMPEXP, EXPON, DPFLG, EXPSGN, FAC, SERLEN
                DEX                   ;Reduce Range (X-Index Register)
                BPL   FINLOOP         ;LOOP Until All Clear
                BCC   FIN2NMRL        ;Branch if Char is a Numeral (C=0)
                CMP   #'-'            ;Is First Char [in (A)] a Minus Sign?
                BNE   FINPLUS?        ;NO (Leading Sign), Number is NOT Negative
;                                     ;YES (Leading Sign), Number is Negative:
                STX   SERLEN          ;X=$FF: SERLEN Holds Length of Series-1
                BEQ   FIN1EVAL        ;Always Taken

FINPLUS?        CMP   #'+'            ;Is First Char [in (A)] a Plus Sign?
                BNE   FIN3PDP?        ;NO (Leading Sign), but Number is Positive!
;                                     ;YES (Leading Sign), Number is Positive:
FIN1EVAL        JSR   CHRGET          ;Get Next Char/Token of String
FIN2NMRL        BCC   FIN9NMRL        ;Branch if Char is a Numeral (C=0)
FIN3PDP?        CMP   #'.'            ;Is Char [in (A)] a Decimal Point?
                BEQ   FINADJX         ;YES (Leading DP), Number is a Fraction:
                CMP   #'E'            ;NO, Is Char [in (A)] an Exponent Token?
                BNE   FIN7POSX        ;NO, So End of Number; EXIT
                JSR   CHRGET          ;YES, Get Next Char/Token of String
                BCC   FIN5NMRL        ;Branch if Char is a Numeral (C=0)
                CMP   #TOK_MINUS      ;Is Char [in (A)] a Minus Token?
                BEQ   FIN3NEGX        ;YES (Minus Token), Exponent is Negative
                CMP   #'-'            ;NO, Is Char [in (A)] a Minus Sign?
                BEQ   FIN3NEGX        ;YES (Minus Sign), Exponent is Negative
                CMP   #TOK_PLUS       ;NO, Is Char [in (A)] a Plus Token?
                BEQ   FIN4POSX        ;YES (Plus Token), Exponent is Positive
                CMP   #'+'            ;NO, Is Char [in (A)] a Plus Sign?
                BEQ   FIN4POSX        ;YES (Plus Sign), Exponent is Positive
                BNE   FIN6SGNX        ;NO, So End of Exponent; EXIT; Always Taken

FIN3NEGX        ROR   EXPSGN          ;C=1: Flag Negative Exponent
;                                     ;Else, Exponent is Positive:
FIN4POSX        JSR   CHRGET          ;Get Next Char/Token of Exponent
FIN5NMRL        BCC   GETEXP          ;Branch if Char is a Numeral (C=0)
FIN6SGNX        BIT   EXPSGN          ;Else, End of Number, Test Sign of Exponent
                BPL   FIN7POSX        ;Branch if Exponent is Positive
;                                     ;Else, Exponent is Negative; Negate it:
                LDA   #0              ;Clear Accumulator
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   EXPON           ;Subtract Saved Exponent
                JMP   FIN8ADJX        ;Go Complete Exponent Adjustment

; Found Decimal Point, so Number is a Fraction; Adjust Exponent & EXIT:
; 
FINADJX         ROR   DPFLG           ;C=1, Set Decimal Point Flag
                BIT   DPFLG           ;Test Flag for prior Decimal Point
                BVC   FIN1EVAL        ;LOOP if NO prior Decimal Point
; <<< ====================================================================== >>>
; <<< There should be a jump to to error here!  Multiple decimal points give >>>
; <<< strange results in PRINT statements.  Variable assignments correctly   >>>
; <<< give syntax errors; e.g., "A=11..22" will give a syntax error, because >>>
; <<< it is two numbers with no operator in between.  But, in a numeric      >>>
; <<< string, a second decimal point is taken as a terminator; e.g.,         >>>
; <<< "PRINT 11..22" gives no error, because it is just the concatenation of >>>
; <<< two numbers.                                                           >>>
; <<< ====================================================================== >>>
FIN7POSX        LDA   EXPON           ;Get Saved Exponent
;                                     ;Get Count of Numerals after Decimal Pt:
FIN8ADJX        SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   TMPEXP          ;Subtract Current Exponent Shift Count
                STA   EXPON           ;Complete/Save Current Adjusted Exponent
                BEQ   FIN8EVDN?       ;Branch if Exponent=0: No Adjust Needed
                BPL   FIN8DPR         ;Branch if Exponent>0: Multiply by Ten
FIN8DPL         JSR   DIV10           ;Else, Exponent<0, Divide by Ten
                INC   EXPON           ;Advance Exponent
                BNE   FIN8DPL         ;Branch Until Exponent=0
                BEQ   FIN8EVDN?       ;Done; Always Taken

FIN8DPR         JSR   MUL10           ;Exponent>0: Multiply by Ten
                DEC   EXPON           ;Reduce Exponent
                BNE   FIN8DPR         ;Branch Until Exponent=0
FIN8EVDN?       LDA   SERLEN          ;Is Whole Number Negative/Positive?
                BMI   FIN8EVD         ;Negative Number: Negate FAC
                RTS                   ;Positive Number: All Done! Return to Caller

FIN8EVD         JMP   NEGOP           ;Negative Number: Go Negate FAC

;                                     ;Accumulate a Numeral into FAC:
FIN9NMRL        PHA                   ;Push Numeral
                BIT   DPFLG           ;Was there a Decimal Point?
                BPL   FIN9X10         ;Branch if NOT
                INC   TMPEXP          ;Else, Advance Exponent Shift Count
FIN9X10         JSR   MUL10           ;Multiply by Ten (FAC=10*FAC)
                PLA                   ;Pull Numeral; Compensate for ASCII:
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
; <<< Shorter here to just "AND #$0F" to Convert ASCII to Binary Form: >>>
                SBC   #'0'            ;Subtract Low ASCII Zero; Mask 
                JSR   ADDACC          ;Accumulate (Add) Numeral
                JMP   FIN1EVAL        ;LOOP: Evaluate Next Char/Token of String

; ==============================================================================
; Accumulate Numeral into FAC Mantissa: Add FAC to (A) & Put back in FAC
; ==============================================================================
; 
ADDACC          PHA                   ;Push Addend
                JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
                PLA                   ;Pull Addend
                JSR   FLOAT           ;Float Signed Integer in (A) into FAC
                LDA   ARGSIGN         ;Get ARG Unpacked Sign (msb)
                EOR   FACSIGN         ;XOR FAC Unpacked Sign (msb)
                STA   SGNCPR          ;Set Sign Flag for Comparing
                LDX   FAC             ;Get Fax Exponent to Signal if FAC <>|= 0
                JMP   FADDT           ;Go Add FAC to ARG & Put back in FAC

; ==============================================================================
; Accumulate Numeral into FAC Exponent: Add FACX to (A) & Put back in FACX
; ==============================================================================
; 
GETEXP          LDA   EXPON           ;Get Saved Exponent
                CMP   #10             ;Is its Current Value > 2 Digits
                BCC   GETEXP1         ;NO, This is 1st or 2nd Digit
                LDA   #100            ;Exponent Too Big
                BIT   EXPSGN          ;Unless it is Negative
                BMI   GETEXP2         ;Large Negative Exponent makes FAC=0
                JMP   OVERFLOW        ;Large Positive Exponent is Error

;                                     ;Exponent Times 10:
GETEXP1         ASL   A               ;Exponent Times 2  . . . . . . . . .  [2X] 
                ASL   A               ;Exponent Times 2  . . . . . . . . .  [4X] 
                CLC                   ;Prepare for Add with Carry
                ADC   EXPON           ;Add Exponent  . . . . . . . . . . .  [5X] 
                ASL   A               ;Exponent Times 2  . . . . . . . . . [10X] 
                CLC                   ;Prepare for Add with Carry
                LDY   #0              ;Clear Indirect Addressing Index
                ADC   (TXTPTR),Y      ;Add the New Digit; Compensate for ASCII:
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
; <<< Shorter here to just "AND #$0F" to Convert ASCII to Binary Form: >>>
                SBC   #'0'            ;Subtract Low ASCII Zero; Mask 
;                                     ;REF:(Large Negative Exponent makes FAC=0)
GETEXP2         STA   EXPON           ;Set Saved Exponent
                JMP   FIN4POSX        ;Go Get Next Char/Token of Exponent

; ==============================================================================
; Really BIG Numbers                                      (Packed FAC Constants)
; ==============================================================================
; 
CON_1E8M1       HEX   9B3EBC1FFD      ;[Normalized]; ((10^8)-.1)=(99,999,999.9)
;   1E8M1                             ;<-[M1 means -.1,  9 nines: 99,999,999.9]
CON_1E9M1       HEX   9E6E6B27FD      ;[Normalized]; ((10^9)-1) = (999,999,999)
;   1E9M1                             ;<-[M1 means -1, nine nines: 999,999,999]
CON_1E9         HEX   9E6E6B2800      ;[Normalized];  (10^9)   =(1,000,000,000)

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit: 
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_E8M1 HEX 9B3EBC1FFD |(00) |$9B-$80=$18=+24 |$.3EBC1FFD |+3.28911359E+7
; (!) POS_E8M1 HEX 9BBEBC1FFD |(00) |$9B-$80=$18=+24 |$.BEBC1FFD |+9.99999999E+7
; (!) NEG_E8M1 HEX 9BBEBC1FFD |(FF) |$9B-$80=$18=+24 |$.BEBC1FFD |-9.99999999E+7
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_E9M1 HEX 9E6E6B27FD |(00) |$9E-$80=$1E=+30 |$.6E6B27FD |+4.63129087E+8
; (!) POS_E9M1 HEX 9EEE6B27FD |(00) |$9E-$80=$1E=+30 |$.EE6B27FD |+9.99999999E+8
; (!) NEG_E9M1 HEX 9EEE6B27FD |(FF) |$9E-$80=$1E=+30 |$.EE6B27FD |-9.99999999E+8
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_E9   HEX 9E6E6B2800 |(00) |$9E-$80=$1E=+30 |$.6E6B2800 |+4.63129088E+8
; (!) POS_E9   HEX 9EEE6B2800 |(00) |$9E-$80=$1E=+30 |$.EE6B2800 |+1.00000000E+9
; (!) NEG_E9   HEX 9EEE6B2800 |(FF) |$9E-$80=$1E=+30 |$.EE6B2800 |-1.00000000E+9
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; Print Line Number
; ==============================================================================
; 
; ----------------------------------- ;Print " IN <LINE #>":
INPRT           LDA   #<QT_IN         ;Get " IN " Zero-String Address, Low
                LDY   #>QT_IN         ;Get " IN " Zero-String Address, High
                JSR   PRINTSTR        ;Print String starting at [(A,Y)={Low,High}]
                LDA   CURLIN+1        ;Get Current Applesoft Line Number, High
                LDX   CURLIN          ;Get Current Applesoft Line Number, Low
; ----------------------------------- ;Print Decimal Integer at [(X,A)={Lo,Hi}]
LINPRT          STA   FAC+1           ;Set FAC Mantissa, Top
                STX   FAC+2           ;Set FAC Mantissa, High
;                                     ;^[FLOAT2 Clears FAC Mantissa, Mid & Low]
                LDX   #$90            ;Set Exponent to 2^16 =65,536 =%0001,0000
;                                     ;FAC FP#, So Set High Bit: $90=%1001,0000
;                                     ;(Shifts Decimal Pt 16-bits to the Right)
                SEC                   ;Flag to Float (FAC+1,2) as Positive Number
                JSR   FLOAT2          ;Float Unsigned: [(X)->(FACX), (FAC+1,2)]
; ----------------------------------- ;Print FAC (User-Callable Entry Point):
PRINTFAC        JSR   FOUT            ;Convert Number in FAC to String & Print It
PRINTSTR        JMP   STROUT          ;Print String starting at [(A,Y)={Low,High}]

; ==============================================================================
; Convert FAC to a Zero-String starting at STACK [or at FOUTBUFF (STACK-1)]; 
; Return with [(A,Y)={Low,High}] Pointing at Zero-String:
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; Normal Entry Point, so that resultant Zero-String starts at STACK [$100]:
; ------------------------------------------------------------------------------
; 
FOUT            LDY   #1              ;Set Indirect Addressing Index, Advanced 1
; 
; ------------------------------------------------------------------------------
; STR$ Function Enters Here, with (Y=0), so that resultant Zero-String starts at
; FOUTBUFF (STACK-1) [$FF] {to Force movment of the String to String-Space}
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Convert FAC to Zero-String in FOUT-Buff:
FOUT1           LDA   #'-'            ;Flag (Sign) in case FAC is Negative
                DEY                   ;Reduce Indirect Addressing Y-Index
;                                     ;^[Entry at FOUT, (Y)=(1 ->  0):(STACK);
;                                     ; Entry at FOUT1, (Y)=(0 -> -1):(STACK-1)]
                BIT   FACSIGN         ;Test FAC Unpacked Sign (msb)
                BPL   FOUTPOS         ;Branch if FAC is Positive
;                                     ;Else, FAC is Negative:
                INY                   ;Advance Indirect Addressing Y-Index
;                                     ;^[Entry at FOUT, (Y)=( 0 -> 1):(STACK);
;                                     ; Entry at FOUT1, (Y)=(-1 -> 0):(STACK-1)]
                STA   FOUTBUFF,Y      ;Make Minus Sign 1st Char of String
;                                     ;^[Forces move to String-Space if Y=0]
FOUTPOS         STA   FACSIGN         ;Set FAC Unpacked Sign (msb) [$2D=Positive]
                STY   STRNG2          ;Save Indirect Addressing Y-Index
;                                     ;^[Index into Output String (BEING BUILT)]
                INY                   ;Advance Indirect Addressing Y-Index
                LDA   #'0'            ;Get a Low ASCII Zero in case FAC=0
                LDX   FAC             ;Get FAC Exponent [FAC<>|=0?]
                BNE   FOUTNOT0        ;Branch if FAC (Exponent) is NOT Zero
                JMP   FOUTFIN         ;Else, FAC (Exponent) is Zero, So Finish Up

FOUTNOT0        LDA   #0              ;Clear (A) [Starting Value for TMPEXP]
;                                     ;  ^[TMPEXP is Exponent Shift Counter]
                CPX   #$80            ;   Is the FAC Exponent>=128? [FAC>=1?]
                BEQ   FOUTIS1         ;Branch if FAC Exponent =128. [FAC =1.]
                BCS   FOUTMORE        ;Branch if FAC Exponent>=128. [FAC>=1.]
;                                     ;Else, the FAC Exponent< 128. [FAC< 1.]
FOUTIS1         LDA   #<CON_1E9       ;Get Address of Constant 1E9, Low
                LDY   #>CON_1E9       ;Get Address of Constant 1E9, High
                JSR   FMULT           ;Move Decimal Point: FAC=FAC*[(A,Y)={L,H}]
;                     ^^^^^---------- ;<<< Because of bug in FMULT, ... >>>
                LDA   #$F7            ;Fix Exponent for more speed: [(Exp)=(-9)]
FOUTMORE        STA   TMPEXP          ;Set Shift Counter: (TMPEXP)=[(0) or (-9)]
; ----------------------------------- ;Adjust until 1E8<=FAC<1E9; Normalize 
; (Outer Loop)                        ;between [100,000,000 & 999,999,999]:
FOUTADJ1        LDA   #<CON_1E9M1     ;Get Address of Constant 1E9-1, Low
                LDY   #>CON_1E9M1     ;Get Address of Constant 1E9-1, High
                JSR   FCOMP           ;Compare FAC with Packed Number at (A,Y) ^
;                                     ;Rtns: (A)=(-1|0|1)<--[FAC (<|=|>) (A,Y)]
                BEQ   FOUTINRNG2      ;Branch if FAC=1E9-1; In Range, EXIT LOOP
                BPL   FOUTLARGE       ;Branch if FAC>1E9-1; Too Large, Do FAC/10
; (Inner Loop) ---------------------- ;Else, ... FAC<1E9-1; Test Lower Limit:
FOUTADJ2        LDA   #<CON_1E8M1     ;Get Address of Constant 1E8-.1, Low
                LDY   #>CON_1E8M1     ;Get Address of Constant 1E8-.1, High
                JSR   FCOMP           ;Compare FAC with Packed Number at (A,Y) ^
;                                     ;Rtns: (A)=(-1|0|1)<--[FAC (<|=|>) (A,Y)]
                BEQ   FOUTSMALL       ;Branch if FAC=1E8-.1; Too Small, Do FAC*10
                BPL   FOUTINRNG1      ;Branch if FAC>1E8-.1; In Range, EXIT LOOP
;              ---------------------- ;Else, FAC<1E8-.1; Too Small, Do FAC*10:
FOUTSMALL       JSR   MUL10           ;Too Small, Multiply FAC by Ten
                DEC   TMPEXP          ;Keep Track of Multiplies (Shift Count)
                BNE   FOUTADJ2        ;LOOP until 1E8 <= FAC < 1E9; Always Taken
;              ---------------------- ;Else, FAC>1E9-1; Too Large, Do FAC/10:
FOUTLARGE       JSR   DIV10           ;Too Large, Divide FAC by Ten
                INC   TMPEXP          ;Keep Track of Divisions (Shift Count)
                BNE   FOUTADJ1        ;LOOP until 1E8 <= FAC < 1E9; Always Taken
; ------------------------------------------------------------------------------
; Round, Convert, & Print (Long Integer) FAC:
; ------------------------------------------------------------------------------
FOUTINRNG1      JSR   FADDH           ;Round FAC
FOUTINRNG2      JSR   QINT            ;Convert FAC to (4 Byte) Integer
; ------------------------------------------------------------------------------
; FAC Mantissa is now in Integer Form with Power of Ten Adjustment in TMPEXP;
; If -10 < TMPEXP < 1, Print in Decimal Form; Else, Print in Exponential Form:
; ------------------------------------------------------------------------------
                LDX   #1              ;Preset Decimal Point Pointer
;                                     ;^[Assume 1 Numeral before Decimal Point]
;                                     ;Check Range: [(-10)<(TMPEXP)<(1)]
                LDA   TMPEXP          ;Get FAC Exponent Shift Count
                CLC                   ;Prepare for Add with Carry
                ADC   #10             ;Add Ten [(A)=(TMPEXP+10)]:[(0)<(A)<(11)]?
                BMI   FOUTXF1         ;Branch if [(TMPEXP)<=(-10)]:[(A)<(0)]
;                                     ;^[(FAC<.01): Use Exponential Form]
                CMP   #11             ;Is [(-10)<(TMPEXP)<(1)]:[(0)<(A)<(11)]?
                BCS   FOUTXF2         ;Branch if [(TMPEXP)>=(1)]:[(A)>=(11)]
;                                     ;^[(FAC>=1E10): Use Exponential Form]
;                                     ;C=0: Subtract with Borrow [A-Data-!C]
;                                     ; or: Add with Carry [A+Data+C] (same):
                ADC   #$FF            ;Subtract 1 to Get Decimal Point Pointer
                TAX                   ;Set Decimal Point Pointer
; ----------------------------------- ;Compute Correct/Remaining Exponent:
                LDA   #2              ;Preset Remaining Exponent, Advanced
FOUTXF1         SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
FOUTXF2         SBC   #2              ;Subtract Advanced Preset
                STA   EXPON           ;Set Remaining Exponent = 0
                STX   TMPEXP          ;Save Decimal Point Pointer
;                                     ;^[Replaces FACX Shift Count]
                TXA                   ;Get Decimal Point Pointer
;                                     ;^[Number of Numerals before Decimal Pt]
                BEQ   FOUTPDP         ;Branch if Decimal Point is 1st (at Start)
                BPL   FOUTMKS         ;Branch if NO Decimal Point at Start
; ----------------------------------- ;Place Decimal Point in String:
FOUTPDP         LDY   STRNG2          ;Retrieve Saved Indirect Addressing Y-Index
;                                     ;^[Index into Output String (BEING BUILT)]
                LDA   #'.'            ;Get a Decimal Point Character
                INY                   ;Advance Indirect Addressing Y-Index
                STA   FOUTBUFF,Y      ;Place a Decimal Point Character in String
                TXA                   ;Get Decimal Point Pointer
                BEQ   FOUTSVY         ;Branch if Decimal Point is 1st (at Start)
                LDA   #'0'            ;Get a Zero Character
                INY                   ;Advance Indirect Addressing Y-Index
                STA   FOUTBUFF,Y      ;Place a Zero Character in String
; ----------------------------------- ;Decimal Point is 1st (at Start):
FOUTSVY         STY   STRNG2          ;Save Indirect Addressing Y-Index
;                                     ;^[Output String Character Pointer]
; ----------------------------------- ;NO Decimal Point at Start:
; Make String                       ;Zero in on Number while Building String:
FOUTMKS         LDY   #0              ;Clear Indirect Addressing Y-Index
;                                     ;Y-Index = Pointer to Powers
                LDX   #$80            ;Starting Value for Numeral [w/o (msb)]
;                                     ;^[& (+|-) Direction/Instruction (msb)]:
;                                     ;^[& (+|-) Add-to/Subtract-frm FAC Mant]
; ----------------------------------- ;Divide by Powers of 10 to get Numerals:
; Make String Loop                    ;Start by Adding -1E8 (from DECTBL) until 
;                                     ;Overshoot; Then Add +1E7, Then Add -1E6, 
;                                     ;Then Add +1E5, & ... (Alternating Signs);
;                                     ;The Number of times each Power is Added
;                                     ;is 1 more than corresponding Numeral (*);
;                                     ;Get 4 Power-Data-Bytes/Cycle in sequence:
FOUT2LOOP       LDA   FAC+4           ;Get FAC Mantissa, Low
                CLC                   ;Prepare for Add with Carry
                ADC   DECTBL+3,Y      ;Add Power Data, Low
                STA   FAC+4           ;Set FAC Mantissa, Low
                LDA   FAC+3           ;Get FAC Mantissa, Middle
                ADC   DECTBL+2,Y      ;Add Power Data, Middle
                STA   FAC+3           ;Set FAC Mantissa, Middle
                LDA   FAC+2           ;Get FAC Mantissa, High
                ADC   DECTBL+1,Y      ;Add Power Data, High
                STA   FAC+2           ;Set FAC Mantissa, High
                LDA   FAC+1           ;Get FAC Mantissa, Top
                ADC   DECTBL,Y        ;Add Power Data, Top
                STA   FAC+1           ;Set FAC Mantissa, Top
;              -------- NEXT -------- ;Carry & X Now Control (+|-) Loop Activity
                INX                   ;Advance Counter: Numeral Value [w/o (msb)]
;              ---------------------- ;(C=1); Stop Adding If X is Positive:
                BCS   FOUT2LPND       ;(C=1); Branch if FAC Mantissa Overflowed
;              ---------------------- ;(C=0); Keep Adding If X is Positive:
                BPL   FOUT2LOOP       ;(C=0); LOOP if [(X)>=(0)]
;              ---------------------- ;(C=0); Stop Adding If X is Negative:
;                                     ;       [Overshot Lower Limit]
                BMI   FOUTCNTD        ;(C=0); Branch if [(X)<(0)]; Always Taken

;              ---------------------- ;FAC Mantissa Overflowed:
;                                     ;(C=1); Keep Adding If X is Negative:
FOUT2LPND       BMI   FOUT2LOOP       ;(C=1); LOOP if [(X)<(0)]
;                                     ;(C=1); Stop Adding If X is Positive:
;                                     ;       [Overshot Upper Limit]
; ----------------------------------- ;End of Inner Make String Loop (FOUT2LOOP)
; Counted                             ;Make X into a Numeral;
;                                     ;How depends on last Direction:
FOUTCNTD        TXA                   ;Get Count: Numeral Value [w/o (msb)]
                BCC   FOUTNMRL        ;Branch if Overshot Lower Limit
;                                     ;Else, Overshot Upper Limit;
;                                     ;Adjust Count for Positive case:
                EOR   #%11111111      ;Invert Bits (Negate)
;                                     ;Add with Carry Set (C=1):
                ADC   #10             ;Numeral=10+C-X; (*) Remember X is One Up!
FOUTNMRL        ADC   #'/'            ;Convert Count to ASCII Numeral
;                                     ;Advance to Next Smaller Power of Ten:
                INY                   ;Advance Indirect Addressing Y-Index (*4)
                INY                   ;[4 times to get 4 Power Data Bytes/Cycle
                INY                   ;Sequencially from the Powers of 10
                INY                   ;(Decimal/Hexadecimal Constants) Table]
                STY   VARPTR          ;Save Y-Index: Pointer to Powers
                LDY   STRNG2          ;Get Output String Character Pointer
                INY                   ;Advance Output String Character Pointer
                TAX                   ;Save ASCII Numeral, (msb) is Direction
                AND   #%01111111      ;Assure it's Low ASCII, $30..39, for String
                STA   FOUTBUFF,Y      ;Place Low ASCII Numeral into Output String
                DEC   TMPEXP          ;Count Numeral; Adjust Decimal Point Pointer
                BNE   FOUTSKPDP       ;Branch if Not yet Time for Decimal Point
                LDA   #'.'            ;Else, Time for Decimal Point, Get One
                INY                   ;Advance Output String Character Pointer
                STA   FOUTBUFF,Y      ;Place Decimal Point into Output String
FOUTSKPDP       STY   STRNG2          ;Save Output String Character Pointer
                LDY   VARPTR          ;Retrieve Saved Pointer to Powers
                TXA                   ;Retrieve ASCII Numeral, (msb) is Direction
;                                     ;Change Dir: Adding=0, Subtracting=$80
;                                     ;(Invert Specified Bits by XOR-Mask):
                EOR   #%11111111      ;Invert Bits (Negate) [Toggle Sign]
;                                     ;(Select Specified Bits by AND-Mask):
                AND   #%10000000      ;Keep Negated Sign & Discard Negated Value
                TAX                   ;Save Direction: Adding=0, Subtracting=$80
;                                     ;Done Adding & Subtracting Yet?
                CPY   #36             ;[DECTBLEND-DECTBL]=[$EE8D-$EE69]=[$24]=[36]
;                                     ;Also: [4 Bytes/Const * 9 Cons]=[36]
                BNE   FOUT2LOOP       ;LOOP Until Done Adding & Subtracting
; ----------------------------------- ;End of Outer Make String Loop (FOUT2LOOP)
;                                     ;Nine Numerals were Placeed in String; 
;                                     ;Truncate Trailing: Zeroes & Decimal Point
                LDY   STRNG2          ;Retrieve Output String Character Pointer
FOUTMVBK        LDA   FOUTBUFF,Y      ;Get (Y) Character Placed in Output String
                DEY                   ;Reduce Output String Character Pointer
                CMP   #'0'            ;Was Last Character Got a Zero?
                BEQ   FOUTMVBK        ;Branch to Suppress Trailing Zero
                CMP   #'.'            ;Was Last Character Got a Decimal Point?
                BEQ   FOUTNEEDX       ;Branch to Overwrite Trailing Decimal Point
;                                     ;Else, Not Decimal Point, so Keep Numeral:
                INY                   ;Advance Output String Character Pointer
FOUTNEEDX       LDA   #'+'            ;Prepare for Positive Exponent "E+##"
                LDX   EXPON           ;Get Exponent from Safe
                BEQ   FOUTMKND        ;Branch if NO Exponent (A=0)
                BPL   FOUTPUTX        ;Branch if Exponent is Positive (A>0)
;                                     ;Else, Exponent is Negative (A<0)
                LDA   #0              ;Prepare to Negate Exponent (0-EXPON)
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   EXPON           ;Subtract to Negate Exponent (0-EXPON)
                TAX                   ;Save Negated Exponent: (X)=(-EXPON)
                LDA   #'-'            ;Get a Minus Sign
FOUTPUTX        STA   FOUTBUFF+2,Y    ;Place Minus Sign into Output String [E-##]
                LDA   #'E'            ;Get an "E" (Exponent) Sign
                STA   FOUTBUFF+1,Y    ;Place "E" Sign into Output String [E-##]
                TXA                   ;Retrieve Negated Exponent: (A=X)=(-EXPON)
                LDX   #'/'            ;=("0"-1); Convert to Decimal [Lower Limit]
;                                     ;[ASCII Sequence: /,0,1,2,3,4,5,6,7,8,9,:]
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
FOUTWHATX       INX                   ;Count Subtraction (from Negated Exponent)
                SBC   #10             ;Subtract 10 (for Exponent Ten's Place)
                BCS   FOUTWHATX       ;BGT: Branch if More Tens to Subtract
;                                     ;Do Remainder (for Exponent One's Place):
                ADC   #':'            ;=("9"+1); Convert to Decimal [Upper Limit]
;                                     ;[ASCII Sequence: /,0,1,2,3,4,5,6,7,8,9,:]
                STA   FOUTBUFF+4,Y    ;Place into String at Exponent One's Place
                TXA                   ;Get Exponent Ten's Place Subtraction Count
                STA   FOUTBUFF+3,Y    ;Place into String at Exponent Ten's Place
                LDA   #$00            ;Get a Zero ($00) to Terminate Z-String
                STA   FOUTBUFF+5,Y    ;Place Zero at End of String
                BEQ   FOUTPTSTK       ;Always Taken

;                                     ;FAC (Exponent) is Zero, So Finish Up:
FOUTFIN         STA   FOUTBUFF,Y      ;Place ASCII "0" into String at (Y) Position
;                                     ;Just Mark End of String:
FOUTMKND        LDA   #$00            ;Get a Zero ($00) to Terminate Z-String
                STA   FOUTBUFF+1,Y    ;Place Zero at End of String
;                                     ;Point at Start of String:
FOUTPTSTK       LDA   #<STACK         ;Apple-II 6502 Microprocessor Stack, Low
                LDY   #>STACK         ;Apple-II 6502 Microprocessor Stack, High
;                                     ;-----------------------------------------
;                                     ;^ STR$ Starts STRING at FOUTBUFF (STK-1),
;                                     ;  but STR$ doesn't use [(A,Y)={Lo,Hi}],
;                                     ;  so using STACK here is okay!
;                                     ;-----------------------------------------
                RTS                   ;Return to Caller

; ==============================================================================
; The Number One Half (1/2)                                (Packed FAC Constant)
; ==============================================================================
; 
CON_HALF        HEX   8000000000      ;<-[Normalized]; (1/2)=(0.500)
; 
; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_HALF HEX 8000000000 |(00) |$80-$80=$00= +0 |$.00000000 |+5.00000000E-1
; (!) POS_HALF HEX 8080000000 |(00) |$80-$80=$00= +0 |$.80000000 |+5.00000000E-1
; (!) NEG_HALF HEX 8080000000 |(FF) |$80-$80=$00= +0 |$.80000000 |-5.00000000E-1
; ------------------------------------------------------------------------------
; <<< Plugging NRM_HALF into & Printing FAC ($ED2EG) results in nothing printed!
; --Seems that when the mantissa is zero there's a problem printing numbers. >>>
; ==============================================================================
; 
; 
; ==============================================================================
; Powers of 10: (Decimal/Hexadecimal Constants) <<<[NOT Packed FAC Constants]>>>
; ==============================================================================
;        From 1E+8 down to 1, as 32-bit integers, with alternating signs:
;            %(s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;         Hexadecimal Constant        |   Decimal  | ^Exp |   Qword   |  Word
; ------------------------------------|------------|------|-----------|---------
DECTBL          HEX   FA0A1F00        ;-100,000,000= -1E+8 =$FFFF,FFFF,FA0A,1F00
                HEX   00989680        ; +10,000,000= +1E+7 =$0000,0000,0098,9680
                HEX   FFF0BDC0        ;. -1,000,000= -1E+6 =$FFFF,FFFF,FFF0,BDC0
                HEX   000186A0        ;... +100,000= +1E+5 =$0000,0000,0001,86A0
                HEX   FFFFD8F0        ;.... -10,000= -1E+4 =$FFFF,FFFF,FFFF,D8F0
                HEX   000003E8        ;..... +1,000= +1E+3 =$0000,0000,0000,03E8
                HEX   FFFFFF9C        ;....... -100= -1E+2 =$FFFF,FFFF,FFFF,FF9C
                HEX   0000000A        ;........ +10= +1E+1 =$0000,0000,0000,000A
                HEX   FFFFFFFF        ;......... -1= -1E+0 =$FFFF,FFFF,FFFF,FFFF

; ------------------------------------------------------------------------------
; DECTBLEND    EQU    *             ;$EE8D
; ==============================================================================
; 
; ==============================================================================
; "SQR" Square Root Function: Immediate & Deferred; Parameter: SQR (Aexpr);
; Returns Positive Square Root of a Number (Aexpr); This uses exponentiation
; SQR(x) = x^.5, rather than a Newton-Raphson iteration, but this special
; implementation is faster than the normal one. 
; ==============================================================================
; 
SQR             JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
;                                     ;Point at Constant: (1/2)=(0.500)
                LDA   #<CON_HALF      ;Get Address for Constant, Low
                LDY   #>CON_HALF      ;Get Address for Constant, High
                JSR   UPAY2FAC        ;Unpack FP# at [(A,Y)={Low,High}] into FAC
;                                     ;[Drop into Power Function]
; 
; ==============================================================================
; "EXPONENT" [POWER] Function: FAC=ARG^FAC
; ==============================================================================
; This is the Exponentiation ("^") Operator, NOT the "EXP" Exponent Function! 
; But, if the accumulator is zero upon entry here, this routine branches to the
; "EXP" Exponent Function routine.
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
FPWRT           BEQ   EXP             ;Branch to "EXP" Function if (A=0)
;                                     ;^[if FAC=0, ARG^FAC=EXP(0)]
                LDA   ARG             ;Get ARG Exponent 
                BNE   FPWRT1          ;Branch if ARG (Exponent) is Not Zero
;                                     ;Else [if ARG=0, ARG^FAC=0], ...
                JMP   ZFACSGNEXP      ;Go Set FAC Signed Exponent & Sign

; ------------------------------------------------------------------------------
; Exponentiation Operation:
; [BASE^POWER]=[ARG^FAC]=[EXP((LOG(ABS(ARG))*FAC)*ARGSIGN)]
; ------------------------------------------------------------------------------
; 
;              ---------------------- ;Save FAC [POWER] in TEMP3:
FPWRT1          LDX   #TEMP3          ;Get Destination Address, Low
                LDY   #>TEMP3         ;Get Destination Address, High
                JSR   FACRND2XY       ;Pack FAC (Rounded) into [(X,Y)={Low,High}]
;              ---------------------- ;Normally, ARG [BASE] must be Positive:
                LDA   ARGSIGN         ;Get ARG Unpacked Sign (msb)
                BPL   FPWRT2          ;Branch if ARG is Positive (OK)
;              ---------------------- ;Else, ARG is Negative (OK if Int Power)
;                                     ;Check if it's an Integer Power: 
                JSR   INT             ;Get Integer Part in FAC = Float[INT(FAC)]
;                                     ;Does INT(FAC)=FAC?
                LDA   #TEMP3          ;Get Comparand Address, Low
                LDY   #>TEMP3         ;Get Comparand Address, High
                JSR   FCOMP           ;Compare FAC with Packed Number at (A,Y) ^
;                                     ;Rtns: (A)=(-1|0|1)<--(A,Y)=[(>|=|<) FAC]
                BNE   FPWRT2          ;Branch if Not Integer Power (FAC)<>(TEMP3)
;                                     ;^[Not Integer Power would cause Error!]
;              ---------------------- ;Else, it is an Int Power (FAC)=(TEMP3);
;                                     ;So allow Negtive ARG by making it Postive
;                                     ;when moved to FAC for Calculation:
                TYA                   ;Clear Accumulator (A=Y=0)
                LDY   CHARAC          ;Get Parity [(lsb) of (CHARAC)] (from INT)
;                                     ;^[Saved FAC Mantissa (Integer Form), Low]
; ----------------------------------- ;Now, ARG is Positive, or is Negative & an
;                                     ;Integer Power, fixable for Calculation,
;                                     ;or Not an Integer Power; [(A=0) Sets FAC 
;                                     ;Unpacked Sign (msb)], Next:
FPWRT2          JSR   CPYARGFAC       ;Copy ARG into FAC [FAC=ABS(ARG)]
                TYA                   ;Get to Save [Y=0 or Y=(CHARAC)] on STACK:
                PHA                   ;Push (Y) as Flag for Negative ARG [0=(+)]
;              ---------------------- ;Get Natural Logarithm of ABS(ARG):
                JSR   LOG             ;Do LOG(FAC) [ABS(ARG) was copied into FAC]
;              ---------------------- ;Now, Multiply by Power (Exponent):
                LDA   #TEMP3          ;Get TEMP3 (Safe FAC [POWER]) Address, Low
                LDY   #>TEMP3         ;Get TEMP3 (Safe FAC [POWER]) Address, High
                JSR   FMULT           ;Multiply FAC by POWER [FAC=FAC*(A,Y)]
;                     ^^^^^---------- ;<<< Because of bug in FMULT, ... >>>
                JSR   EXP             ;Raise to Power of Natural Base (e=2.718282)
;              ---------------------- ;Is Exponent [POWER] a Negative Odd Int?
                PLA                   ;Pull Flag for Negative ARG [0=(+)]
                LSR   A               ;Put Negative ARG Flag (lsb) into Carry
                BCC   BAS_RTS23       ;Return to Caller if NOT; Else, Do NEGOP
; 
; ==============================================================================
; "NEGOP" [Greater-Than (">") Operator] Function: Negates Value in FACSIGN
; ==============================================================================
; 
; ==============================================================================
; Comparison for (GREATER-THAN)->-(LESS-THAN) [Rel Ops (">") Unary Minus entry]:
; ==============================================================================
; From MATHTBL: MO_UMNS_GTLT  DFB P_NEQ    ;$CF...207...>...Unary Minus ("-")
;               TA_UMNS_GTLT  DW  NEGOP-1  ;(GREATER-THAN)->-(LESS-THAN) Op Adrs
; ==============================================================================
; 
;              EQU    *               ;(Math Operator Table Branch Address +1)
NEGOP           LDA   FAC             ;Get FAC Exponent
                BEQ   BAS_RTS23       ;Branch if FAC=0; No need to Complement
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   FACSIGN         ;Set FAC Unpacked Sign (msb)
BAS_RTS23       RTS                   ;Return to Caller

; ==============================================================================
; LOG (base 2) of (e):(The Base for Natural Logarithms)    (Packed FAC Constant)
; ==============================================================================
; The Base for Natural Logarithms (e) [Euler's] Constant & Formula:
; ------------------------------------------------------------------------------
;           e = 2.718281828
;      Exp(1) = 2.71828183
; ==============================================================================
; Logarithm Base Conversion Formulas & Constants:
; ------------------------------------------------------------------------------
; Log (base b) N = ln(N) / ln(b)  |   ln(2) = 0.693147181
; Log (base 2) N = ln(N) / ln(2)  |           ^--(Using AppleWin & Applesoft)
; ------------------------------------------------------------------------------
; ln(10) = 2.30258509             |  Log(2) = 0.30102999566398119521373889472449
;          ^---(Using A/W & A/S)  |           ^--(Using Calculator in Windows 7)
; ------------------------------------------------------------------------------
;     Log(2) = [(ln(2))/(ln(10))] = [(0.693147181)/(2.30258509)] = (0.301029996)
;                                   ^-------(Using AppleWin & Applesoft)-------^
; ==============================================================================
; The Values Indicated here (CON_LOG_E) & below (POLY_EXP, POLY_EXP_L2, &
; POLY_ONE), are NOT EXACT since the Coefficients are Adjusted for Accuracy:
; ------------------------------------------------------------------------------
; 
CON_LOG_E       HEX   8138AA3B29      ;[Normalized]; LOG(base2)(e) = 1.442695042
; 
;  Proof: LOG(base 2)(e) = [(ln(e))/(ln(2))] = [(1)/(0.693147181)] = 1.44269504
; ------------------------------------------------------------------------------
; 
; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_LOGE HEX 8138AA3B29 |(00) |$81-$80=$01= +1 |$.38AA3B29 |+0.44269504E+0
; (!) POS_LOGE HEX 81B8AA3B29 |(00) |$81-$80=$01= +1 |$.B8AA3B29 |+1.44269504E+0
; (!) NEG_LOGE HEX 81B8AA3B29 |(FF) |$81-$80=$01= +1 |$.B8AA3B29 |-1.44269504E+0
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; Polynomial Coeficients            (Packed FAC Constants adjusted for accuracy)
; ==============================================================================
; 
POLY_EXP        DFB   $07             ;Index: (Polynomial Coeficients)-1
                HEX   7134583E56      ;<-[Normalized]; (LOG(2)^7)/7!
                HEX   74167EB31B      ;<-[Normalized]; (LOG(2)^6)/6!
                HEX   772FEEE385      ;<-[Normalized]; (LOG(2)^5)/5!
                HEX   7A1D841C2A      ;<-[Normalized]; (LOG(2)^4)/4!
                HEX   7C6359580A      ;<-[Normalized]; (LOG(2)^3)/3!
                HEX   7E75FDE7C6      ;<-[Normalized]; (LOG(2)^2)/2!
; 
POLY_EXP_L2     HEX   8031721810      ;<-[Normalized]; (LOG(2)^1)/1! {<> ln(2)}
; << Is this a BUG?  {POLY_EXP_L2 == ln(2)+(0.5E-8)} <> {CON_LOGTWO == ln(2)} >>
; 
POLY_ONE        HEX   8100000000      ;<-[Normalized]; The Number One (1), again

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_7 HEX 7134583E56 |(00) |$71-$80=$F1=-15 |$.34583E56 |+6.23997465E-6
; (!) POS_L2_7 HEX 71B4583E56 |(00) |$71-$80=$F1=-15 |$.B4583E56 |+2.14987637E-5
; (!) NEG_L2_7 HEX 71B4583E56 |(FF) |$71-$80=$F1=-15 |$.B4583E56 |-2.14987637E-5
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_6 HEX 74167EB31B |(00) |$74-$80=$F4=-12 |$.167EB31B |+2.14528279E-5
; (!) POS_L2_6 HEX 74967EB31B |(00) |$74-$80=$F4=-12 |$.967EB31B |+1.43523140E-4
; (!) NEG_L2_6 HEX 74967EB31B |(FF) |$74-$80=$F4=-12 |$.967EB31B |-1.43523140E-4
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_5 HEX 772FEEE385 |(00) |$77-$80=$F7= -9 |$.2FEEE385 |+3.65700983E-4
; (!) POS_L2_5 HEX 77AFEEE385 |(00) |$77-$80=$F7= -9 |$.AFEEE385 |+1.34556348E-3
; (!) NEG_L2_5 HEX 77AFEEE385 |(FF) |$77-$80=$F7= -9 |$.AFEEE385 |-1.34556348E-3
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_4 HEX 7A1D841C2A |(00) |$7A-$80=$FA= -6 |$.1D841C2A |+1.80151701E-3
; (!) POS_L2_4 HEX 7A9D841C2A |(00) |$7A-$80=$FA= -6 |$.9D841C2A |+9.61401701E-3
; (!) NEG_L2_4 HEX 7A9D841C2A |(FF) |$7A-$80=$FA= -6 |$.9D841C2A |-9.61401701E-3
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_3 HEX 7C6359580A |(00) |$7C-$80=$FC= -4 |$.6359580A |+2.42551269E-2
; (!) POS_L2_3 HEX 7CE359580A |(00) |$7C-$80=$FC= -4 |$.E359580A |+5.55051269E-2
; (!) NEG_L2_3 HEX 7CE359580A |(FF) |$7C-$80=$FC= -4 |$.E359580A |-5.55051269E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_2 HEX 7E75FDE7C6 |(00) |$7E-$80=$FE= -2 |$.75FDE7C6 |+1.15226385E-1
; (!) POS_L2_2 HEX 7EF5FDE7C6 |(00) |$7E-$80=$FE= -2 |$.F5FDE7C6 |+2.40226385E-1
; (!) NEG_L2_2 HEX 7EF5FDE7C6 |(FF) |$7E-$80=$FE= -2 |$.F5FDE7C6 |-2.40226385E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_L2_1 HEX 8031721810 |(00) |$80-$80=$00= +0 |$.31721810 |+1.93147186E-1
; (!) POS_L2_1 HEX 80B1721810 |(00) |$80-$80=$00= +0 |$.B1721810 |+6.93147186E-1
; (!) NEG_L2_1 HEX 80B1721810 |(FF) |$80-$80=$00= +0 |$.B1721810 |-6.93147186E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_LN2  HEX 80317217F8 |(00) |$80-$80=$00= +0 |$.317217F8 |+1.93147181E-1
; (!) POS_LN2  HEX 80B17217F8 |(00) |$80-$80=$00= +0 |$.B17217F8 |+6.93147181E-1
; (!) NEG_LN2  HEX 80B17217F8 |(FF) |$80-$80=$00= +0 |$.B17217F8 |-6.93147181E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ONE  HEX 8100000000 |(00) |$81-$80=$01= +1 |$.00000000 |+1.00000000E+0
; (!) POS_ONE  HEX 8180000000 |(00) |$81-$80=$01= +1 |$.80000000 |+1.00000000E+0
; (!) NEG_ONE  HEX 8180000000 |(FF) |$81-$80=$01= +1 |$.80000000 |-1.00000000E+0
; ------------------------------------------------------------------------------
; <<< Plugging NRM_ONE into & Printing FAC ($ED2EG) results in BLANK LINE!
; --Seems that when the mantissa is zero there's a problem printing numbers. >>>
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; "EXP" Exponent Function: Immediate & Deferred; Parameter: EXP (Aexpr); 
;       Raises (e), Euler's Constant, the Base for Natural Logarithms, 
;       (to 6 Places, e=2.718282) to the POWER (Aexpr) Specified
; ==============================================================================
;                     Computes FAC = e^FAC = 2^[FAC*Log2(e)]
; ==============================================================================
; This is NOT the Exponentiation ("^") [Power] Operator!  [But, if (A) is zero
; upon entry there, this routine is branched to immediately]
; ==============================================================================
;                        "Convert to Power of Two Problem" 
; ------------------------------------------------------------------------------
; 
;                                     ;Setup to compute e^FAC = 2^[FAC*Log2(e)]:
EXP             LDA   #<CON_LOG_E     ;Get Constant [Log2(e)] Address, Low
                LDY   #>CON_LOG_E     ;Get Constant [Log2(e)] Address, High
                JSR   FMULT           ;Multiply: FAC = FAC * [(A,Y)={Low,High}]
;                     ^^^^^---------- ;<<< Because of bug in FMULT, EXP(x) is
;                                     ;off for approximately 1<x<1.00000012 and
;                                     ;many other values; e.g., near any integer
;                                     ;(not too large), half integer, etc. >>>
                LDA   FACEXT          ;Get FAC Extra Precision Byte
                ADC   #$50            ;1st Range Test; Add to Round Up
;                                     ;^[Non-Standard Rounding here]
                BCC   EXP1            ;Branch if No Carryover
;                                     ;Else, Round Up (FACEXT > $AF)
                JSR   INCMAN          ;Advance FAC (Add Carryover)
EXP1            STA   ARGEXT          ;Set ARG Extra Precision Byte
;                                     ;^[Strange Value]
                JSR   FAC2ARG         ;Copy FAC to ARG
                LDA   FAC             ;Get FAC Exponent
                CMP   #$88            ;Within Range? [Maximum Exponent < 128]
                BCC   EXP3            ;BLT: Branch if within Range    [< 136]
EXP2LOOP        JSR   OUTOFRNG        ;Else, Out of Range, Make Zero or Overflow
EXP3            JSR   INT             ;Get Integer Part in FAC = Float[INT(FAC)]
                LDA   CHARAC          ;Get Integer Part of POWER
                CLC                   ;Prepare for Add with Carry
                ADC   #$81            ;2nd Range Test; Add to Exponent Bias + 1
                BEQ   EXP2LOOP        ;[0-$81=$7F] Branch if Overflow
;                                     ;Get Back to Normal Bias:
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #1              ;Subtract 1 from Exponent Bias + 1
                PHA                   ;Save Exponent
;                                     ;Swap ARG and FAC:
                LDX   #5              ;Get Count: Number of Bytes to Swap
; <<< Why Swap?  It's doing -(A-B) when (B-A) is the same thing! >>>
EXP4LOOP        LDA   ARG,X           ;Get ARG Byte to Swap
                LDY   FAC,X           ;Get FAC Byte to Swap
                STA   FAC,X           ;Set FAC Byte being Swapped
                STY   ARG,X           ;Set ARG Byte being Swapped
                DEX                   ;Reduce Byte Counter
                BPL   EXP4LOOP        ;LOOP Until Done
                LDA   ARGEXT          ;Get ARG Extra Precision Byte
;                                     ;^[Strange Value]
                STA   FACEXT          ;Set FAC Extra Precision Byte
                JSR   FSUBT           ;Subtract Integer Part [POWER-INT(POWER)]
;                                     ;Remainder is Fractional Part
                JSR   NEGOP           ;Negate Value in FAC (Invert FACSIGN Bits)
                LDA   #<POLY_EXP      ;Get Polynomial Coeficients Address, Low
                LDY   #>POLY_EXP      ;Get Polynomial Coeficients Address, High
                JSR   POLYNOMIAL      ;Compute Series F(x) on Fractional Part
                LDA   #0              ;Clear Accumulator
                STA   SGNCPR          ;Clear Sign Flag for Comparing
                PLA                   ;Retrieve Exponent
                JSR   ADDEXPS1        ;Add Exponent of Integer Part
; <<< Wasted byte here (below), could have just jumped there (above) >>>
                RTS                   ;Return to Caller

; ==============================================================================
; Odd Polynomial Subroutine
; 
;   F(x) = x * P(x^2)
; 
;   Where: x is Value in FAC
;          [(A,Y)={Low,High}] Points at Coefficient Table
;          1st Byte of Coefficient Table is Index: (Polynomial Coeficients)-1
;          Coefficients follow, Highest Power 1st
; 
;   P(x^2) Series Computed using Normal Polynomial Subroutine
; 
; ==============================================================================
; Computes ax+bx^3+cx^5+... where SERPTR (A,Y) points to Coeficients ...c,b,a.
; ==============================================================================
; 
POLY_ODD        STA   SERPTR          ;Save Series Pointer, Low
                STY   SERPTR+1        ;Save Series Pointer, High
                JSR   FACRND2TMP1     ;Store FAC Rounded in TEMP1
                LDA   #TEMP1          ;Get TEMP1 ZP Address, Low
;                                     ;Y=0: TEMP1 ZP Address, High; x=(TEMP1)
                JSR   FMULT           ;Square x; Then Do Series in (x^2):
;                     ^^^^^---------- ;<<< Because of bug in FMULT, ... >>>
                JSR   SERMAIN         ;Calc: a+bx+cx^2+...; Coef's: ...c,b,a.
                LDA   #TEMP1          ;Get TEMP1 ZP Address, Low
                LDY   #>TEMP1         ;Get TEMP1 ZP Address, High
;                     --------------- ;<<< Because of bug in FMULT, ... >>>
                JMP   FMULT           ;Multiply by P(x^2) Series (& Exit)

; ==============================================================================
; Normal Polynomial Subroutine
; 
;   P(x) = C(0)*x^n + C(1)*x^(n-1) + ... + C(n)
; 
;   Where: x is Value in FAC
;          [(A,Y)={Low,High}] Points at Coefficient Table
;          1st Byte of Coefficient Table is Index: (Polynomial Coeficients)-1
;          Coefficients follow, Highest Power 1st
; 
; ==============================================================================
; Computes a+bx+cx^2+... where SERPTR (A,Y) points to Coeficients ...c,b,a.
; ==============================================================================
; 
POLYNOMIAL      STA   SERPTR          ;Save Series Pointer, Low
                STY   SERPTR+1        ;Save Series Pointer, High
; ----------------------------------- ;Calc: a+bx+cx^2+...; Coef's: ...c,b,a.
SERMAIN         JSR   FACRND2TMP2     ;Store FAC Rounded (x) in TEMP2
                LDA   (SERPTR),Y      ;Get PC Index: (Polynomial Coeficients)-1
                STA   SERLEN          ;Save PC Index as Series Length
;              ---------------------- ;Point to last Coefficient (1st in Table):
                LDY   SERPTR          ;Get Pointer to Series Data, Low
                INY                   ;Advance Y-Index: Series Data Pointer, Low
                TYA                   ;Get Series Data Pointer, Low
                BNE   SERMAIN1        ;Branch if Not Crossing Page Boundary
                INC   SERPTR+1        ;Advance Pointer to Series Data, High
SERMAIN1        STA   SERPTR          ;Set Pointer to Series Data, Low
                LDY   SERPTR+1        ;Get Pointer to Series Data, High
;              ---------------------- ;Accumulate Series Terms:
SERMAIN2        JSR   FMULT           ;Multiply: FAC = FAC * [(A,Y)={Low,High}]
;                     ^^^^^---------- ;<<< Because of bug in FMULT, ... >>>
;              ---------------------- ;Advance Pointer to Next Coefficient:
                LDA   SERPTR          ;Get Pointer to Series Data, Low
                LDY   SERPTR+1        ;Get Pointer to Series Data, High
                CLC                   ;Prepare for Add with Carry
                ADC   #5              ;Add 5 Bytes/Coefficient
                BCC   SERMAIN3        ;Branch if No Carryover
                INY                   ;Advance Y-Index: Series Data Pointer, High
SERMAIN3        STA   SERPTR          ;Set Pointer to Series Data, Low
                STY   SERPTR+1        ;Set Pointer to Series Data, High
;              ---------------------- ;Add Next Coefficient:
                JSR   FADD            ;Add: FAC = FAC + [(A,Y)={Low,High}]
;              ---------------------- ;Point at x again:
                LDA   #TEMP2          ;Get Address of TEMP2 FAC Safe, Low
                LDY   #>TEMP2         ;Get Address of TEMP2 FAC Safe, High
;              ---------------------- ;If Series Not Done, Add Another Term:
                DEC   SERLEN          ;Reduce Series Length
                BNE   SERMAIN2        ;LOOP Until Done
BAS_RTS24       RTS                   ;Return to Caller

; ==============================================================================
; RND Floating-Point Numbers                              (Packed FAC Constants)
; ==============================================================================
;      <<< The missing fifth bytes here account for a known bug in RND >>>
; ------------------------------------------------------------------------------
; 
CON_RND1        HEX   9835447A        ;<<< Missing one byte for a FP value! >>>
CON_RND2        HEX   6828B146        ;<<< Missing one byte for a FP value! >>>

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific 
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec 
; ----------------------------|-----|----------------|-----------|--------------
;   CON_RND1  HEX  9835447A   |(00) |$98-$80=$18=+24 |$.35447A68 |+3.49093841e+6
;                             |     | Taken as a 32-bit Integer:  -1,741,339,526
; ----------------------------|-----|----------------|-----------|--------------
;   CON_RND2  HEX  6828B146   |(00) |$68-$80=$E8=-24 |$.28B14620 |+9.47445545e-9
;                             |     | Taken as a 32-bit Integer:  +1,747,497,286
; ------------------------------------------------------------------------------
; Since these are missing one byte each for a FP value,          \
; I am using the next byte in sequence for the final byte of each "$.mantissa"!
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; "RND" Random Number Function: Immediate & Deferred; Parameter: RND (Aexpr);
; Returns a Random Real Number between Zero & One: RND(Aexpr)=[(0)=<(RND#)<(1)]
; ==============================================================================
; 
RND             JSR   SIGN            ;FAC Sign (Neg|0|Pos) Returns (A)=(-1|0|1)
                TAX                   ;Save Sign of FAC (as Potential RND Seed)
                BMI   RNDFACNEG       ;Branch if Sign of FAC (Seed) is Negative
;              ---------------------- ;Else, Move Current RND Seed into FAC:
                LDA   #RNDSEED        ;Get Pointer to FP Random Number Seed, Low
                LDY   #>RNDSEED       ;Get Pointer to FP Random Number Seed, High
                JSR   UPAY2FAC        ;Unpack FP# at [(A,Y)={Low,High}] into FAC
                TXA                   ;Retrieve Sign of FAC (Potential RND Seed)
;              ---------------------- ;EXIT if RND(0):
                BEQ   BAS_RTS24       ;Branch if FAC=0, Return Seed=0 Unchanged
; ----------------------------------- ;Else, Do Random Number Function:
;                                     ;<<< "Very Poor RND Algorithm"--BS-C >>>
;              ---------------------- ;Mix It Up!
                LDA   #<CON_RND1      ;Get RND FP Number Constant #1, Low
                LDY   #>CON_RND1      ;Get RND FP Number Constant #1, High
;                     --------------- ;<<< BUG: Constants are Truncated >>>
                JSR   FMULT           ;Multiply: FAC = FAC * [(A,Y)={Low,High}]
;                     ^^^^^---------- ;<<< Because of bug in FMULT, ... >>>
;              ---------------------- ;Mix It Up More!
                LDA   #<CON_RND2      ;Get RND FP Number Constant #2, Low
                LDY   #>CON_RND2      ;Get RND FP Number Constant #2, High
;                     --------------- ;<<< BUG: Constants are Truncated; & Due
;                                     ;to Small Exponent, JSR Does Nothing: >>>
                JSR   FADD            ;Add: FAC = FAC + [(A,Y)={Low,High}]
;              ---------------------- ;Mix It Up More Still!
;                                     ;Swap Most & Least Significant Bytes:
RNDFACNEG       LDX   FAC+4           ;Get FAC Mantissa, Low
                LDA   FAC+1           ;Get FAC Mantissa, Top
                STA   FAC+4           ;Set FAC Mantissa, Low
                STX   FAC+1           ;Set FAC Mantissa, Top
;              ---------------------- ;Take Absolute Value; Make It Positive:
                LDA   #0              ;Clear Accumulator
                STA   FACSIGN         ;Clear FAC Unpacked Sign (msb)
;              ---------------------- ;Setup Extra Bit "Randomly":
                LDA   FAC             ;Get FAC Exponent
                STA   FACEXT          ;Set FAC Extra Precision Byte
                LDA   #$80            ;Adjust Range: Set FACX to be between 0 & 1
                STA   FAC             ;Set FAC Exponent
                JSR   NRMLZFAC2       ;Normalize Value in FAC
;              ---------------------- ;Move FAC To RND Number Seed:
                LDX   #RNDSEED        ;Get Pointer to FP Random Number Seed, Low
                LDY   #>RNDSEED       ;Get Pointer to FP Random Number Seed, High
GO_MOVMF        JMP   FACRND2XY       ;Pack FAC (Rounded) into [(X,Y)={Low,High}]

; ==============================================================================
; "COS" Cosine Function: Immediate & Deferred; Parameter: COS (Aexpr);
;       Returns the Cosine of (Aexpr) Radians; Computes COS(FAC)=SIN(FAC+pi/2)
; ==============================================================================
; XY-Coordinates:                                                   [Background]
;    Y=SIN[(+|-)Angle],X=COS[(+|-)Angle]
;                      X=SIN[pi/2-[(+|-)Angle]]
;                      X=SIN[pi/2 (-|+) Angle], so COS(FAC)=SIN(FAC+pi/2) is OK!
; ==============================================================================
; <<< Because of BUG in FMULT, COS(x) is off for approximately               >>>
; <<< -.000000184 < x < .000000184, X not 0, and many other values           >>>
; ==============================================================================
; 
COS             LDA   #<PI_HALVED     ;Get Pi Halved (pi/2) Coefficient, Low
                LDY   #>PI_HALVED     ;Get Pi Halved (pi/2) Coefficient, High
;                                     ;[Full Circle = 2*pi radians =360 degrees]
;                                     ;[ 1/4 Circle = pi/2 radians = 90 degrees]
                JSR   FADD            ;Add: FAC = FAC + [(A,Y)={Low,High}]
; 
; ==============================================================================
; "SIN" Sine Function: Immediate & Deferred; Parameter: SIN (Aexpr);
;       Returns the Sine of (Aexpr) Radians; Computes SIN(FAC)
; ==============================================================================
; XY-Coordinates:                                                   [Background]
;    Y=SIN[(+|-)Angle],X=COS[(+|-)Angle]
;                      X=SIN[pi/2-[(+|-)Angle]]
;                      X=SIN[pi/2 (-|+) Angle], so COS(FAC)=SIN(FAC+pi/2) is OK!
; ==============================================================================
; <<< Because of BUG in FMULT, SIN(x) is off for x near pi/2                 >>>
; <<< (but not = pi/2) and many other places                                 >>>
; ==============================================================================
; 
;                                     ;COS Function drops in with FAC=FAC+pi/2
; ----------------------------------- ;Remove Multiples of 2*pi by Dividing & 
;                                     ;Saving Fractional Part [the Remainder]:
SIN             JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
                LDA   #<PI_DOUBLED    ;Get Pi Doubled (2*pi) Coefficient, Low
                LDY   #>PI_DOUBLED    ;Get Pi Doubled (2*pi) Coefficient, High
;                                     ;[Full Circle =2*pi radians =360 degrees]
                LDX   ARGSIGN         ;Get ARG Unpacked Sign (msb) to use in DIV
                JSR   DIV             ;Divide by 2*pi: FAC=ARG/[(A,Y)={Low,High}]
                JSR   FACRND2ARG      ;Copy FAC to ARG (Rounded)
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($F000-$F7FF): ROM Socket $F0 on a real Apple II Plus.
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
                JSR   INT             ;Get Integer Part in FAC = Float[INT(FAC)]
                LDA   #0              ;Clear Accumulator
                STA   SGNCPR          ;Clear Sign Flag for Comparing
; <<< Wasted lines (above), because FSUBT (below) changes SGNCPR again! >>>
                JSR   FSUBT           ;Subtract Integer Part [FAC-INT(FAC)] to
;                                     ;Get Fractional Part [Remainder=mod(2*pi)]
; ----------------------------------> ;Now, FAC=Angle as Fraction of Full Circle
; Circle    /2|1\     |1\     |1\     ;^[Full Circle = 2*pi rads = 360 degrees]
; Folding  |--+--| -> +--| -> +--|    ;^[ 1/2 Circle =   pi rads = 180 degrees]
; Diagram   \3|4/     |4/             ;^[ 1/4 Circle = pi/2 rads =  90 degrees]
; ----------------------------------> ;Fold FAC into 1st Quad [pi/2, 0 ~90 ]:
                LDA   #<QUARTER       ;Get Address of Constant (1/4)=(0.25), Low
                LDY   #>QUARTER       ;Get Address of Constant (1/4)=(0.25), High
; <<< There are much simpler ways to do this! >>>
                JSR   FSUB            ;Subtract: FAC=[(A,Y)={Low,High}]-FAC
;                                     ;Folds Circle on 90 degree Y-Axis, Left to
;                                     ;Right, which puts Angle from 2nd or 3rd 
;                                     ;Quad into 1st or 4th Quad, respectively
;              ---------------------- ;Test & Save Sign for later unfolding:
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                PHA                   ;Push FAC Unpacked Sign (msb)
                BPL   SIN1            ;Branch if FACSIGN is Positive, which means
;                                     ;Angle is OK, & is now in the 1st Quadrant
;              ---------------------- ;Else, FACSIGN is Negative, which means
;                                     ;Angle is NOT OK, it's in the 4th Quadrant
;                                     ;Add 1/2 to Fold FAC into 1st Quadrant:
                JSR   FADDH           ;Round Up to Add 1/2: FAC = FAC + 1/2
;                                     ;Folds Circle on 0 degree X-Axis, Bottom
;                                     ;to Top, which puts Angle from 4th into
;                                     ;1st Quadrant
; ----------------------------------- ;Test Sign for unfolding:
                LDA   FACSIGN         ;Get FAC Unpacked Sign (msb)
                BMI   SIN2            ;Branch if FACSIGN is Negative [Angle's OK]
;              ---------------------- ;Else, FACSIGN is Postive [Angle's NOT OK]
                LDA   SIGNFLG         ;Get Trig Functions Sign Flag
;                                     ;^[Cleared in TAN Function]
                EOR   #%11111111      ;Invert Bits (Negate)
                STA   SIGNFLG         ;Set Trig Functions Sign Flag
; ----------------------------------- ;TAN Function Entry Point to Get COS:
SIN1            JSR   NEGOP           ;Negate Value in FAC (Invert FACSIGN Bits)
;              ---------------------- ;Angle is OK, & is now in the 1st Quadrant
SIN2            LDA   #<QUARTER       ;Get Address of Constant (1/4)=(0.25), Low
                LDY   #>QUARTER       ;Get Address of Constant (1/4)=(0.25), High
                JSR   FADD            ;Add: FAC = FAC + [(A,Y)={Low,High}]
                PLA                   ;Pull (A): FAC Unpacked Sign (msb)
;                                     ;^[or: Trig Func's Sign Flag if from TAN]
                BPL   SIN3            ;Branch if (A) is Positive 
                JSR   NEGOP           ;Negate Value in FAC (Invert FACSIGN Bits)
; ----------------------------------- ;Unfolding Complete; Compute SIN:
SIN3            LDA   #<POLY_SIN      ;Get Address of Sin Coefficients, Low
                LDY   #>POLY_SIN      ;Get Address of Sin Coefficients, High
                JMP   POLY_ODD        ;Go do Standard Sin Series: Compute SIN

; ==============================================================================
; "TAN" Tangent Function: Immediate & Deferred; Parameter: TAN (Aexpr);
;       Returns the Tangent of (Aexpr) Radians;
;       Computes [TAN(FAC)]=[SIN(FAC)/COS(FAC)]
; ==============================================================================
; 
TAN             JSR   FACRND2TMP1     ;Save FAC Rounded in TEMP1
                LDA   #0              ;Clear Accumulator
                STA   SIGNFLG         ;Clear Trig Functions Sign Flag [will be 
;                                     ;Toggled for 2nd or 3rd Quadrant]
                JSR   SIN             ;Get SIN(FAC)
;              ---------------------- ;Store SIN at TEMP3:
                LDX   #TEMP3          ;Get Address of Temp FAC #3, Low
                LDY   #>TEMP3         ;Get Address of Temp FAC #3, High
; <<< A Strange Way to Call FACRND2XY! >>>
                JSR   GO_MOVMF        ;Pack FAC (Rounded) into [(X,Y)={Low,High}]
;              ---------------------- ;Retrieve FAC:
                LDA   #TEMP1          ;Get Address of Temp FAC #1, Low
                LDY   #>TEMP1         ;Get Address of Temp FAC #1, High
;              ---------------------- ;Compute COS:
                JSR   UPAY2FAC        ;Unpack FP# at [(A,Y)={Low,High}] into FAC
                LDA   #0              ;Clear Accumulator
                STA   FACSIGN         ;Clear FAC Unpacked Sign (msb)
                LDA   SIGNFLG         ;Get Trig Functions Sign Flag
; <<< A "Weird & Dangerous Way [Why?] to Get into SIN" -- BS-C >>>
                JSR   TAN1            ;Get COS
;              ---------------------- ;Retrieve SIN:
                LDA   #TEMP3          ;Get Address of Temp FAC #3, Low
                LDY   #>TEMP3         ;Get Address of Temp FAC #3, High
;              ---------------------- ;Compute SIN/COS:
                JMP   FDIV            ;Divide: (A,Y)-->(ARG)/(FAC)-->(FAC)

; <<< Shame, Shame! -- BS-C
;     Why not just put this 'in-line' above with a JSR instead of JMP? >>>
TAN1            PHA                   ;Push Trig Functions Sign Flag
                JMP   SIN1            ;Go Get COS

; ==============================================================================
; Pi Coefficients                   (Packed FAC Constants adjusted for accuracy)
; ==============================================================================
; Pi Constant & Formulas:
; ------------------------------------------------------------------------------
;   pi = ............... = 3.141592654  |   2*pi = ............ = 6.283185308
;   pi = 4*ATN(1)-(1E-9) = 3.14159265   |   2*(4*ATN(1)-(1E-9)) = 6.28318530
;   <>  [4*ATN(1) = .... = 3.14159266]  |  [2*(4*ATN(1)) = .... = 6.28318532]
; ==============================================================================
; 
PI_HALVED       HEX   81490FDAA2      ;<-[Normalized]; (pi/2)
PI_DOUBLED      HEX   83490FDAA2      ;<-[Normalized]; (2*pi); = PI2_1 (below)
QUARTER         HEX   7F00000000      ;<-[Normalized]; (1/4)=(0.250000000)
; ----------------------------------- ;Alternating Sin Series:
POLY_SIN        DFB   $05             ;Index: (Pi Coefficients)-1
; ----------------------------------- ;32-bit numbers, with alternating signs:
PI2_11          HEX   84E61A2D1B      ;(2*pi)^11/11!
PI2_9           HEX   862807FBF8      ;(2*pi)^9/9!
PI2_7           HEX   8799688901      ;(2*pi)^7/7!
PI2_5           HEX   872335DFE1      ;(2*pi)^5/5!
PI2_3           HEX   86A55DE728      ;(2*pi)^3/3!
PI2_1           HEX   83490FDAA2      ;<-[Normalized]; (2*pi); = PI_DOUBLED (^)
; 
; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_PID2 HEX 81490FDAA2 |(00) |$81-$80=$01= +1 |$.490FDAA2 |+0.57079633E+0
; (!) POS_PID2 HEX 81C90FDAA2 |(00) |$81-$80=$01= +1 |$.C90FDAA2 |+1.57079633E+0
; (!) NEG_PID2 HEX 81C90FDAA2 |(FF) |$81-$80=$01= +1 |$.C90FDAA2 |-1.57079633E+0
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_PI   HEX 82490FDAA2 |(00) |$82-$80=$02= +2 |$.490FDAA2 |+1.14159265E+0
; (!) POS_PI   HEX 82C90FDAA2 |(00) |$82-$80=$02= +2 |$.C90FDAA2 |+3.14159266E+0
; (!) NEG_PI   HEX 82C90FDAA2 |(FF) |$82-$80=$02= +2 |$.C90FDAA2 |-3.14159266E+0
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_PIM2 HEX 83490FDAA2 |(00) |$83-$80=$03= +3 |$.490FDAA2 |+2.28318531E+0
; (!) POS_PIM2 HEX 83C90FDAA2 |(00) |$83-$80=$03= +3 |$.C90FDAA2 |+6.28318531E+0
; (!) NEG_PIM2 HEX 83C90FDAA2 |(FF) |$83-$80=$03= +3 |$.C90FDAA2 |-6.28318531E+0
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_QTR  HEX 7F00000000 |(00) |$7F-$80=$FF= -1 |$.00000000 |+2.50000000E-1
; (!) POS_QTR  HEX 7F80000000 |(00) |$7F-$80=$FF= -1 |$.80000000 |+2.50000000E-1
; (!) NEG_QTR  HEX 7F80000000 |(FF) |$7F-$80=$FF= -1 |$.80000000 |-2.50000000E-1
; ------------------------------------------------------------------------------
; <<< Plugging NRM_QTR into & Printing FAC ($ED2EG) results in nothing printed!
; --Seems that when the mantissa is zero there's a problem printing numbers. >>>
; ------------------------------------------------------------------------------
; Alternating Sin Series:
; ------------------------------------------------------------------------------
; (2*pi)^11/11! = ((2*(3.141592654))^11/(11*10*9*8*7*6*5*4*3*2)) |+1.50946426E+1
; (?) NRM_PI2B HEX 84E61A2D1B |(FF) |$84-$80=$04= +4 |$.E61A2D1B |-1.43813907E+1
; (!) POS_PI2B HEX 84661A2D1B |(00) |$84-$80=$04= +4 |$.661A2D1B |+6.38139068E+0
; (!) NEG_PI2B HEX 84661A2D1B |(FF) |$84-$80=$04= +4 |$.661A2D1B |-6.38139068E+0
; ----------------------------|-----|----------------|-----------|--------------
; (2*pi)^9/9!   = ((2*(3.141592654))^9/(9*8*7*6*5*4*3*2)) = .... |+4.20586940E+1
; (?) NRM_PI29 HEX 862807FBF8 |(00) |$86-$80=$06= +6 |$.2807FBF8 |+1.00077971E+1
; (!) POS_PI29 HEX 86A807FBF8 |(00) |$86-$80=$06= +6 |$.A807FBF8 |+4.20077971E+1
; (!) NEG_PI29 HEX 86A807FBF8 |(FF) |$86-$80=$06= +6 |$.A807FBF8 |-4.20077971E+1
; ----------------------------|-----|----------------|-----------|--------------
; (2*pi)^7/7!   = ((2*(3.141592654))^7/(7*6*5*4*3*2)) = ........ |+7.67058598E+1
; (?) NRM_PI27 HEX 8799688901 |(FF) |$87-$80=$07= +7 |$.99688901 |-7.67041703E+1
; (!) POS_PI27 HEX 8719688901 |(00) |$87-$80=$07= +7 |$.19688901 |+1.27041702E+1
; (!) NEG_PI27 HEX 8719688901 |(FF) |$87-$80=$07= +7 |$.19688901 |-1.27041702E+1
; ----------------------------|-----|----------------|-----------|--------------
; (2*pi)^5/5!   = ((2*(3.141592654))^5/(5*4*3*2)) = ............ |+8.16052493E+1
; (?) NRM_PI25 HEX 872335DFE1 |(00) |$87-$80=$07= +7 |$.2335DFE1 |+1.76052237E+1
; (!) POS_PI25 HEX 87A335DFE1 |(00) |$87-$80=$07= +7 |$.A335DFE1 |+8.16052237E+1
; (!) NEG_PI25 HEX 87A335DFE1 |(FF) |$87-$80=$07= +7 |$.A335DFE1 |-8.16052237E+1
; ----------------------------|-----|----------------|-----------|--------------
; (2*pi)^3/3!   = ((2*(3.141592654))^3/(3*2)) = ................ |+4.13417023E+1
; (?) NRM_PI23 HEX 86A55DE728 |(FF) |$86-$80=$06= +6 |$.A55DE728 |-4.13417021E+1
; (!) POS_PI23 HEX 86255DE728 |(00) |$86-$80=$06= +6 |$.255DE728 |+9.34170211E+0
; (!) NEG_PI23 HEX 86255DE728 |(FF) |$86-$80=$06= +6 |$.255DE728 |-9.34170211E+0
; ----------------------------|-----|----------------|-----------|--------------
; (2*pi)        = (2*(3.141592654)) = .......................... |+6.28318531E+0
; (?) NRM_PI21 HEX 83490FDAA2 |(00) |$83-$80=$03= +3 |$.490FDAA2 |+2.28318531E+0
; (!) POS_PI21 HEX 83C90FDAA2 |(00) |$83-$80=$03= +3 |$.C90FDAA2 |+6.28318531E+0
; (!) NEG_PI21 HEX 83C90FDAA2 |(FF) |$83-$80=$03= +3 |$.C90FDAA2 |-6.28318531E+0
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; HIDDEN EASTER EGG                                          by James P. Davis
; ==============================================================================
; Supposedly, this proves that Applesoft is a Bill Gates / Microsoft product:
; ------------------------------------------------------------------------------
; Easter Egg = "MICROSOFT!" Backward
; XOR each byte with $87 to convert the character codes to ASCII
; ------------------------------------------------------------------------------
;        [$A6 D3 C1 C8 D4 C8 D5 C4 CE CA] XOR $87 = ASCII: "!TFOSORCIM";
;        [$CA CE C4 D5 C8 D4 C8 C1 D3 A6] XOR $87 = ASCII: "MICROSOFT!":
; ------------------------------------------------------------------------------
;   $A6 D3 C1 C8 D4 C8 D5 C4 CE CA reversed is $CA CE C4 D5 C8 D4 C8 C1 D3 A6
;   ============================== <----+----> ==============================
;    $A6 XOR $87 = $21 = 33 = "!"  \\\\\|/////  $CA XOR $87 = $4D = 77 = "M"
;    $D3 XOR $87 = $54 = 84 = "T"   \\\\|////   $CE XOR $87 = $49 = 73 = "I"
;    $C1 XOR $87 = $46 = 70 = "F"    \\\|///    $C4 XOR $87 = $43 = 67 = "C"
;    $C8 XOR $87 = $4F = 79 = "O"     \\|//     $D5 XOR $87 = $52 = 82 = "R"
;    $D4 XOR $87 = $53 = 83 = "S"   A  \|/  |   $C8 XOR $87 = $4F = 79 = "O"
;    $C8 XOR $87 = $4F = 79 = "O"   |  /|\  V   $D4 XOR $87 = $53 = 83 = "S"
;    $D5 XOR $87 = $52 = 82 = "R"     //|\\     $C8 XOR $87 = $4F = 79 = "O"
;    $C4 XOR $87 = $43 = 67 = "C"    ///|\\\    $C1 XOR $87 = $46 = 70 = "F"
;    $CE XOR $87 = $49 = 73 = "I"   ////|\\\\   $D3 XOR $87 = $54 = 84 = "T"
;    $CA XOR $87 = $4D = 77 = "M"  /////|\\\\\  $A6 XOR $87 = $21 = 33 = "!"
; ------------------------------------------------------------------------------
; See: "Bill Gates' Personal Easter Eggs in 8 Bit BASIC"
;       <https://www.pagetable.com/?p=43>
; ==============================================================================
;                <<< THE NEXT TEN BYTES ARE NEVER REFERENCED >>>
; <<<<<<<< You can change them in (Apple II Plus) Emulator ROM images! >>>>>>>>>
; ==============================================================================
; 
EASTER_EGG1     HEX   A6D3C1C8D4      ;XOR $87 = ASCII: "!TFOS"
EASTER_EGG0     HEX   C8D5C4CECA      ;XOR $87 = ASCII: "ORCIM"

; ==============================================================================
; "ATN" Arctangent Function: [ARCTAN(FAC)]
; ==============================================================================
;    A Modified Gregory Series is used here.  (Gregory converges too slowly!)
; ------------------------------------------------------------------------------
; Gregory's Series (published first by Leibniz) is one of the series which, when
; summed to infinity, yields a value of pi [pi=4*ATN(1)-(1E-9)=3.141592654...]:
;   pi=4*ATN(1)=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]
; ------------------------------------------------------------------------------
; pi/4=ATN(1)=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]/4
;     =4*[(1/4)-(1/12)+(1/20)-(1/28)+(1/36)-...+((-1)^(n-1))/(8n-4){+/-}...]
; ------------------------------------------------------------------------------
; pi/8=ATN(1)/2=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]/8
;     =4*[(1/8)-(1/24)+(1/40)-(1/56)+(1/72)-...+((-1)^(n-1))/(16n-8){+/-}...]
; ==============================================================================
; 
ATN             LDA   FACSIGN         ;Fold the Argument Range first:
                PHA                   ;Save FAC Sign for later unfolding
                BPL   ATN_1           ;BGE: If Not Negative; Else, Complement:
                JSR   NEGOP           ;Negate Value in FAC (Invert FACSIGN Bits)
ATN_1           LDA   FAC             ;If x >= 1, Form Reciprocal; (x = FACEXP)
                PHA                   ;Save for later unfolding
                CMP   #$81            ;(Exp for FAC >= 1) Normalize between 0 & 1
                BCC   ATN_2           ;BLT: If x < 1, Skip:
                LDA   #<CON_ONE       ;Form Reciprocal (1/x)
                LDY   #>CON_ONE       ;The Number One (1), Normalized
                JSR   FDIV            ;Divide: (A,Y)-->(ARG)/(FAC)-->(FAC)
;                                     ; 0 <=     x  <= 1
;                                     ; 0 <= ATN(x) <= PI/8
ATN_2           LDA   #<POLYATN       ;Compute Polynomial Approximation
                LDY   #>POLYATN       ;using Polynomial ATN Coeficients:
                JSR   POLY_ODD        ;Calc: ax+bx^3+cx^5+...; Coef's: ...c,b,a.
                PLA                   ;Start to unfold:
                CMP   #$81            ;(Exp for FAC >= 1) Was x >= 1?
                BCC   ATN_3           ;BLT: NO, x < 1, Skip:
                LDA   #<PI_HALVED     ;YES, Compensate for Normalization,
                LDY   #>PI_HALVED     ;Subtract from pi/2:
                JSR   FSUB            ;Subtract: (A,Y)-->(ARG)-(FAC)-->(FAC)
ATN_3           PLA                   ;Was FACSIGN Negative?
                BPL   BAS_RTS25       ;BGE: NO, FACSIGN is Positive; Skip next:
                JMP   NEGOP           ;Negate Value in FAC (Invert FACSIGN Bits)

BAS_RTS25       RTS                   ;Return to Caller

; NOTE: Polynomial ATN Coeficients?  Still a Mystery!
; ==============================================================================
; Polynomial ATN Coeficients      (Packed FAC Constants adjusted for accuracy)
; ==============================================================================
;    A Modified Gregory Series is used here.  (Gregory converges too slowly!)
; ------------------------------------------------------------------------------
; Gregory's Series (published first by Leibniz) is one of the series which, when
; summed to infinity, yields a value of pi [pi=4*ATN(1)-(1E-9)=3.141592654...]:
;   pi=4*ATN(1)=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]
; ------------------------------------------------------------------------------
; pi/4=ATN(1)=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]/4
;     =4*[(1/4)-(1/12)+(1/20)-(1/28)+(1/36)-...+((-1)^(n-1))/(8n-4){+/-}...]
; ------------------------------------------------------------------------------
; pi/8=ATN(1)/2=4*[1-(1/3)+(1/5)-(1/7)+(1/9)-...+((-1)^(n-1))/(2n-1){+/-}...]/8
;     =4*[(1/8)-(1/24)+(1/40)-(1/56)+(1/72)-...+((-1)^(n-1))/(16n-8){+/-}...]
; ==============================================================================
; Q1: Do these
;     Polynomial ATN Coeficients [POLYATN (Alternating ATN Series)] (below)
;     have simple formulas like the
;     Pi Coefficients [POLY_SIN (Alternating SIN Series)] (above) have?
; Q2: What is the Modification to the Gregory Series used here?
; Q3: -- A distributed divide by 4 or by 8, more or less, or something else?
; Q4: Do these numbers represent the fractions in the alternating series?
; Q5: How are these coeficients adjusted for accuracy?
; ------------------------------------------------------------------------------
; I am looking for a pattern (mathematical equation for each coeficient) here;
; This is all I have deduced so far: vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -- JPD
; ==============================================================================
; 
POLYATN         DFB   11              ;Index: (Polynomial ATN Coeficients)-1
; -----------------------------------------------------------------------------
;                       vvvvvvvv      ;32-bit numbers, with alternating signs:
;                     vvvvvvvvvv      ;[All are Adjusted then Normalized]
; ------------------------------------------------------------------------------
;                                     ;n=12: [+((-1)^(n-1))/(2n-1) = -1/23]:
POLYATN_C       HEX   76B383BDD3      ;-1.96512662E-4 =~ -(1/5089)
;                                     ;-----------------------------------------
;                                     ;n=11: [+((-1)^(n-1))/(2n-1) = +1/21]:
POLYATN_B       HEX   791EF4A6F5      ;+4.85094216E-3 =~ +(1/206)
;                                     ;-----------------------------------------
;                                     ;n=10: [+((-1)^(n-1))/(2n-1) = -1/19]:
POLYATN_A       HEX   7B83FCB010      ;-4.86701843E-4 =~ -(1/2055)
;                                     ;-----------------------------------------
;                                     ;n=9: [+((-1)^(n-1))/(2n-1) = +1/17]:
POLYATN_9       HEX   7C0C1F67CA      ;+3.42096380E-2 =~ +(1/29)
;                                     ;-----------------------------------------
;                                     ;n=8: [+((-1)^(n-1))/(2n-1) = -1/15]:
POLYATN_8       HEX   7CDE53CBC1      ;-2.30291328E-2 =~ -(1/43)
;                                     ;-----------------------------------------
;                                     ;n=7: [+((-1)^(n-1))/(2n-1) = +1/13]:
POLYATN_7       HEX   7D1464704C      ;+7.24571965E-2 =~ +(1/14)
;                                     ;-----------------------------------------
;                                     ;n=6: [+((-1)^(n-1))/(2n-1) = -1/11]:
POLYATN_6       HEX   7DB7EA517A      ;-2.73023954E-2 =~ -(1/37)
;                                     ;-----------------------------------------
;                                     ;n=5: [+((-1)^(n-1))/(2n-1) = +1/9]:
POLYATN_5       HEX   7D6330887E      ;+1.10932413E-1 =~ +(1/9)
;                                     ;-----------------------------------------
;                                     ;n=4: [+((-1)^(n-1))/(2n-1) = -1/7]:
POLYATN_4       HEX   7E9244993A      ;-1.78398077E-2 =~ -(1/56)  = -1/(7*8)
;                                     ;-----------------------------------------
;                                     ;n=3: [+((-1)^(n-1))/(2n-1) = +1/5]:
POLYATN_3       HEX   7E4CCC91C7      ;+1.99999120E-1 =~ +(1/5)
;                                     ;-----------------------------------------
;                                     ;n=2: [+((-1)^(n-1))/(2n-1) = -1/3]:
POLYATN_2       HEX   7FAAAAAA13      ;-8.33333157E-2 =~ -(1/12) = -1/(3*4)
;                                     ;                        = -((1/8)-(1/24))
;                                     ;-----------------------------------------
;                                     ;n=1: [+((-1)^(n-1))/(2n-1) = +1]:
POLYATN_1       HEX   8100000000      ;The Number One (1), again!

; ------------------------------------------------------------------------------
; Plugging into & Printing FAC ($ED2EG)
; ------------------------------------------------------------------------------
; FAC Signed Exponents have had $80 added & binary Mantissa msb is sign bit:
;           %(1.s)xxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx,xxxx <--(32 bits)
; ------------------------------------------------------------------------------
;      Plug into & Print FAC  |FAC- |    Exponent    |$.Mantissa |sn Scientific
;      ($ED2EG)*   vvvvvvvvvv |SIGN | Hex        Dec |           | Notation Dec
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATNC HEX 76B383BDD3 |(FF) |$76-$80=$F6=-10 |$.B383BDD3 |-6.84793912E-4
; (!) POS_ATNC HEX 763383BDD3 |(00) |$76-$80=$F6=-10 |$.3383BDD3 |+1.96512662E-4
; (!) NEG_ATNC HEX 763383BDD3 |(FF) |$76-$80=$F6=-10 |$.3383BDD3 |-1.96512662E-4
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATNB HEX 791EF4A6F5 |(00) |$79-$80=$F9= -7 |$.1EF4A6F5 |+9.44692156E-4
; (!) POS_ATNB HEX 799EF4A6F5 |(00) |$79-$80=$F9= -7 |$.9EF4A6F5 |+4.85094216E-3
; (!) NEG_ATNB HEX 799EF4A6F5 |(FF) |$79-$80=$F9= -7 |$.9EF4A6F5 |-4.85094216E-3
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATNA HEX 7B83FCB010 |(FF) |$7B-$80=$FB= -5 |$.83FCB010 |-1.61117018E-6
; (!) POS_ATNA HEX 7B03FCB010 |(00) |$7B-$80=$FB= -5 |$.03FCB010 |+4.86701843E-4
; (!) NEG_ATNA HEX 7B03FCB010 |(FF) |$7B-$80=$FB= -5 |$.03FCB010 |-4.86701843E-4
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN9 HEX 7C0C1F67CA |(00) |$7C-$80=$FC= -4 |$.0C1F67CA |+2.95963805E-3
; (!) POS_ATN9 HEX 7C8C1F67CA |(00) |$7C-$80=$FC= -4 |$.8C1F67CA |+3.42096380E-2
; (!) NEG_ATN9 HEX 7C8C1F67CA |(FF) |$7C-$80=$FC= -4 |$.8C1F67CA |-3.42096380E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN8 HEX 7CDE53CBC1 |(FF) |$7C-$80=$FC= -4 |$.DE53CBC1 |-5.42791328E-2
; (!) POS_ATN8 HEX 7C5E53CBC1 |(00) |$7C-$80=$FC= -4 |$.5E53CBC1 |+2.30291328E-2
; (!) NEG_ATN8 HEX 7C5E53CBC1 |(FF) |$7C-$80=$FC= -4 |$.5E53CBC1 |-2.30291328E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN7 HEX 7D1464704C |(00) |$7D-$80=$FD= -3 |$.1464704C |+9.95719654E-3
; (!) POS_ATN7 HEX 7D9464704C |(00) |$7D-$80=$FD= -3 |$.9464704C |+7.24571965E-2
; (!) NEG_ATN7 HEX 7D9464704C |(FF) |$7D-$80=$FD= -3 |$.9464704C |-7.24571965E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN6 HEX 7DB7EA517A |(FF) |$7D-$80=$FD= -3 |$.B7EA517A |-8.98023954E-2
; (!) POS_ATN6 HEX 7D37EA517A |(00) |$7D-$80=$FD= -3 |$.37EA517A |+2.73023954E-2
; (!) NEG_ATN6 HEX 7D37EA517A |(FF) |$7D-$80=$FD= -3 |$.37EA517A |-2.73023954E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN5 HEX 7D6330887E |(00) |$7D-$80=$FD= -3 |$.6330887E |+4.84324134E-2
; (!) POS_ATN5 HEX 7DE330887E |(00) |$7D-$80=$FD= -3 |$.E330887E |+1.10932413E-1
; (!) NEG_ATN5 HEX 7DE330887E |(FF) |$7D-$80=$FD= -3 |$.E330887E |-1.10932413E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN4 HEX 7E9244993A |(FF) |$7E-$80=$FE= -2 |$.9244993A |-1.42839808E-1
; (!) POS_ATN4 HEX 7E1244993A |(00) |$7E-$80=$FE= -2 |$.1244993A |+1.78398077E-2
; (!) NEG_ATN4 HEX 7E1244993A |(FF) |$7E-$80=$FE= -2 |$.1244993A |-1.78398077E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN3 HEX 7E4CCC91C7 |(00) |$7E-$80=$FE= -2 |$.4CCC91C7 |+7.49991205E-2
; (!) POS_ATN3 HEX 7ECCCC91C7 |(00) |$7E-$80=$FE= -2 |$.CCCC91C7 |+1.99999120E-1
; (!) NEG_ATN3 HEX 7ECCCC91C7 |(FF) |$7E-$80=$FE= -2 |$.CCCC91C7 |-1.99999120E-1
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN2 HEX 7FAAAAAA13 |(FF) |$7F-$80=$FF= -1 |$.AAAAAA13 |-3.33333316E-1
; (!) POS_ATN2 HEX 7F2AAAAA13 |(00) |$7F-$80=$FF= -1 |$.2AAAAA13 |+8.33333157E-2
; (!) NEG_ATN2 HEX 7F2AAAAA13 |(FF) |$7F-$80=$FF= -1 |$.2AAAAA13 |-8.33333157E-2
; ----------------------------|-----|----------------|-----------|--------------
; (?) NRM_ATN1 HEX 8100000000 |(00) |$81-$80=$01= +1 |$.00000000 |+1.00000000E+0
; (!) POS_ATN1 HEX 8180000000 |(00) |$81-$80=$01= +1 |$.80000000 |+1.00000000E+0
; (!) NEG_ATN1 HEX 8180000000 |(FF) |$81-$80=$01= +1 |$.80000000 |-1.00000000E+0
; ------------------------------------------------------------------------------
; <<< Plugging NRM_ATN1 into & Printing FAC ($ED2EG) results in BLANK LINE!
; --Seems that when the mantissa is zero there's a problem printing numbers. >>>
; ------------------------------------------------------------------------------
; * FACSIGN msb must be set ($80-$FF) to print a minus sign before a result #.
; ==============================================================================
; 
; 
; ==============================================================================
; GENERIC CHRGET [See it here!]
; ==============================================================================
; Generic copy of CHRGET/CHRGOT subroutine, which is copied into $00B1...$00C8
; during initialization
; ==============================================================================
; Cornelis Bongers described several improvements to CHRGET in Micro Magazine or
; Call-A.P.P.L.E.  (I don't remember which or exactly when) -- BS-C
; ==============================================================================
; 
GENCHRGET       INC   TXTPTR          ;Advance Next Char/Token Pointer, Low
                BNE   GENCHRGOT       ;Skip Advancing Pointer, High
                INC   TXTPTR+1        ;Advance Next Char/Token Pointer, High
GENCHRGOT       LDA   NON_SEQUITUR    ;NON_SEQUITUR is TXTPTR in Zero-Page
; ------------------------------------------------------------------------------
; Clear Carry if Numeric, Set Carry if Not Numeric, & leave A-Reg as found:
; ------------------------------------------------------------------------------
                CMP   #':'            ;Is A-Reg a Number, a Colon/EOS, EOL/EOP?
                BCS   GENCGRTS        ;BGE: Return Carry Set if Not a Number &
;                                     ;     Z-Flag Set if a Colon/EOS or EOL/EOP
;                                     ;-----------------------------------------
;                                     ;[This should've been 1st after CHRGOT!]:
                CMP   #' '            ;Is A-Reg a Space Character?
                BEQ   GENCHRGET       ;YES, Ignore it; Get Next Character/Token
;                                     ;-----------------------------------------
                SEC                   ;Prep to Subtract w/o Borrow [A-Data-!C]
                SBC   #'0'            ;Subtract Low ASCII Zero ('0') Character
                SEC                   ;Prep to Subtract w/o Borrow [A-Data-!C]
                SBC   #$D0            ;Subtract $100-'0' Lo-ASCII Zero Character
; ------------------------------------------------------------------------------
GENCGRTS        RTS                   ;Return to Caller

; ==============================================================================
; Randome Number Seed: Initial value for random number, also copied in along
; with CHRGET, but erroneously: <<< BUG: The last byte is not copied >>>
; ==============================================================================
RND_SEED        HEX   804FC75258      ;Approximately = .811635157

; ==============================================================================
; GENERIC.END & COLD.START                              [*]=[(A,Y)={Low,High}]
; ==============================================================================
COLD_START      LDX   #$FF            ;Initialize Direct Mode:
                STX   CURLIN+1        ;Set Direct Mode Flag
                LDX   #$FB            ;Initialize Stack Pointer:
                TXS                   ;Set Stack Pointer Register [S-Reg)=(-5)]
; Upper 4 bytes of STACK used for Forward Link & Line Number in New Line Input
; ==============================================================================
; We must finish COLD_START!  So, as a precaution: Set GOWARM and GOSTROUT to
; (restart) COLD_START until COLD_START is completed; then properly reset them!
; ------------------------------------------------------------------------------
; GOWARM   (LOC0, LOC1 & LOC2) is setup by COLD_START, but is not used anywhere
; GOSTROUT (LOC3, LOC4 & LOC5) is setup by COLD_START, but is not used anywhere
; ------------------------------------------------------------------------------
                LDA   #<COLD_START    ;Get Cold Start Address, Low            [*]
                LDY   #>COLD_START    ;Get Cold Start Address, High
                STA   LOC1            ;Set GOWARM+1; =LOC0+1                  [*]
                STY   LOC1+1          ;Set GOWARM+2; =LOC0+2; =LOC1+1; =LOC2
                STA   LOC4            ;Set GOSTROUT+1; =LOC3+1                [*]
                STY   LOC4+1          ;Set GOSTROUT+2; =LOC3+2; =LOC4+1; =LOC5
                JSR   NORMAL          ;Set Normal Display Mode
                LDA   #$4C            ;Set JMP OpCode for 4 Vectors:
                STA   LOC0            ;Set GOWARM   : (LOC0, LOC1 & LOC2)
                STA   LOC3            ;Set GOSTROUT : (LOC3, LOC4 & LOC5)
                STA   JMPADRS         ;Set Applesoft Jump from ZP to <Address>
                STA   BAS_USRVEC      ;Set Applesoft USR() Command Vector (JMP)
;                                     ;Point USR() Command Vector to Illegal
;                                     ;Quantity Error, until User sets it up
                LDA   #<IQERR         ;Get Print IQ-Error, Low                [*]
                LDY   #>IQERR         ;Get Print IQ-Error, High
                STA   BAS_USRPTR      ;Set USR() Command Ptr, Low             [*]
                STY   BAS_USRPTR+1    ;Set USR() Command Ptr, High
; ------------------------------------------------------------------------------
; Copy CHRGET subroutine & RND Seed to Zero-Page ($B1-$CC) [NOT last byte ($CD)]
; ------------------------------------------------------------------------------
                LDX   #$1C            ;COLD_START-GENCHRGET-1=$1C=28 [is WRONG!] 
; <<< BUG: Should be COLD_START-GENCHRGET=$1D=29!  Includes RND_SEED! >>>
CPYCHRGET       LDA   GENCHRGET-1,X   ;Get a Byte; <<< No -1 would fix BUG & >>>
                STA   $B0,X           ;Set a Byte; <<< No -1 would fix BUG ! >>>
                STX   SPDBYT          ;Initialize Speed (on last pass SPDBYT = 1)
;                                     ;Serves as clue to where (which iteration)
;                                     ;if loop fails to complete (is inerupted)!
                DEX                   ;Count Down
                BNE   CPYCHRGET       ;Loop Until Done; <<< BPL would fix BUG >>>
; ------------------------------------------------------------------------------
                STX   TRCFLG          ;Set NOTRACE (X-Reg=0)
                TXA                   ;Reset A-Reg to Zero, too (from X-Reg)
                STA   SHFTSGNX        ;Clear Sign Extension Right Shifter
;                                     ; (holds 0 except in INT routine)
                STA   LASTPT+1        ;Clear Last Used Temp String Pointer, High
; ------------------------------------------------------------------------------
                PHA                   ;Push a Zero onto STACK at $1FB; The Zero
; here signifies the Start of a New Input Line to Parse or the Start of a New
; Program for the first Input Line, but it's never moved, copied, or used for
; anything more than the target of the LINEIMAGE (Indexed Addressing) Pointer!
; ------------------------------------------------------------------------------
                LDA   #3              ;Get 3 to set TSD Length:
                STA   DSCLEN          ;Set Temporary String Descriptor Length
                JSR   CRDO            ;Print a Carriage <Return> Character
; ----------------------------------- ;Setup Fake Forward Link:
                LDA   #$01            ;Initialize Input Line's Next Line Pointer
                STA   IMGNXLNPTR+1    ;Set Input Line's Next Line Pointer, High
                STA   IMGNXLNPTR      ;Set Input Line's Next Line Pointer, Low
                LDX   #TEMPST         ;Holds up to 3 Descriptors [($55~$5D)=(9B)]
                STX   TEMPPT          ;Set SD Stack: Next Temp Descriptor Pointer
; ==============================================================================
; Find High End of RAM:                                   [*]=[(A,Y)={Low,High}]
; ==============================================================================
;                                     ;Setup Pointer to Low End of RAM:
                LDA   #<PRGMEM        ;Get Start of Program Memory, Low (=0)  [*]
                LDY   #>PRGMEM        ;Get Start of Program Memory, High
                STA   LINNUM          ;Set Memory Scan Pointer, Low, for Zip! [*]
                STY   LINNUM+1        ;Set Memory Scan Pointer, High, for Paging
; ------------------------------------------------------------------------------
; Test First Byte of each Page until ROM or an Empty Ram Socket is Found:
; ------------------------------------------------------------------------------
                LDY   #$00            ;Set for Indirect Addressing of Mem Pages
FNDMEM          INC   LINNUM+1        ;Incement Memory Scan Paging Pointer
                LDA   (LINNUM),Y      ;Test 1st.Byte on Page
                EOR   #%11111111      ;Invert Bits: Test if RAM|ROM|MT-RAM-SKT
                STA   (LINNUM),Y      ;Can change RAM
                CMP   (LINNUM),Y      ;Cannot change ROM/MT-RAM-SKT
                BNE   MEMFND          ;ROM/MT-RAM-SKT found!
                EOR   #%11111111      ;Invert Bits: Put back in RAM as found
                STA   (LINNUM),Y      ;Can change/fix RAM
                CMP   (LINNUM),Y      ;Cannot change/fix ROM/MT-RAM-SKT
                BEQ   FNDMEM          ;Test & Fix RAM until ROM/MT-RAM-SKT found
; ------------------------------------------------------------------------------
; ROM or an empty RAM socket has been Found; Initialize All for a NEW Program:
; ------------------------------------------------------------------------------
;                                     ;    Assure RAM is a multiple of 4 KB
;                                     ;(bad RAM may've yielded a non-multiple):
;                                     ; ------ [*]=[(Y,A)={Low,High}] ------- v
;                                     ;        ^[opposite of normal]^         v
MEMFND          LDY   LINNUM          ;Get Memory Scan Pointer, Low (=0)     [*]
                LDA   LINNUM+1        ;Get Memory Scan Pointer, High
                AND   #$F0            ;Keep High Nibble and Zero Low Nibble
                STY   MEMSIZ          ;Set End of String Space (HIMEM), Low  [*]
                STA   MEMSIZ+1        ;Set End of String Space (HIMEM), High
                STY   FRETOP          ;Set Top of Free Space, Low            [*]
                STA   FRETOP+1        ;Set Top of Free Space, High
;                                     ;^(AKA: Bottom or Start of String Space)
;                                     ;That Resets String-Storage (FRETOP=HIMEM)
;                                     ;-----------------------------------------
;                                     ; Reset Start of Program (Ptr) to $800:
;                                     ; ------ [*]=[(X,Y)={Low,High}] ------- v
                LDX   #<PRGMEM        ;Get Start of Program Memory, Low (=0) [*]
                LDY   #>PRGMEM        ;Get Start of Program Memory, High (=8)
                STX   TXTTAB          ;Set Start of Program Pointer, Low     [*]
                STY   TXTTAB+1        ;Set Start of Program Pointer, High
;                                     ;-----------------------------------------
                LDY   #$00            ;Both Index Registers (X & Y) are now Zero
                STY   AUTORUN         ;Initialize Lock Byte; Turn Off Auto-Run
                TYA                   ;The Accumulator Register is now Zero
                STA   (TXTTAB),Y      ;Start of Program ($800) is now Zero
                INC   TXTTAB          ;Point at $801 as Start of Program
                BNE   INITPRGM        ;Skip High Byte; Always Happens
                INC   TXTTAB+1        ;Never Happens <-\-< [Wasted 4 Bytes Here!]
; Continue to Initialize for a NEW Program:               [*]=[(A,Y)={Low,High}]
INITPRGM        LDA   TXTTAB          ;Get Start of Program Pointer, Low (=1) [*]
                LDY   TXTTAB+1        ;Get Start of Program Pointer, High (=8)
                JSR   REASON          ;Assure enough Arrays-to-Strings Free-Space
                JSR   SCRTCH          ;Initialize NEW Program
; ------------------------------------------------------------------------------
; Properly Reset GOWARM and GOSTROUT ("Wasting Prime Real Estate at 0-5!"):
; ------------------------------------------------------------------------------
; GOWARM   (LOC0, LOC1 & LOC2) is setup by COLD_START, but is not used anywhere
; GOSTROUT (LOC3, LOC4 & LOC5) is setup by COLD_START, but is not used anywhere
; ------------------------------------------------------------------------------
; Setup GOSTROUT to Print the String at [(A,Y)={Low,High}] when called:
                LDA   #<STROUT        ;Get String Out Routine Address, Low
                LDY   #>STROUT        ;Get String Out Routine Address, High
                STA   LOC4            ;Set GOSTROUT+1; =LOC3+1
                STY   LOC4+1          ;Set GOSTROUT+2; =LOC3+2; =LOC4+1; =LOC5
; Set GOWARM to BASIC Soft/Warm/Ctrl-C [& Mon Cmd: 0G] Entry Point
                LDA   #<RESTART       ;Get BASIC Warm Start Address, Low
                LDY   #>RESTART       ;Get BASIC Warm Start Address, High
                STA   LOC1            ;Set GOWARM+1; =LOC0+1
                STY   LOC1+1          ;Set GOWARM+2; =LOC0+2; =LOC1+1; =LOC2
                JMP   (LOC1)          ;DO WARM START

; 
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft - Part D, $F1D5-$F7FF: Graphics Display Routines, etc.
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; 
; ==============================================================================
; "CALL" Statement: Immediate & Deferred; Parameter: CALL Aexpr;
; ==============================================================================
; Causes execution of a machine language subroutine at the memeory location
; whose decimal address is specified (Aexpr)
; ------------------------------------------------------------------------------
; Effectively: Performs a JSR to the specified address; Called routines can
; return with RTS; & Applesoft will continue with the next statement
; ------------------------------------------------------------------------------
; Note: Applesoft's CALL does not set up registers like Integer BASIC's does;
; On a CALL: Y = CALL Adrs, Low; A = CALL Adrs, High; & X = FAC Adrs ($9D)
; ==============================================================================
; 
CALL            JSR   FRMNUM          ;Evaluate & Assure Expression is Numeric
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
                JMP   (LINNUM)        ;Jump to 6502 Memory Address in Line Number

; ==============================================================================
; "IN#" Statement: Immediate & Deferred; Parameter: IN# Aexpr
; ==============================================================================
; Sets Vector to get Input from Slot Number (1~7) specified (Aexpr)
; ------------------------------------------------------------------------------
; Note: There's No Check for a Valid Slot Number; As long as the Value is < 256
; it is Accepted; But the Monitor Masks the Value to 4 Bits (0-15)
; ==============================================================================
; 
IN_NUMBER       JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                TXA                   ;Get Value of Expression (0~255)
;                                     ;Install in Character Input Hook
;                                     ;^[Vector at KSW ($38,$39)={Low,High}]:
                JMP   INPORT          ;Go Set Slot for Input (Monitor S/R)

; ==============================================================================
; "PR#" Statement: Immediate & Deferred; Parameter: PR# Aexpr;
; ==============================================================================
; Sets Vector to direct Output to Slot Number (1~7) specified (Aexpr)
; ------------------------------------------------------------------------------
; Note: There's No Check for a Valid Slot Number; As long as the Value is < 256
; it is Accepted; But the Monitor Masks the Value to 4 Bits (0-15)
; ==============================================================================
; 
PR_NUMBER       JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                TXA                   ;Get Value of Expression (0~255)
;                                     ;Install in Character Output Hook
;                                     ;^[Vector at CSW ($36,$37)={Low,High}]:
                JMP   OUTPORT         ;Go Set Slot for Output (Monitor S/R)

; 
; ==============================================================================
; Low Resolution (Lo-Res) Graphics Subroutines
; ==============================================================================
; Lo-Res Screen SIZE is 48 or 80 by 48:
;  48 Hard-Coded below, in Apple II Plus machines;
;  48 for <  Apple IIc, in machines without 80-Column Capability;
;  80 for >= Apple IIc, but coding it created a Dangerous BUG in those machines!
;  [Enhanced Apple IIe is THE BEST Apple II machine! -- JPD]
; ==============================================================================
; 
; 
; ==============================================================================
; Cartesian Coordinator: Subroutine to Get Cartesian ("#,#") Coordinates
; ==============================================================================
; Gets Two Values < 48, with Comma Separator
; ------------------------------------------------------------------------------
; Called for PLOT X,Y; HLIN A,B at Y; & VLIN A,B at X
; ==============================================================================
; 
; ----------------------------------- ;Get 1st Coordinate:
PLOTFNS         JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                CPX   #SIZE           ;Assure (X)<(Max Size of Lo-Res Screen)
                BCS   BAS_GOERR       ;BGE: IQ ERROR if it is Not < SIZE
                STX   FIRST           ;Save 1st Lo-Res Plot Coordinate
                LDA   #','            ;Must have a Comma next
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
; ----------------------------------- ;Get 2nd Coordinate:
                JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                CPX   #SIZE           ;Assure (X)<(Max Size of Lo-Res Screen)
                BCS   BAS_GOERR       ;BGE: IQ ERROR if it is Not < SIZE
                STX   H2              ;Set Right End of Horizontal Line (HLINE)
                STX   V2              ;Set Bottom End of Vertical Line (VLINE)
                RTS                   ;Return [(FIRST),(X=H2=V2)] to Caller

BAS_GOERR       JMP   IQERR           ;Go Print "?Illegal Quantity" Error Message

; ==============================================================================
; Line Coordinator: Subroutine to Get Lo-Res Line ("#,# at #") Coordinates
; ==============================================================================
; Gets "A,B at C" Values < 48, with Comma & "at" Separators, for HLIN and VLIN;
; Puts Smaller of (A,B) in FIRST, and Larger of (A,B) in H2 & V2;
; Returns X-Reg = (C) Value
; ------------------------------------------------------------------------------
; Called for HLIN A,B at Y; & VLIN A,B at X
; ==============================================================================
; 
LINCOOR         JSR   PLOTFNS         ;Get Cartesian ("A,B") Coordinates
                CPX   FIRST           ;Is B < A?  [Plot Coordinates (PC)]
                BCS   LINAT           ;BGE: Branch if B >= A
;                                     ;Else, B < A; Swap (A,B) -> (B,A):
                LDA   FIRST           ;Get B, 2nd Lo-Res PC, & Smaller of (A,B)
                STA   H2              ;Set Right End of Horizontal Line (HLINE)
                STA   V2              ;Set Bottom End of Vertical Line (VLINE)
                STX   FIRST           ;Save X as 1st Lo-Res Plot Coordinate
;                                     ;Was (A,B) -> Now (B,A)
LINAT           LDA   #TOK_AT         ;Get "AT" Token
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
                JSR   GETBYT          ;Convert Next Expression to a Byte in X-Reg
                CPX   #SIZE           ;Assure (X)<(Max Size of Lo-Res Screen)
                BCS   BAS_GOERR       ;BGE: IQ ERROR if it is Not < SIZE
                RTS                   ;Return to Caller

; ==============================================================================
; "PLOT" Statement: Immediate & Deferred; Parameters: PLOT Aexpr1, Aexpr2
; ==============================================================================
; Plots a Point of current COLOR at [(X,Y)={Aexpr1,Aexpr2}] on the Lo-Res Screen
; ==============================================================================
; 
BAS_PLOT        JSR   PLOTFNS         ;Get Cartesian ("X,Y") Coordinates
                TXA                   ;Get 2nd (Y) Coordinate
                LDY   FIRST           ;Get 1st (X) Coordinate
                CPY   #40             ;Is  1st (X) Coordinate < 40?
                BCS   BAS_GOERR       ;BGE: IQ ERROR if 1st (X) Coordinate >= 40
                JMP   MON_PLOT        ;Go Let Monitor Plot Point on Lo-Res Screen

; ==============================================================================
; "HLIN" Statement: Immediate & Deferred; Parms: HLIN Aexpr1, Aexpr2 AT Aexpr3
; ==============================================================================
; Draws a Horizontal Line of current COLOR on the Lo-Res Screen
; from [(X,Y)=(Aexpr1,Aexpr3)] to [(X,Y)=(Aexpr2,Aexpr3)]
; ==============================================================================
HLIN            JSR   LINCOOR         ;Get Lo-Res Line ("A,B at Y") Coordinates
                TXA                   ;Get 3rd (Y) Horizontal Line Coordinate
                LDY   H2              ;Get Right End (B) of Horizontal Line
                CPY   #40             ;Is  Right End (B) of Horizontal Line < 40?
                BCS   BAS_GOERR       ;BGE: IQ ERROR if Right End of Line >= 40
                LDY   FIRST           ;Get Left End (A) of Horizontal Line
                JMP   HLINE           ;Go Let Monitor Draw Line on Lo-Res Screen

; ==============================================================================
; "VLIN" Statement: Immediate & Deferred; Parms: VLIN Aexpr1, Aexpr2 AT Aexpr3
; ==============================================================================
; Draws a Vertical Line of current COLOR on the Lo-Res Screen
; from [(X,Y)=(Aexpr1,Aexpr3)] to [(X,Y)=(Aexpr2,Aexpr3)]
; ==============================================================================
; 
VLIN            JSR   LINCOOR         ;Get Lo-Res Line ("A,B at X") Coordinates
                TXA                   ;Get 3rd (X) Vertical Column Coordinate
                TAY                   ;Get Bottom End (B) of Vertical Line
                CPY   #40             ;Is  Bottom End (B) of Vertical Line < 40?
                BCS   BAS_GOERR       ;BGE: IQ ERROR if Bottom End of Line >= 40
                LDA   FIRST           ;Get Top End (A) of Vertical Line
                JMP   VLINE           ;Go Let Monitor Draw Line on Lo-Res Screen

; ==============================================================================
; "COLOR=" Statement: Immediate & Deferred; Parameter: COLOR = Aexpr1
; ==============================================================================
; Set the Color for Lo-Res Plotting of Points (Dots) & Lines
; ==============================================================================
; 
COLOR           JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                TXA                   ;Get Color for Lo-Res (Dot/Line) Plotting
                JMP   SETCOL          ;Go Let Monitor Set Color for Lo-Res Plots

; 
; ==============================================================================
; Non-Graphics Subroutines
; ==============================================================================
; 
; 
; ==============================================================================
; "VTAB" Statement: Immediate & Deferred; Parameter: VTAB Aexpr1
; ==============================================================================
; Moves the Cursor to the Line (1~24) that is Aexpr1 Lines down the screen
; ==============================================================================
; 
VTAB            JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                DEX                   ;Reduce Line Number [from (1~24) to (0~23)]
                TXA                   ;Get Line Number to Check Range
                CMP   #24             ;Is Line Number < 24?
                BCS   BAS_GOERR       ;BGE: IQ ERROR if Line Number >= 24
                JMP   TABV            ;Go Let Monitor Set Vertical Cursor Position

; ==============================================================================
; "SPEED=" Statement: Immediate & Deferred; Parameter: SPEED = Aexpr1
; ==============================================================================
; Sets the Speed at which Characters are to be sent to the Screen or to other
; Input/Output Devices
; ==============================================================================
; 
SPEED           JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                TXA                   ;Get Input/Output Speed Specified (0~255)
                EOR   #%11111111      ;Invert Bits (Negate)            -(0~255)
                TAX                   ;Get Negated I/O Speed           (-255~0)
                INX                   ;Advance I/O Speed   [1+(-255~0)=(-254~1)]
                STX   SPDBYT          ;=$100-Speed+1, So SPEED=255 is Fastest[?]
                RTS                   ;Return to Caller

; ==============================================================================
; "TRACE" Statement: Immediate & Deferred; No Parameters; Enables DeBug Mode
; ==============================================================================
; 
TRACE           SEC                   ;To Set Sign Bit in TRCFLG
;                                     ;Trace OFF/ON Flag (<128/>127)~(bit-7)
                DFB   BCC             ;Never Taken; Fake BCC to skip next OpCode

; ==============================================================================
; "NOTRACE" Statement: Immediate & Deferred; No Parameters; Disables DeBug Mode
; ==============================================================================
; 
NOTRACE         CLC                   ;To Clear Sign Bit in TRCFLG
;                                     ;Trace OFF/ON Flag (<128/>127)~(bit-7)
                ROR   TRCFLG          ;Shift CARRY into TRCFLG
                RTS                   ;Return to Caller

; ==============================================================================
; "NORMAL" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Sets Normal Video Input/Output Mode: White Letters on Black Background
; ==============================================================================
; 
NORMAL          LDA   #$FF            ;For INVFLG Text Mask
;                                     ;(Normal=$FF, Flash=$7F, Inverse=$3F)
                BNE   NRMINV          ;Always Taken

; ==============================================================================
; "INVERSE" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Sets Inverse Video Input/Output Mode: Black Letters on White Background
; ==============================================================================
; 
INVERSE         LDA   #$3F            ;For INVFLG Text Mask
NRMINV          LDX   #$00            ;For FLASHBIT Text Mask
NRMINVFLSH      STA   INVFLG          ;Text Mask (Normal=$FF, Flash=$7F, Inverse=$3F)
                STX   FLASHBIT        ;Text Mask (Flash=$40, Lowercase=$20, Else=$00)
                RTS                   ;Return to Caller

; ==============================================================================
; "FLASH" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Sets Flashing Video Input/Output Mode: Alternating Normal (White Letters on
; Black Background) with Inverse (Black Letters on White Background) Modes
; [about two times per second] 
; ==============================================================================
; 
FLASH           LDA   #$7F            ;For INVFLG Text Mask
;                                     ;(Normal=$FF, Flash=$7F, Inverse=$3F)
                LDX   #$40            ;For FLASHBIT Text Mask
;                                     ;(Flash=$40, Lowercase=$20, Else=$00)
                BNE   NRMINVFLSH      ;Always Taken

; ==============================================================================
; "HIMEM:" Statement: Immediate & Deferred; Parameter: HIMEM: Aexpr1
; ==============================================================================
; Sets Highest Memory Address Available to a BASIC Program, including Variables,
; to Protect Memory above IT for Data, Graphics, or Machine Language Routines;
; Automatically Set during Cold Start to Maximum RAM Memory Address in System;
; Reset by RESET CTRL-B RETURN, which also Erases Any Stored Program; Not Reset
; by CLEAR, RUN, NEW, DEL, Changing or Adding a Program Line, or RESET alone;
; Resets String Variable Pointers to Zero Difference, which is effectively the
; same as Clearing String Variables!
; ==============================================================================
; 
HIMEM           JSR   FRMNUM          ;Get Value Specified as 16-Bit Integer
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
; ----------------------------------- ;Is HIMEM above Variables & Arrays?
                LDA   LINNUM          ;Get HIMEM Value Specified, Low
                CMP   STREND          ;Subtract Start of Free Space, Low
                LDA   LINNUM+1        ;Get HIMEM Value Specified, High
                SBC   STREND+1        ;Subtract Start of Free Space, High
                BCS   SETHI           ;BGE: Branch if HIMEM is above them
JMM             JMP   MEMERR          ;ERROR if NOT, Do "?Out Of Memory" Error

; ----------------------------------- ;Store New HIMEM Value:
SETHI           LDA   LINNUM          ;Get HIMEM Value Specified, Low
                STA   MEMSIZ          ;Set Top End of String Space (HIMEM), Low
                STA   FRETOP          ;Set Bottom End of String Space, Low
;                                     ;^(AKA: Top of Free Space, Low)
                LDA   LINNUM+1        ;Get HIMEM Value Specified, High
                STA   MEMSIZ+1        ;Set Top End of String Space (HIMEM), High
                STA   FRETOP+1        ;Set Bottom End of String Space, High
;                                     ;^(AKA: Top of Free Space, High)
;                                     ;That Resets String-Storage (FRETOP=HIMEM)
                RTS                   ;Return to Caller

; ==============================================================================
; <<< HIMEM: Does Not Clear String Variables, which could be Disastrous! >>>
; ------------------------------------------------------------------------------
; But, it does Reset String Variable Pointers to Zero Difference, which is
; effectively the same as Clearing String Variables!
; ==============================================================================
; 
; 
; ==============================================================================
; "LOMEM:" Statement: Immediate & Deferred; Parameter: LOMEM: Aexpr1
; ==============================================================================
; Sets Lowest Memory Address Available to a BASIC Program; Automatically Set to
; End of Program, Start of Simple BASIC Variables, before Program Execution;
; Reset by NEW, DEL, & by Adding or Changing a Program Line; Reset by RESET
; CTRL-B, which also Deletes any Stored Program; Not Reset by RUN, RESET CTRL-C
; RETURN, or RESET 0G RETURN; Can Protect Variables from High-Resolution
; Graphics
; ==============================================================================
; 
LOMEM           JSR   FRMNUM          ;Get Value Specified as 16-Bit Integer
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
; ----------------------------------- ;Is LOMEM below HIMEM?
                LDA   LINNUM          ;Get LOMEM Value Specified, Low
                CMP   MEMSIZ          ;Subtract Top of String Space (HIMEM), Low
                LDA   LINNUM+1        ;Get LOMEM Value Specified, High
                SBC   MEMSIZ+1        ;Subtract Top of String Space (HIMEM), High
                BCS   JMM             ;BGE: Do "?Out Of Memory" ERROR if NOT
; ----------------------------------- ;Is LOMEM above End of Program (EOP)?
                LDA   LINNUM          ;Get LOMEM Value Specified, Low
                CMP   VARTAB          ;Subtract Start of Variables (EOP+1), Low
                LDA   LINNUM+1        ;Get LOMEM Value Specified, High
                SBC   VARTAB+1        ;Subtract Start of Variables (EOP+1), High
                BCC   JMM             ;BLT: Do "?Out Of Memory" ERROR if NOT
; ----------------------------------- ;Store New LOMEM Value:
                LDA   LINNUM          ;Get LOMEM Value Specified, Low
                STA   VARTAB          ;Set Start of Variables (EOP+1), Low
                LDA   LINNUM+1        ;Get LOMEM Value Specified, High
                STA   VARTAB+1        ;Set Start of Variables (EOP+1), High
                JMP   CLEARC          ;Go Clear Variables & Arrays

; ==============================================================================
; "ONERR GOTO" Statements: Deferred Only; Parameter: ONERR GOTO LineNumber
; ==============================================================================
; Prevents having an Error Message Printed & Execution Halted when an Error
; Occurs during Program Execution; ONERR GOTO must be Executed before the
; occurance of an Error to avoid Program Interruption; Sets a Flag that causes
; an Unconditional Jump to LineNumber (if an Error Occurs during Program
; Execution); POKE 216, 0 (*$D8:0) Resets the Error-Detection Flag so that
; Normal Error Messages will be Printed.
; ==============================================================================
; 
ONERR           LDA   #TOK_GOTO       ;Get GOTO Token
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
; ----------------------------------- ;Save TXTPTR for ERRHNDLR:
                LDA   TXTPTR          ;Get Next Char/Token Pointer, Low
                STA   TXTPSV          ;Set Char/Token Pointer Safe, Low
                LDA   TXTPTR+1        ;Get Next Char/Token Pointer, High
                STA   TXTPSV+1        ;Set Char/Token Pointer Safe, High
                SEC                   ;Set Sign Bit of ERRFLG
                ROR   ERRFLG          ;Activate ONERR GOTO (ERRFLG=#$80)
; ----------------------------------- ;Save Current Line Number:
                LDA   CURLIN          ;Get Current Line Number, Low
                STA   CURLSV          ;Set Current Line Safe, Low
                LDA   CURLIN+1        ;Get Current Line Number, High
                STA   CURLSV+1        ;Set Current Line Safe, High
; ----------------------------------- ;Ignore Rest of Line:     <<< Why? >>>
;                                     ;[Anything after ONERR GOTO LineNumber
;                                     ; is treated like a REM & Ignored !!!]
                JSR   REM_END         ;Set (Y)=(Offset to Next ":" or EOL)
;              ---------------------- ;Advance TXTPTR by adding (Y):
                JMP   ADDON           ;Continue Program at Next Line

; ==============================================================================
; Error Handler (Part 2): Routine to Handle errors if ONERR GOTO is Active
; ==============================================================================
; 
ERRHNDLR        STX   ERRNUM          ;Set Current Error Number Safe
; ----------------------------------- ;Get & Save Stack Pointer Saved at NEWSTT:
                LDX   REMSTK          ;Get Stack Ptr Saved Before Each Statement
                STX   ERRSTK          ;Set Stack Pointer Before Error Safe
; <<< Could also have done TXS here; See ONERR Correction in Applesoft Manual >>
; ----------------------------------- ;Save Line Number of Offending Statement:
                LDA   CURLIN          ;Get Current Line Number, Low
                STA   ERRLIN          ;Set Line Number Where ERROR Occurred, Low
                LDA   CURLIN+1        ;Get Current Line Number, High
                STA   ERRLIN+1        ;Set Line Number Where ERROR Occurred, High
; ----------------------------------- ;Get Position in Line to RESUME:
                LDA   OLDTEXT         ;Get Old Text Pointer, Low
                STA   ERRPOS          ;Set Error Handler TXTPTR Safe, Low
                LDA   OLDTEXT+1       ;Get Old Text Pointer, High
                STA   ERRPOS+1        ;Set Error Handler TXTPTR Safe, High
; ----------------------------------- ;Setup for "ON ERR GO TO <Line #>" Msg:
                LDA   TXTPSV          ;Get Char/Token Pointer Safe, Low
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                LDA   TXTPSV+1        ;Get Char/Token Pointer Safe, High
                STA   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Save Line Number of "ON ERR" Statement:
                LDA   CURLSV          ;Get Current Line Safe, Low
                STA   CURLIN          ;Set Current Line Number, Low
                LDA   CURLSV+1        ;Get Current Line Safe, High
                STA   CURLIN+1        ;Set Current Line Number, High
; ----------------------------------- ;Start Conversion:
                JSR   CHRGOT          ;Get Char/Token Got w/o advancing TXTPTR
                JSR   GOTO            ;Goto Specified ONERR GOTO Line Number
                JMP   NEWSTT          ;Execute a New Statement

; ==============================================================================
; "RESUME" Statement: Deferred; No Parameters
; ==============================================================================
; RESUMEs Program Execution at Beginning of Statement where ERROR occurred when
; used after Error Handling; Dangerous if used in Immediate Mode
; ==============================================================================
; 
; ----------------------------------- ;Restore Line Number:
RESUME          LDA   ERRLIN          ;Get Line Number Where ERROR Occurred, Low
                STA   CURLIN          ;Set Current Line Number, Low
                LDA   ERRLIN+1        ;Get Line Number Where ERROR Occurred, High
                STA   CURLIN+1        ;Set Current Line Number, High
; ----------------------------------- ;Restore Next Char/Token Pointer:
                LDA   ERRPOS          ;Get Error Handler TXTPTR Safe, Low
                STA   TXTPTR          ;Set Next Char/Token Pointer, Low
                LDA   ERRPOS+1        ;Get Error Handler TXTPTR Safe, High
                STA   TXTPTR+1        ;Set Next Char/Token Pointer, High
; ----------------------------------- ;Restore Stack Pointer:
                LDX   ERRSTK          ;Get Stack Pointer Before Error Safe
                TXS                   ;Set Stack Pointer
; ----------------------------------- ;Re-try Offending Line:
                JMP   NEWSTT          ;Execute Offending Statement, Again

; ==============================================================================
; "DEL" Statement: Immediate & Deferred; Parameters: DEL LineNuml , LineNum2
; ==============================================================================
; Deletes a Range of Lines from LineNuml to LineNum2, inclusively; Respectively,
; if LineNuml/LineNum2 is NOT an Existing Program Line Number, the Next Larger/-
; /Smaller Line Number in the Program is used in lieu of LineNuml/LineNum2
; ==============================================================================
; 
JSYN            JMP   SYNERROR        ;Relay Point to Throw a "?Syntax" Error

; ==============================================================================
; "DEL" Statement - Main Entry Point:
; ==============================================================================
; 
DEL             BCS   JSYN            ;BGE: ERROR If Line Number NOT Specified
; ----------------------------------- ;Synchronize LOMEM Pointers:
                LDX   PRGEND          ;Get End of Program Pointer, Low
                STX   VARTAB          ;Set Start of Variables Pointer, Low
                LDX   PRGEND+1        ;Get End of Program Pointer, High
                STX   VARTAB+1        ;Set Start of Variables Pointer, High
; ----------------------------------- ;Is Range START Line Number in Program?
                JSR   LINGET          ;Get Range START Line Number (LINNUM)
;                                     ;^[Rtns 0 if Line Number is NOT Specified]
                JSR   FNDLIN          ;Find, Convert, & Point LOWTR at Line/Next
                LDA   LOWTR           ;Get Address of Line or Next Line, Low
                STA   DSTPTR          ;Set Move Destination Pointer, Low
                LDA   LOWTR+1         ;Get Address of Line or Next Line, High
                STA   DSTPTR+1        ;Set Move Destination Pointer, High
; ----------------------------------> ;Upper Program will move down to (DSTPTR)
                LDA   #','            ;Require a Comma Separator Character next: 
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
; ----------------------------------- ;Is Range END Line Number in Program?
                JSR   LINGET          ;Get Range END Line Number (LINNUM)
;                                     ;^[Rtns 0 if Line Number is NOT Specified]
; ----------------------------------- ;Point 1 Line Past Range END Line Number:
                INC   LINNUM          ;Advance Range END Line Number, Low
                BNE   DELSKIP1        ;Branch if No Page Carryover
                INC   LINNUM+1        ;Advance Range END Line Number, High
; ----------------------------------- ;Is Range Valid (START < END):
DELSKIP1        JSR   FNDLIN          ;Find, Convert, & Point LOWTR at Line/Next
                LDA   LOWTR           ;Get Address of Line or Next Line, Low
                CMP   DSTPTR          ;Subtract Move Destination Pointer, Low
                LDA   LOWTR+1         ;Get Address of Line or Next Line, High
                SBC   DSTPTR+1        ;Subtract Move Destination Pointer, High
                BCS   DELMVDWN        ;BGE: Branch if Range Valid (START < END)
                RTS                   ;Else, Nothing to Delete; Return to Caller

; ------------------------------------------------------------------------------
; Delete Specified Section:
; Move Upper Program Section Down [(LOWTR~VARTAB) to (DSTPTR)] 
; ------------------------------------------------------------------------------
; 
DELMVDWN        LDY   #0              ;Clear Indirect Addressing Index
; ----------------------------------- ;Move a Byte (Delete Loop):
DELMVLOOP       LDA   (LOWTR),Y       ;Get a Byte from (Source Address),Y
                STA   (DSTPTR),Y      ;Copy Byte to (Destination Address),Y
; ----------------------------------- ;Advance to Next Source Address:
                INC   LOWTR           ;Advance Source Address, Low
                BNE   DELMVSKP1       ;Branch if No Page Boundary Reached
                INC   LOWTR+1         ;Advance Source Address, High
; ----------------------------------- ;Advance to Next Destination Address:
DELMVSKP1       INC   DSTPTR          ;Advance Destination Address, Low
                BNE   DELMVSKP2       ;Branch if No Page Boundary Reached
                INC   DSTPTR+1        ;Advance Destination Address, High
; ----------------------------------- ;Move Next Byte? Or Finish Up?
DELMVSKP2       LDA   VARTAB          ;Get Start of Variables Ptr (EOP+1), Low
                CMP   LOWTR           ;Subtract Source Address, Low
                LDA   VARTAB+1        ;Get Start of Variables Ptr (EOP+1), High
                SBC   LOWTR+1         ;Subtract Source Address, High
                BCS   DELMVLOOP       ;BGE: LOOP if Not Done Moving Bytes
;                                     ;^[Done when LOWTR move-up reaches VARTAB]
;                                     ;^[Variables will be Cleared, Not Moved!]
; ----------------------------------- ;Else, Finish Up; Reverse Last Advance:
;                                     ;Point End of Program (EOP) to Last Byte 
;                                     ;Moved [(Destination Address)-1]:
                LDX   DSTPTR+1        ;Get Destination Address, High
                LDY   DSTPTR          ;Get Destination Address, Low
                BNE   DELMVSKP3       ;Branch if No Page Boundary Reached
                DEX                   ;Reduce Destination Address, High
DELMVSKP3       DEY                   ;Reduce Destination Address, Low
; <<< Seems like there is a one byte overlap here now that would wipe out the
; last byte of an Applesoft BASIC program!  Should this last reduction really
; have been done? -- JPD >>>
; ----------------------------------- ;Reset Start of Variables Pointer (LOMEM):
                STX   VARTAB+1        ;Set Start of Variables Ptr (EOP+1), High
                STY   VARTAB          ;Set Start of Variables Ptr (EOP+1), Low
                JMP   FIXLINKS        ;Go Clear Vars, Fix Fwd Links, Restart Warm

; ==============================================================================
; "GR" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Sets Low-Resolution GRaphics Mode (40 by 40) for Screen, leaving Four Lines
; for Text at Bottom; Screen is Cleared to Black, & Cursor is Moved to Text
; Window; Can be Converted to Full-Screen (40 by 48) Graphics, after executing
; GR, with command POKE -16302,0 or equivalent command POKE 49234,0; If GR
; follows a Full-Screen POKE command, Mixed Graphics-Plus-Text Mode is Reset;
; After a GR command, COLOR has been set to Zero
; ==============================================================================
; 
GR              LDA   LORES           ;Reset HiRes Mode to LoRes/Text Mode
                LDA   MIXSET          ;Set Mixed Graphics & Text Mode
                JMP   SETGR           ;Go Set Screen to Graphics Mode

; ==============================================================================
; "TEXT" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Sets Screen to Full-Screen Text Mode (40 characters per line, 24 lines) from
; Low-Resolution Graphics Mode or either of two High-Resolution Graphics Modes;
; Prompt & Cursor are moved to last line of Screen; Same as VTAB 24 in Text Mode
; ==============================================================================
; 
;              JMP    TEXT02          ;(=$FB36) Would've done both these things:
TEXT            LDA   TXTPAGE1        ;Display Text Page1; R/W Main V-RAM
                JMP   SETTXT          ;Go Set Screen to Text Mode

; <<<                                 ;Better code would be:
; TEXT         LDA     MIXSET         ;Set Mixed Graphics & Text Mode
;              JMP     TEXT01         ;(=$FB33) Reset HiRes to LoRes/Text Mode
;                                     ;                              -- BS-C >>>
; ==============================================================================
; 
; 
; ==============================================================================
; Tape Array STORE & RECALL Routines: 
; ==============================================================================
;    (There are No Corresponding Routines for Diskette Storage in Applesoft)
; ==============================================================================
; STORE & RECALL Arrays via Cassette Tape (using Apple II Audio Input/Output)
; System; [Did anybody ever use these?]; Array Names are Not Stored with their
; Values, So an Array may be Recalled using a Different Name than that used when
; Stored; Dimensions of arrays recalled should be identical to Dimensions of
; Original Arrays Stored; Failure to observe this will result in Scrambled
; Numbers, Extra Zeros, or ?Out of Memory Erors, in Recalled Arrays
; ==============================================================================
; 
; ==============================================================================
; "STORE" Statement: Immediate & Deferred; Parameter: STORE Avar
; ==============================================================================
; 
; ----------------------------------- ;Prepare to Read/Write a 3-Byte Header 
;                                     ;from/to a Cassette Tape (Audio I/O):
STORE           JSR   GETARYPTR       ;If Found, Point LOWTR at Array Specified
; ----------------------------------- ;Compute [(Array Size)=(Fwd Offset)-1]:
                LDY   #3              ;Point to Forward Offset Pointer, High
;                                     ;^[Data within Array Variable Pointer]
                LDA   (LOWTR),Y       ;Get Forward Offset, High
                TAX                   ;Save Forward Offset, High
                DEY                   ;Point to Forward Offset Pointer, Low
;                                     ;^[Data within Array Variable Pointer]
                LDA   (LOWTR),Y       ;Get Forward Offset, Low
                SBC   #1              ;Reduce Forward Offset, Low
;                                     ;^[C=0: Subtract with Borrow (A-Data-!C)]
;                                     ;^[C=1: Subtract w/o  Borrow (A-Data-!C)]
                BCS   STORESKP1       ;BGE: Branch if Borrowed [(A)>=(Data)]
                DEX                   ;Else, LT: Reduce Forward Offset, High
STORESKP1       STA   LINNUM          ;Save Array Size, Low
                STX   LINNUM+1        ;Save Array Size, High
; ----------------------------------- ;STORE Array on Tape:
                JSR   MON_WRITE       ;Write 3-Byte Header (Length & Lock Byte)
                JSR   TAPEPTR         ;Point at 1st Value in Array
                JMP   MON_WRITE       ;Go Write Array Data to Tape

; ==============================================================================
; "RECALL" Statement: Immediate & Deferred; Parameter: RECALL Avar
; ==============================================================================
; 
; ----------------------------------- ;Prepare to Read/Write a 3-Byte Header 
;                                     ;from/to a Cassette Tape (Audio I/O):
RECALL          JSR   GETARYPTR       ;If Found, Point LOWTR at Array Specified
; ----------------------------------- ;RECALL 3-Byte Header from Tape:
                JSR   MON_READ        ;Read 3-Byte Header (Length & Lock Byte)
; ----------------------------------- ;Compute [(Fwd Offset)-(Tape Array Size)]:
                LDY   #2              ;Point to Forward Offset Pointer, Low
;                                     ;^[Data within Array Variable Pointer]
                LDA   (LOWTR),Y       ;Get Forward Offset, Low
                CMP   LINNUM          ;Subtract Tape Array Size, Low (A-Data):NZC
;                                     ;^[Carry gets Set when [(A)>=(Data)]]
                INY                   ;Point to Forward Offset Pointer, High
                LDA   (LOWTR),Y       ;Get Forward Offset, High
                SBC   LINNUM+1        ;Subtract Tape Array Size, High
;                                     ;^[C=0: Subtract with Borrow (A-Data-!C)]
;                                     ;^[C=1: Subtract w/o  Borrow (A-Data-!C)]
;                                     ;Now've Adrs where Tape Array would Start
;                                     ;^[OK if >, but sh'd be = Spec'd Start+1]
                BCS   RECALLDATA      ;BGE: Branch if Borrowed [(A)>=(Data)]
                JMP   MEMERR          ;Else, LT: Throw an "?Out Of Memory" Error

; ----------------------------------- ;RECALL Array Data from Tape:
RECALLDATA      JSR   TAPEPTR         ;Point at 1st Value in Array
                JMP   MON_READ        ;Go Read Array Data from Tape

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Initialization Routines:
; ==============================================================================
; 
; ==============================================================================
; "HGR2" Statement: Immediate & Deferred; No Parameters; Init & Clear HIRES Pg.2
; ==============================================================================
; Sets Full-Screen High-Resolution Graphics Mode (280 by 192), Displaying Screen
; Page 2 of Memory (16K-24K), Cleared to Black
; ==============================================================================
; 
HGR2            BIT   TXTPAGE2        ;Display Text Page 2
;                                     ;Default to:
                BIT   MIXCLR          ;Set Full Screen Graphics & Text Mode
                LDA   #>HGR2SCRN      ;Get Hi-Res Screen Pg.2 Base-Address, High
                BNE   SETHPG          ;Go Set Hi-Res Graphics Mode; Always Taken

; ==============================================================================
; "HGR" Statement: Immediate & Deferred; No Parameters; Init & Clear HIRES Pg.1
; ==============================================================================
; Sets Mixed-Screen High-Resolution Graphics Mode (280 by 160), Displaying
; Screen Page 1 of Memory (8K-16K), Cleared to Black, Leaving 4 Lines of Text
; Visible at Bottom of Screen, & 20 Lines of Text Invisible at Top of Screen,
; Overlayed with Graphics but Still Functional Underneath, with Cursor
; Unrestricted but Only Visible at Bottom of Screen
; ==============================================================================
; 
HGR             LDA   #>HGR1SCRN      ;Get Hi-Res Screen Pg.1 Base-Address, High
                BIT   TXTPAGE1        ;Display Text Page1; R/W Main V-RAM
;                                     ;Default to:
                BIT   MIXSET          ;Set Mixed Graphics & Text Mode
; 
; ==============================================================================
; Common High-Resolution Graphics Mode (Hi-Res) Initialization Routine:
; ==============================================================================
; 
SETHPG          STA   HGRPAGE         ;Set Hi-Res Base Page (HPg1=$20, HPg2=$40)
                LDA   HIRES           ;Reset Lo-Res/Text Mode to Hi-Res Mode
                LDA   TXTCLR          ;Set Graphics Display Mode
; ----------------------------------- ;Setup to Initialize Hi-Res Screen Memory:
HCLR            LDA   #0              ;Clear Accumulator
                STA   HCOLOR1         ;Clear Hi-Res Color Mask (Black Background)
                LDA   HGRPAGE         ;Get Hi-Res Base Page (HPg1=$20, HPg2=$40)
                STA   HSHAPE+1        ;Clear Hi-Res Screen Byte Pointer, High
                LDY   #0              ;Clear Indirect Addressing Index
                STY   HSHAPE          ;Clear Hi-Res Screen Byte Pointer, Low
; ----------------------------------- ;Initialize Loop; Color Hi-Res Background:
BGLOOP          LDA   HCOLOR1         ;Get Hi-Res Color Mask
                STA   (HSHAPE),Y      ;Clear Hi-Res Screen to Mask Color
                JSR   COLORSHIFT      ;Correct for Color Shift
;                                     ;(Slows Clear by Factor of 2)
                INY                   ;Advance Indirect Addressing Index
                BNE   BGLOOP          ;LOOP if Not at Page Boundary
                INC   HSHAPE+1        ;Advance Hi-Res Screen Byte Pointer, High
                LDA   HSHAPE+1        ;Get Hi-Res Screen Byte Pointer, High
                AND   #%00011111      ;Done? <-[Done at Hi-Res Page End +1, High:
;                                     ;Pg1:$40=(%01000000); Pg2:$60=(%01100000)
                BNE   BGLOOP          ;LOOP if Not Done
                RTS                   ;Else, Return to Caller

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Position And Plot Subroutines:
; ==============================================================================
; 
; ==============================================================================
; Set Hi-Res Cursor Position Subroutine:              [Called by HPLOT0 & SCALE]
; ==============================================================================
; Enter with: [(X,Y)={Low,High}] = Horizontal (Cartesian) X-Coordinate (0-279)
;                  (Accumulator) =   Vertical (Cartesian) Y-Coordinate (0-191)
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
; ----------------------------------- ;Save Spec'd Cartesian (X,Y) Coordinates:
HPOSN           STA   HGRY            ;Save  Vertical  Y-Position
                STX   HGRX            ;Save Horizontal X-Position, Low
                STY   HGRX+1          ;Save Horizontal X-Position, High
; ----------------------------------- ;Compute Base Address for Y-Position 
;                                     ;^[to access Screen Memory via (GBASL),Y]:
                PHA                   ;*** BITS IN: A|Y=ABCDEFGH; Push Y-Position
                AND   #%11000000      ;Retain A|Y=AB000000, Negative & Overflow Bits
                STA   GBASL           ;Set Graphics Base Address, Low
                LSR   A               ;Shift Right: A|Y=0AB00000
                LSR   A               ;Shift Right: A|Y=00AB0000
                ORA   GBASL           ;*** BITS OUT: GBASL=ABAB0000
                STA   GBASL           ;Set Graphics Base Address, Low
; ----------------------------------- ;-----------------------------------------
;                                     ;Bit  A|Y     GBASH     GBASL    A|Y = Row
                PLA                   ;| --------  --------  -------- Pull Y-Pos
                STA   GBASH           ;Y=ABCDEFGH (ABCDEFGH) ABAB0000 <Set GBASH
                ASL   A               ;A-BCDEFGH0< ABCDEFGH  ABAB0000 Shift Left
                ASL   A               ;B-CDEFGH00< ABCDEFGH  ABAB0000 Shift Left
                ASL   A               ;C-DEFGH000< ABCDEFGH  ABAB0000 Shift Left
                ROL   GBASH           ;A-DEFGH000  BCDEFGHC< ABAB0000 Sets GBASH
                ASL   A               ;D-EFGH0000< BCDEFGHC  ABAB0000 Shift Left
                ROL   GBASH           ;B-EFGH0000  CDEFGHCD< ABAB0000 Sets GBASH
                ASL   A               ;E-FGH00000< CDEFGHCD  ABAB0000 Shift Left
                ROR   GBASL           ;0-FGH00000  CDEFGHCD >EABAB000 Sets GBASL
                LDA   GBASH           ;0-CDEFGHCD (CDEFGHCD) EABAB000 <Get GBASH
                AND   #%00011111      ;0-000FGHCD& CDEFGHCD  EABAB000 Rtn 5 LSBs
                ORA   HGRPAGE         ;0-PPPFGHCD+ CDEFGHCD  EABAB000 +($20,$40)
                STA   GBASH           ;0-PPPFGHCD (PPPFGHCD) EABAB000 <Set GBASH
;                                     ;-----------------------------------------
;                                     ;Hi-Res Page1: PPP=001 for $2000-$3FFF
;                                     ;Hi-Res Page2: PPP=010 for $4000-$5FFF
; ----------------------------------- ;-----------------------------------------
;                                     ;Divide X-Position by 7 for Index frm Base
;                                     ;Address (Quotient) & BIT within Screen 
;                                     ;Memry Byte (Mask Specified by Remainder):
                TXA                   ;Retrieve Horizontal X-Position, Low
                CPY   #0              ;Is Horizontal X-Position, High a Zero?
                BEQ   HPOSN2          ;Branch if So: Horizontal X-Position < 256
;                                     ;Else, Horizontal X-Position >= 256:
;                                     ;256/7 = 36, Remainder = 4; & Carry = 1, 
;                                     ;So ADC #4 is Too Large; However, ADC #4 
;                                     ;Clears Carry which makes SBC #7 only -6, 
;                                     ;balancing it out ...
                LDY   #35             ;Following INY will make Y=36
                ADC   #4              ;Addvance Horizontal X-Position, Low
HPOSN1          INY                   ;Addvance Horizontal X-Position, High
;              ---------------------- ;Horizontal X-Position < 256:
HPOSN2          SBC   #7              ;Reduce Horizontal X-Position, Low
;                                     ;^[C=0: Subtract with Borrow (A-Data-!C)]
;                                     ;^[C=1: Subtract w.o  Borrow (A-Data-!C)]
                BCS   HPOSN1          ;BGE: LOOP if Borrowed [(A)>=(Data)]
                STY   HGRHORIZ        ;Store Horizontal Byte Index (Counted)
                TAX                   ;Use Remainder -7 to look up Color Bit Mask:
                LDA   MSKTBL-249,X    ;[Should be MSKTBL-$100+7,X] Get Bit Mask
                STA   HMASK           ;Save H/GR On-the-Fly Color Bit Mask
                TYA                   ;Retrieve Horizontal Byte Index (Quotient)
                LSR   A               ;Shift Right (lsb->C): Even or Odd Column?
                LDA   HGRCOLOR        ;Get Specified Hi-Res Graphics Color
                STA   HCOLOR1         ;Set Hi-Res Color Mask (Color Specified)
                BCS   COLORSHIFT      ;Branch if Odd Column: Fix Odd Color
                RTS                   ;Return to Caller if Even Column: No Fix

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Plot Subroutine:      [Called by HPLOT]
; ==============================================================================
; Enter with: [(X,Y)={Low,High}] = Horizontal (Cartesian) X-Coordinate (0-279)
;                  (Accumulator) =   Vertical (Cartesian) Y-Coordinate (0-191)
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
; ----------------------------------- ;Plot a Dot (w/ current Color Specified):
HPLOT0          JSR   HPOSN           ;Set Hi-Res Cursor Position
;                                     ;^[Computes Bit Position in GBASL/GBASH &
;                                     ;HGRHORIZ, + HMASK, from Y-Coordinate in
;                                     ;A-Reg & X-Coordinate in X-Reg & Y-Reg]
                LDA   HCOLOR1         ;Get Hi-Res Color Mask (Color Specified)
;                                     ;For any 1-bits in HCOLOR1, 
;                                     ;Substitute Corresponding Bit of HMASK: 
                EOR   (GBASL),Y       ;XOR with Dot at Cursor Position
                AND   HMASK           ;AND with H/GR On-the-Fly Color Bit Mask
                EOR   (GBASL),Y       ;XOR with Dot at Cursor Position
                STA   (GBASL),Y       ;Plot a Dot: Set Color at Cursor Position
                RTS                   ;Return to Caller

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Left, Right, Up, Down Subroutines:
; ==============================================================================
; 
; ==============================================================================
; Move Left or Right One Pixel (1 Dot):
; ==============================================================================
; If Status is Positive, Move Right; If is Negative, Move Left; If already at
; Left or Right Edge, Wrap Around
; ==============================================================================
; Remember Bits in Hi-Res Byte are Backwards Order:    Byte N   Byte N+1
;                                                    S7654321   SEDCBA98
; ==============================================================================
; 
MVLFTRGT        BPL   MVRIGHT         ;Go Move Right If Status is Positive
; ----------------------------------- ;Else, Move Left: Status is Negative:
MVLEFT          LDA   HMASK           ;Get H/GR On-the-Fly Color Bit Mask
;              ---------------------- ;Shifting Mask Right, Moves Dot Left:
                LSR   A               ;Shift Right (lsb->C): Bit = 0 or 1?
                BCS   MVLEFT1         ;Branch if Bit Set: Dot Moved to Next Byte
                EOR   #%11000000      ;Move Sign bit back to where it was (msb)
MVLFTRGT1       STA   HMASK           ;Set New H/GR On-the-Fly Color Bit Mask
                RTS                   ;Return to Caller

; ----------------------------------- ;Dot Moved to Next Byte:
MVLEFT1         DEY                   ;Reduce Horizontal Byte Index
                BPL   MVLEFT2         ;Branch if still Not Past Edge
                LDY   #39             ;Else, Off Left Edge, So Wrap Around Scrn:
MVLEFT2         LDA   #%11000000      ;New HMASK, Rightmost Bit on Screen, ...
;                                     ;     ... is Overflow Bit in Byte
MVLEFT3         STA   HMASK           ;Set New H/GR On-the-Fly Color Bit Mask
                STY   HGRHORIZ        ;Set New Horizontal Byte Index
; ----------------------------------- ;Correct for Color Shift:
                LDA   HCOLOR1         ;Get Hi-Res Color Mask: Black Bits = 1
COLORSHIFT      ASL   A               ;Shift/Rotate/Fix Even/Odd Color
                CMP   #%11000000      ;(Black1|White1|Black2|White2)=(0|3|4|7)?
                BPL   BAS_RTS26       ;Return to Caller if Black or White
;                                     ;Else, Shifted Hi-Res Color is Negative:
                LDA   HCOLOR1         ;Get Hi-Res Color Mask: Black Bits = 1
                EOR   #%01111111      ;Keep Sign Bit & Invert 7 Color Bits
                STA   HCOLOR1         ;Set Hi-Res Color Mask
BAS_RTS26       RTS                   ;Return to Caller

; ----------------------------------- ;Move Right: Status is Positive:
MVRIGHT         LDA   HMASK           ;Get H/GR On-the-Fly Color Bit Mask
;              ---------------------- ;Shifting Mask Left, Moves Dot Right:
                ASL   A               ;Shift Left (N->S): Bit = 0 or 1?
                EOR   #%10000000      ;Invert Sign Bit & Keep 7 Color Bits
                BMI   MVLFTRGT1       ;Branch if Finished [(N->S): Bit was = 0]
; ----------------------------------- ;Else, Not Done yet [(N->S): Bit was = 1],
;                                     ;Dot Moved to Next Byte:
                LDA   #%10000001      ;Get New H/GR On-the-Fly Color Bit Mask
                INY                   ;Advance Horizontal Byte Index
                CPY   #40             ;Is Horizontal Byte Index Off Right Edge?
                BCC   MVLEFT3         ;BLT: Branch if Not Past Edge; Else:
                LDY   #0              ;Wrap Around Scrn: Zero Horiz. Byte Index
                BCS   MVLEFT3         ;Now, Go Finish Up; Always Taken

; ==============================================================================
; More High-Resolution Graphics Mode (Hi-Res) Left, Right, Up, Down Subroutines:
; ==============================================================================
; 
; ==============================================================================
; "XDRAW" One Bit: [Same as DRAW, but this Compliments Color (It happens here!)]
; ==============================================================================
; 
; ----------------------------------- ;Entry Point for No 90 Degree Rotation:
LRUDX1          CLC                   ;Clear Carry Flag (C=0)
; ----------------------------------- ;Entry Point to Rotate 90 Degrees:
;                                     ;^[Carry Flag should already be Set (C=1)]
LRUDX2          LDA   HGRDX+1         ;Get Hi-Res Drawing Column, High
                AND   #%00000100      ;Is (Bit 2 = 0)?
                BEQ   LRUD4           ;YES, (Bit2 = 0), Don't Plot
;                                     ;NO, (Bit2 = 1), See what's already there:
;              ---------------------- ;[Start of Color Complemnting Section]:
                LDA   #%01111111      ;Clear Sign Bit & Keep 7 Color Bits:
                AND   HMASK           ;AND with H/GR On-the-Fly Color Bit Mask
                AND   (GBASL),Y       ;Get Dot at Cursor Position
;                                     ;Is Screen Bit Set (=1)?
                BNE   LRUD3           ;YES, Go Clear Screen Bit
                INC   HGRCLSN         ;NO, Count Collision
                LDA   #%01111111      ;& Turn Bit On
;              ---------------------- ;[End of Color Complemnting Section]
                AND   HMASK           ;And with H/GR On-the-Fly Color Bit Mask
                BPL   LRUD3           ;Go Plot Bit; Always Taken
; 
; ==============================================================================
; "DRAW" One Bit: [Same as XDRAW, but it Compliments Color (happens just above)]
; ==============================================================================
; 
; ----------------------------------- ;Entry Point for No 90 Degree Rotation:
LRUD1           CLC                   ;Clear Carry Flag (C=0)
; ----------------------------------- ;Entry Point to Rotate 90 Degrees:
;                                     ;^[Carry Flag should already be Set (C=1)]
LRUD2           LDA   HGRDX+1         ;Get Hi-Res Drawing Column, High
                AND   #%00000100      ;Is (Bit 2 = 0)?
                BEQ   LRUD4           ;YES, (Bit 2 = 0), Don't Plot
;                                     ;NO, (Bit2 = 1), See what's already there:
;              ---------------------- ;[Start of NonColorComplemnting Section]:
                LDA   (GBASL),Y       ;Get Dot at Cursor Position
;                                     ;Set Screen Bit to corresponding HCOLOR:
                EOR   HCOLOR1         ;XOR with Hi-Res Color Mask: Black Bits = 1
;              ---------------------- ;[End of Non Color Complemnting Section]
;                                     ;Look at just this Bit Position:
                AND   HMASK           ;AND with H/GR On-the-Fly Color Bit Mask
                BNE   LRUD3           ;Plot Bit if it was Zero
                INC   HGRCLSN         ;Else, Bit is already 1: Count Collision
; ----------------------------------- ;Plot Bit - Toggle Bit on Screen with (A):
LRUD3           EOR   (GBASL),Y       ;XOR with Dot at Cursor Position
                STA   (GBASL),Y       ;Set Dot at Cursor Position
; ----------------------------------- ;Don't Plot - Determine where next Point 
;                                     ;             will be, and Move there:
;              ---------------------- ;Calculate Direction to Move:
;                                     ;Add Quadrant to Specified Vector & Move 
;                                     ;Left/Right/Up/Down based on Sign & Carry:
LRUD4           LDA   HGRDX+1         ;Get Hi-Res Drawing Column, High
                ADC   HGRQUAD         ;Add Hi-Res Drawing Quadrant
CON3            AND   #%00000011      ;Wrap Around Circle
;                                     ;| 0 = %00 : Up    | 1 = %01 : Down |
;                                     ;| 2 = %10 : Right | 3 = %11 : Left |
                CMP   #2              ;C=0 if 0 or 1, C=1 if 2 or 3
                ROR   A               ;Put C into Sign, Odd/Even into C
                BCS   MVLFTRGT        ;BGE: Branch if C >= 2: Move Left or Right
;                                     ;Else, C < 2, Move Up or Down:
MVUPDWN0        BMI   MVDWN           ;Branch if Sign = 1: Move Down
;                                     ;Else, Sign = 0, Move Up:
; 
; ==============================================================================
; Move Up One Pixel (1 Dot): If already at Top, go to Bottom
; ==============================================================================
; ----------------------------------- ;Note: X-Coordinate = X-Position = Column
;                                     ;      Y-Coordinate = Y-Position = Row
; ----------------------------------- ;Remember:   Row      GBASH     GBASL
;                                     ;          ABCDEFGH  PPPFGHCD  EABAB000
; ----------------------------------- ;Compute Base Adrs for HR Line Above; Put
; MVUP        [Drop-In]               ;Result in (GBAS) w/ 192-Line Wrap Around:
; ----------------------------------- ;-----------------------------------------
                CLC                   ;Prepare for Add with Carry
                LDA   GBASH           ;Get Graphics Base Address, High
                BIT   CON_1C          ;&-Mask for "FGH" bits [($1C)=(%00011100)]
                BNE   MVUP5           ;Branch if FGH Bits <> 0; Go Do FGH=FGH-1
;                                     ;^[GBASH=PPP000CD, GBASL=EABAB000]
                ASL   GBASL           ;Else, Put GBASL Sign (E) Bit into Carry
; ----------------------------------- ;Move Left/Right/Up/Down based on Sign:
                BCS   MVUP3           ;Branch if Sign (E) Bit was Set (=1)
;                                     ;^[Do EFGH=EFGH-1 [Really: FGHCD-1]]
;              ---------------------- ;Finished?
;                                     ;Test Bit2 of GBASH for Carry [(H)<-(CD)]:
                BIT   CON3+1          ;(Constant=3)[SourceGen Mission Impossible]
                BEQ   MVUP1           ;Finished if No Carryover [(H=0)<-(CD)]
;                                     ;^[Y-Position Form is AB000000]?
;              ---------------------- ;Else, Not Finished, GBASH [(H=1)<-(CD)]:
                ADC   #%00011111      ;^[Do CDEFGH=CDEFGH-1 for Row = ABCDEFGH]
                SEC                   ;Force Following Branch:
                BCS   MVUP4           ;Always Taken

; ----------------------------------- ;No Carry, Finish:
;                                     ;Y-Position Form is AB000000
MVUP1           ADC   #$23            ;Add enough to make GBASH=PPP11111 later
                PHA                   ;Push Modified GBASH: Save it for Later
;              ---------------------- ;Is Wrap-Around Needed?
                LDA   GBASL           ;GBASL is now ABAB0000 (AB=00,01,10)
                ADC   #%10110000      ;Add to GBASL [High Nibble] 
;                                     ;GBASL = ABAB + 1011:
;                                     ;        0000 + 1011 = 1011  &  Clrs Carry
;                                     ;   or   0101 + 1011 = 0000  &  Sets Carry
;                                     ;   or   1010 + 1011 = 0101  &  Sets Carry
                BCS   MVUP2           ;Branch if C=1: No Wrap-Around Needed
;              ---------------------- ;Else, ... C=0, So Wrap-Around Needed:
                ADC   #%11110000      ;Add to Fix GBASL [High Nibble]->[1010]
MVUP2           STA   GBASL           ;Set Graphics Base Address, Low
;                                     ;^[Form is still ABAB0000]
;              ---------------------- ;Do CDEFGH=CDEFGH-1 for Row = ABCDEFGH:
                PLA                   ;Pull Modified GBASH: Saved for later Mod
                BCS   MVUP4           ;Always Taken
; 
; ----------------------------------- ;Do EFGH=EFGH-1 [Really: FGHCD-1]: 
MVUP3           ADC   #%00011111      ;Add to GBASH=PPPFGHCD
; ----------------------------------- ;Do CDEFGH=CDEFGH-1 for Row = ABCDEFGH:
MVUP4           ROR   GBASL           ;Shift (E) back in to get GBASL=EABAB000
; ----------------------------------- ;Finish GBASH Modifications, Do FGH=FGH-1:
;                                     ;^[GBASH=PPP000CD, GBASL=EABAB000]
MVUP5           ADC   #%11111100      ;Add to GBASH=PPPFGHCD [Really^: PPPFGH-1]
; ----------------------------------- ;Finished:
MVUPDWN1        STA   GBASH           ;Set Graphics Base Address, High
                RTS                   ;Return to Caller

; ==============================================================================
; Move Down One Pixel (1 Dot): If already at Bottom, go to Top
; ==============================================================================
; ----------------------------------- ;Note: X-Coordinate = X-Position = Column
;                                     ;      Y-Coordinate = Y-Position = Row
; ----------------------------------- ;Remember:   Row      GBASH     GBASL
;                                     ;          ABCDEFGH  PPPFGHCD  EABAB000
; ----------------------------------- ;Compute Base Adrs for HR Line Below; Put
; MVDOWN   [No Drop-In]               ;Result in (GBAS) w/ 192-Line Wrap Around:
; ----------------------------------- ;-----------------------------------------
                CLC                   ;Prepare for Add with Carry <(Never Used)>
; ----------------------------------- ;-----------------------------------------
MVDWN           LDA   GBASH           ;Get Graphics Base Address, High
CON4            ADC   #%00000100      ;Add to GBASH=PPPFGHCD; Do FGH=FGH+1
                BIT   CON_1C          ;&-Mask for "FGH" bits [($1C)=(%00011100)]
                BNE   MVUPDWN1        ;Branch if FGH Bits <> 0: Finished
                ASL   GBASL           ;Else, Put GBASL Sign (E) Bit into Carry
; ----------------------------------- ;Move Left/Right/Up/Down based on Sign:
                BCC   MVDWN2          ;Branch if Sign (E) Bit was Clear (=0)
;              ---------------------- ;Finished?
                ADC   #%11100000      ;Add to GBASH=PPPFGHCD; Do PPP=PPP-1
                CLC                   ;Prepare for Add with Carry
;                                     ;Test Bit2 of GBASH for Carry [(H)<-(CD)]:
                BIT   CON4+1          ;(Constant=4)[SourceGen Mission Impossible]
                BEQ   MVDWN3          ;Finished if No Carryover [(H=0)<-(CD)]
;                                     ;Else, Not Finished, GBASH [(H=1)<-(CD)]:
;              ---------------------- ;Is Wrap-Around Needed?
                LDA   GBASL           ;Get Graphics Base Address, Low
                ADC   #%01010000      ;Advance GBASL (AB)'s [High Nibble]: 
;                                     ;GBASL = ABAB + 0101:
;                                     ;        0000 + 0101 = 0101  &  No Carry
;                                     ;   or   0101 + 0101 = 1010  &  No Carry
;                                     ;   or   1010 + 0101 = 1111  &  No Carry
;                                     ;    &   1010 --> Wrap Around Up to Line 0
                EOR   #%11110000      ;Invert GBASL (AB)'s [High Nibble]
                BEQ   MVDWN1          ;Branch if GBASL is Zero: Wrap Needed
;                                     ;^[Wrap Around to Line Zero of Group]
;                                     ;Else, Wrap-Around Not Needed:
                EOR   #%11110000      ;Invert GBASL (AB)'s [High Nibble], Again
;                                     ;^[Get it Back to what was, to Not Wrap]
; ----------------------------------- ;Finish Move:
MVDWN1          STA   GBASL           ;Set New Graphics Base Address, Low
                LDA   HGRPAGE         ;Get Hi-Res Base Page (HPg1=$20, HPg2=$40)
                BCC   MVDWN3          ;Always Taken
; 
; ----------------------------------- ;Finish GBASH Modifications:
MVDWN2          ADC   #%11100000      ;Add to GBASH=PPPFGHCD; Do PPP=PPP-1
; ----------------------------------- ;Fix GBASL, Reverse Shift Left:
MVDWN3          ROR   GBASL           ;Shift (E) back in to get GBASL=EABAB000
                BCC   MVUPDWN1        ;Finished, Go Set GBASH; Always Taken
; 
; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Line Drawing Subroutines:
; ==============================================================================
; 
; ==============================================================================
; HLINRL: Clear Current Point [(X0L, X0H), Y0] so HGLIN will act Relatively
;         to draw line from it to [{(X0L + DXL), (X0H + DXH)}, (Y0 + DY)]
; ==============================================================================
; HLINRL                            ;Enter with: (A,X) = DX from Current Point
; ^(Never Called by Applesoft)      ;             (Y)  = DY from Current Point
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; HLINRL      [Drop-In Only]        ;Never Referenced [Can Never Happen]
; (Only Exception: User-Callable Entry Point; BASIC: CALL -2,768 or CALL 62,768;
;                  But Need to Set A,X & Y Registers 1st; How? POKES & Pg.3 S/R)
; ------------------------------------------------------------------------------
HLINRL          PHA                   ;Push Accumulator
                LDA   #0              ;Clear Accumulator
                STA   HGRX            ;Clear Horizontal X-Position, Low
                STA   HGRX+1          ;Clear Horizontal X-Position, High
                STA   HGRY            ;Clear  Vertical  Y-Position, Low
                PLA                   ;Pull Accumulator
; ------------------------------------------------------------------------------
; 
; ==============================================================================
; Hi-Res Line Drawing Subroutine: Draw Line from Last Plotted Point to [(A,X),Y]
; ==============================================================================
; HGLIN   [Can Drop-In Too]         ;Enter with: (A,X) = X of Target Point {L,H}
;                                     ;             (Y)  = Y of Target Point
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; Delta: the 4th letter of the Greek alphabet (D or d); is used here, with X & Y
; (DX & DY), to mean the amount by which one number or quantity differs from an-
; other, the amount of change; e.g., Delta X = [DX=X1-X0] & Delta Y = [DY=Y1-Y0]
; ==============================================================================
; 
; ----------------------------------- ;Compute Delta X = (X - X0):
HGLIN           PHA                   ;Push Target Point X-Coordinate, Low
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   HGRX            ;Subtract Horizontal X-Position, Low
                PHA                   ;Push Delta X, Low
                TXA                   ;Get Target Point X-Coordinate, High
                SBC   HGRX+1          ;Subtract Horizontal X-Position, High
;                                     ;Now Carry's Direction of Change in X-Pos
                STA   HGRQUAD         ;Set Hi-Res Drawing Quadrant (w/ DXH)
;                                     ;^[Saves DX Dir (Pos=Right, Neg=Left)]
                BCS   HGLIN1          ;BGE: Branch if Borrowed
                PLA                   ;Else, Pull Delta X, Low; &
; ----------------------------------- ;Compute Magnitude of Delta X 
;                                     ;[(DXL,DXH)=(ABS(X-X0))={& Twos Comp}]:
                EOR   #%11111111      ;Invert Bits (Negate)
                ADC   #1              ;Add to Get New Delta X, Low [DXL=(1-DXL)]
                PHA                   ;Push New Delta X, Low
                LDA   #0              ;Prep to Subtract to Get [DXH=(1-DXH-!C)]
                SBC   HGRQUAD         ;Subtract Hi-Res Drawing Quadrant (w/ DXH)
HGLIN1          STA   HGRDX+1         ;Set Hi-Res Drawing Column, High [ABS(DXH)]
                STA   HGRE+1          ;Set Magnitude of Delta X, High  [ABS(DXH)]
                PLA                   ;Pull New Delta X, Low
                STA   HGRDX           ;Set Hi-Res Drawing Column, Low  [ABS(DXL)]
                STA   HGRE            ;Set Magnitude of Delta X, Low   [ABS(DXL)]
; ----------------------------------- ;Set Pointer to End of Line; Target X Pt:
                PLA                   ;Pull Target Point X-Coordinate, Low
                STA   HGRX            ;Set Horizontal X-Position, Low
                STX   HGRX+1          ;Set Horizontal X-Position, High
; ----------------------------------- ;Set Pointer to End of Line; Target Y Pt:
;              ---------------------- ;Compute Delta Y = (Y - Y0):
                TYA                   ;Get Target Point Y-Coordinate [Low < 256]
                CLC                   ;Prepare to Subtract w/ Borrow [A-Data-!C]
                SBC   HGRY            ;Subtract Vertical Y-Position  [DY=Y-Y0-1]
;                                     ;Now Carry's Direction of Change in Y-Pos
                BCC   HGLIN2          ;BLT: Branch if No Borrow
;              ---------------------- ;Else, Compute Magnitude of Delta Y
;                                     ;[(DY)=(ABS(Y-Y0))={& Twos Compliment}]:
                EOR   #%11111111      ;Invert Bits (Negate)
                ADC   #%11111110      ;Add to Get New Delta Y [DY=(254+{C=1}-DY)]
HGLIN2          STA   HGRDY           ;Set Hi-Res Drawing Row, Low [DY=(-1-DY)]
;                                     ;^[-(Magnitude of Delta Y, Lo) [-ABS(DY)]]
                STY   HGRY            ;Set Vertical Y-Position = Target Y Point
; ----------------------------------- ;Add Y-Dir to Hi-Res Drawing Quadrant:
                ROR   HGRQUAD         ;Shift Carry Right into HGRQUAD Bit 7
;                                     ;^[Saves DY Direction (Pos=Up, Neg=Down)]
;                                     ;^[Shifts DX Direction into HGRQUAD Bit 6]
; ----------------------------------- ;Initialize HCOUNT to [-DX-DY-1]:
;                                     ;^[HCount = Number of Dots needed]
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   HGRDX           ;Subtract Drawing Column, Low [ABS(DXL)]
                TAX                   ;Save Result [-ABS(DY)-ABS(DXL)]
                LDA   #%11111111      ;Get -1
                SBC   HGRDX+1         ;Subtract Drawing Column, High [ABS(DXH)]
                STA   HCOUNT          ;Set Hi-Res Line Step [-1-ABS(DXH)]
; ----------------------------------- ;Draw Line:
                LDY   HGRHORIZ        ;Get Hi-Res Byte Horiz. Index from GBASH,L
                BCS   MOVEX2          ;BGE: Branch if Borrowed; Always Taken
; 
; ----------------------------------- ;Move Left or Right One Pixel;
;                                     ;A-Reg Bit 6 has Direction
;                                     ;MOVE X Loop 1 [Overlaps MOVE X Loop 2]:
MOVEX1L1        ASL   A               ;Shift Column Direction into Sign Bit
                JSR   MVLFTRGT        ;Move Left or Right One Pixel (1 Dot)
;              ---------------------- ;Draw Line Now:
                SEC                   ;Prepare to Add with Carry Set (Adds 1)
MOVEX2          LDA   HGRE            ;(C=1): Get Magnitude of Delta X, Low
                ADC   HGRDY           ;Add Hi-Res Drawing Row, Low [DY=(-1-DY)]
                STA   HGRE            ;Set Magnitude of Delta X, Low
                LDA   HGRE+1          ;Get Magnitude of Delta X, High
;                                     ;Carry Clear if HGRE {L,H} goes Negative
                SBC   #0              ;Subtract Zero with Borrow [A-Data-!C]
;                                     ;MOVE X Loop 2 [Overlaps MOVE X Loop 1]:
MOVEX3L2        STA   HGRE+1          ;Set Magnitude of Delta X, High
;              ---------------------- ;Plot A Dot:
                LDA   (GBASL),Y       ;Get Dot at Cursor Position
                EOR   HCOLOR1         ;XOR with Hi-Res Color Mask
                AND   HMASK           ;AND with H/GR On-the-Fly Color Bit Mask
                EOR   (GBASL),Y       ;XOR with Dot at Cursor Position
                STA   (GBASL),Y       ;Set Dot at Cursor Position
                INX                   ;Count Dot Plotted
;              ---------------------- ;Finished All Dots?
                BNE   MOVEX4          ;Branch if All Dots Not Done
;                                     ;Else, Test Rest of Count:
                INC   HCOUNT          ;Advance Hi-Res Line Step [-Dots Needed]
;                                     ;HCount = [-DX-DY-1] = No. of Dots needed
                BEQ   BAS_RTS27       ;EXIT if All Dots Done: Return to Caller
;              ---------------------- ;Else, Test Direction:
MOVEX4          LDA   HGRQUAD         ;Get Hi-Res Drawing Quadrant
;                                     ;^Bit 7 = DY Dir (Pos=Up, Neg=Down);
;                                     ;^Bit 6 = DX Dir (Pos=Right, Neg=Left)
                BCS   MOVEX1L1        ;[LOOP] BGE: Do Next Column (X Dir) Move
                JSR   MVUPDWN0        ;Else, Do Next Row (Y Direction) Move
;              ---------------------- ;Advance Hi-Res Horiz Cursor Position:
                CLC                   ;Prepare for Add with Carry
                LDA   HGRE            ;Get Magnitude of Delta X, Low
                ADC   HGRDX           ;Add Hi-Res Drawing Column, Low
                STA   HGRE            ;Set Magnitude of Delta X, Low
                LDA   HGRE+1          ;Get Magnitude of Delta X, High
                ADC   HGRDX+1         ;Add Hi-Res Drawing Column, High
;              ---------------------- ;(A)=(Magnitude of Delta X, Hi); Next Dot:
                BVC   MOVEX3L2        ;[LOOP] Branch if NO Overflow; Always Taken
; 
; ==============================================================================
; Graphics On-the-Fly Color Bit Mask Table                    (Binary Constants)
; ==============================================================================
; Remember Bits in Hi-Res Byte are Backwards Order:    Byte N   Byte N+1
;                                                    S7654321   SEDCBA98
; ==============================================================================
; 
MSKTBL          DFB   %10000001       ;Mask Hi-Res Byte Sign Bit & Column Bit 1
                DFB   %10000010       ;Mask Hi-Res Byte Sign Bit & Column Bit 2
                DFB   %10000100       ;Mask Hi-Res Byte Sign Bit & Column Bit 3
                DFB   %10001000       ;Mask Hi-Res Byte Sign Bit & Column Bit 4
                DFB   %10010000       ;Mask Hi-Res Byte Sign Bit & Column Bit 5
                DFB   %10100000       ;Mask Hi-Res Byte Sign Bit & Column Bit 6
                DFB   %11000000       ;Mask Hi-Res Byte Sign Bit & Column Bit 7
; 
; ==============================================================================
CON_1C          DFB   %00011100       ;Mask for "FGH" Bits [($1C)=(%00011100)]
;                                     ; Y-Coord   GBASH     GBASL
;                                     ;ABCDEFGH (PPPFGHCD) EABAB000
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
; 
; ==============================================================================
; Cosine Table                         (Used by DRAW and XDRAW as Defined Words)
; ==============================================================================
; COS(90*X/16 Degrees)*$100-1; with one-byte precision, X=0 ~ (+/-)16 (17 Bytes)
; ------------------------------------------------------------------------------
; Indexed via DRAW & XDRAW [for Cosines (DX's) & Sines (DY's)] like so:
;   LDY COSTBL,X   where X is a Positive Low Nibble Value, X=0 ~ +16 (for COS's)
; & LDY COSTBL+1,X where X is a Negative Low Nibble Value, X=0 ~ -16 (for SIN's)
; ==============================================================================
; 
;                                              Values 
;                     ----------------------------------------------------------
;                      Hex            ;      Decimal      &     {Low,High}
;                     --------------- ;-------------------|---------------------
COSTBL          DW    $FEFF           ;=(65,279)=(   -257)|(255,254)=(  -1,  -2)
                DW    $F4FA           ;=(62,714)=( -2,822)|(250,244)=(  -6, -12)
                DW    $E1EC           ;=(57,836)=( -7,700)|(236,225)=( -20, -31)
                DW    $C5D4           ;=(50,644)=(-14,892)|(212,197)=( -44, -59)
                DW    $A1B4           ;=(41,396)=(-24,140)|(180,161)=( -76, -95)
                DW    $788D           ;=(30,861)=(-34,675)|(141,120)=(-115,-136)
                DW    $4961           ;=(18,785)=(-46,751)|( 97, 73)=(-159,-183)
                DW    $1831           ;=( 6,193)=(-59,343)|( 49, 24)=(-207,-232)
                DFB   $FF             ;=(   255)=(-65,281)|(255,n/a)=(  -1, n/a)

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Coordinate Restore Subroutine:
; ==============================================================================
; HFIND (Never Called by Applesoft): Computes Current Position of Hi-Res Cursor;
;       Y-Coordinate from GBASH,GBASL & X-Coordinate from HGRHORIZ & HMASK
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; HFIND       [Drop-In Only]        ;Never Referenced [Can Never Happen]
; (Only Exception: User-Callable Entry Point; BASIC: CALL -2,613 or CALL 62,923
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Convert Base Address to Y-Coordinate;
;                                     ;For: GBASL=EABAB000, GBASH=PPPFGHCD;
;                                     ;Generate: Y-Coordinate=ABCDEFGH:
HFIND           LDA   GBASL           ;EABAB000; Get Graphics Base Address, Low
                ASL   A               ;EABAB000; Shift Sign (E) Bit into Carry
                LDA   GBASH           ;PPPFGHCD; Get Graphics Base Address, High
                AND   #%00000011      ;000000CD; AND Graphics Base Address, High
                ROL   A               ;00000CDE; Rotate Left: Carry, Sign (E) Bit
                ORA   GBASL           ;EABABCDE; OR Graphics Base Address, Low
                ASL   A               ;ABABCDE0; Shift Left
                ASL   A               ;BABCDE00; Shift Left
                ASL   A               ;ABCDE000; Shift Left
                STA   HGRY            ;ABCDE000; Save in Vertical Y-Position, Low
                LDA   GBASH           ;PPPFGHCD; Get Graphics Base Address, High
;                                     ;^(PPP=Screen Page)
                LSR   A               ;0PPPFGHC; Shift Right
                LSR   A               ;00PPPFGH; Shift Right
                AND   #%00000111      ;00000FGH; AND with Seven
                ORA   HGRY            ;ABCDEFGH; OR with Vertical Y-Position, Low
                STA   HGRY            ;ABCDEFGH; Set Vertical Y-Position, Low
; ----------------------------------- ;Convert HGRHORIZ & HMASK to X-Coordinate
;                                     ;[X = 7 * HGRHORIZ + (HMASK Bit Position)]
;                                     ;[Range 0-$133]:
                LDA   HGRHORIZ        ;Get Hi-Res Byte Horizontal Index    (I*1)
                ASL   A               ;Double (A): Horizontal Index        (I*2)
                ADC   HGRHORIZ        ;Add Hi-Res Byte Horizontal Index    (I*3)
                ASL   A               ;Double (A): Horizontal Index        (I*6)
;              ---------------------- ;Since (I*7) might not fit in 1 byte,
;                                     ; wait till later for last add:
                TAX                   ;Save (I*6) Horizontal Index
                DEX                   ;[Loop Prep] Reduce (I*6) Hrz.Index (I*6)-1
;                                     ;Find HMASK Bit Position:
                LDA   HMASK           ;Get H/GR On-the-Fly Color Bit Mask
                AND   #%01111111      ;Discard Sign Bit; Keep 7 Lower Bits (LSBs)
;                                     ;^[Sign Bit = 0 will Stop Loop if reached]
HFNDLOOP        INX                   ;Advance (Loop) Shift Counter   (I*6) 1st.
;                                     ;^[Saved (I*6) Horizontl Index] (I*6)+1..N
                LSR   A               ;Shift LSB Right into Carry
                BNE   HFNDLOOP        ;LOOP if LSB was Set; Else, Exit Loop:
                STA   HGRX+1          ;Set Horizontal X-Position, High (=0)
;                                     ;Compute HGRHORIZ*7+LOG2(HMASK):
                TXA                   ;Get Shift Count
;                                     ;^[Saved (I*6) Horizontl Index]   (I*6)+N
;              ---------------------- ;Add HGRHORIZ One More Time:
                CLC                   ;Prepare for Add with Carry
                ADC   HGRHORIZ        ;Add Hi-Res Byte Horizontal Index  (I*7)+N
                BCC   HFNDFIN         ;Branch if No Carryover
                INC   HGRX+1          ;Advance Horizontal X-Position, High
HFNDFIN         STA   HGRX            ;Set Horizontal X-Position, Low    (I*7)+N
BAS_RTS27       RTS                   ;Return to Caller

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Shape Drawing Subroutines:
; ==============================================================================
; 
; ==============================================================================
; DRAW0: Sets Hi-Res Screen Byte Pointer
; ==============================================================================
; DRAW0                             ;Enter: (X,Y) = Shape Starting Address {L,H}
; ^(Never Called by Applesoft)      ;        (A)  = Rotation ($00-$3F)
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; DRAW0       [No Drop-In]          ;Never Referenced [Can Never Happen]
; (Only Exception: User-Callable Entry Point; BASIC: CALL -2,559 or CALL 62,977;
;                  But Need to Set A,X & Y Registers 1st; How? POKES & Pg.3 S/R)
; ------------------------------------------------------------------------------
; 
DRAW0           STX   HSHAPE          ;Set Hi-Res Screen Byte Pointer, Low
                STY   HSHAPE+1        ;Set Hi-Res Screen Byte Pointer, High
; 
; ------------------------------------------------------------------------------
; 
; ==============================================================================
; Draw A Shape: Continues "DRAW" Statement
; ==============================================================================
; DRAW1   [Can Drop-In Too]         ;Enter: (X,Y) = Shape Starting Address {L,H}
;                                     ;        (A)  = Rotation ($00-$3F)
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
;                                     ;[Same as XDRAW, but it Compliments Color]
DRAW1           TAX                   ;Save Rotation Angle [($00-$3F)=(0-63)]
;              ---------------------- ;Divide Rotation by 16 to Get Quadrant:
                LSR   A               ;Shift Right: (A)=(A/2);  NOW
                LSR   A               ;Shift Right: (A)=(A/2); (A/4)
                LSR   A               ;Shift Right: (A)=(A/2); (A/8)
                LSR   A               ;Shift Right: (A)=(A/2); (A/16)
                STA   HGRQUAD         ;Set HGR Drawing Quadrant
;                                     ;^(Dir: Up=0, Right=1, Down=2, Left=3)
;              ---------------------- ;Use Rotation Angle to Index Trig Table
;                                     ;^[to Get COS & SIN, (X,Y) Distances]:
                TXA                   ;Retrieve Rotation Angle [($00-$3F)=(0-63)]
                AND   #%00001111      ;AND w/ Rotation to Get Index (Low Nibble)
                TAX                   ;Set Positive Index into Trig Table for DX
                LDY   COSTBL,X        ;Get COS(90*X/16 Degrees)*$100-1, Low
                STY   HGRDX           ;Save COS in HGRDX, Drawing Column, Low
                EOR   #%00001111      ;Invert (Negate) Low Nibble Bits of Index
                TAX                   ;Set Negative Index into Trig Table for DY
                LDY   COSTBL+1,X      ;Get COS(90*X/16 Degrees)*$100-1, High
                INY                   ;Advance Value Got; Now have SIN, too
                STY   HGRDY           ;Save SIN in HGRDY, Drawing Row
;              ---------------------- ;Prepare to DRAW One Bit:
                LDY   HGRHORIZ        ;Get HGR Hrz.Index frm GBAS to Current Byte
                LDX   #0              ;Clear Index into Trig Table 
                STX   HGRCLSN         ;Clear HGR Collision Counter
                LDA   (HSHAPE,X)      ;Get 1st Byte of SHAPE Definition
DRWLP2          STA   HGRDX+1         ;Store SHAPE Byte in Drawing Column, High
                LDX   #$80            ;Get Initial Value for Fractional Vectors:
                STX   HGRE            ;Set .5 in COS X-Component
                STX   HGRE+1          ;Set .5 in SIN Y-Component
                LDX   HGRSCALE        ;Get Drawing Scale Factor
;              ---------------------- ;Advance COS X-Component:
DRWLP3          LDA   HGRE            ;Get COS X-Component
                SEC                   ;Prepare for Add w/ Carry Set (Adds 1)
                ADC   HGRDX           ;Add COS X-Component to Drawing Column
                STA   HGRE            ;Set COS X-Component
;                                     ;^[Save Fraction Part, No Integer Part]
                BCC   DRW4            ;BLT: Branch if No Carryover; Else, ...*
                JSR   LRUD1           ;* DRAW One Bit (w/o 90 Degree Rotation)
;                                     ;^[Same as XDRAW <- Compliments Color]
;              ---------------------- ;Advance SIN Y-Component:
                CLC                   ;Prepare for Add w/ Carry Clear (Adds 0)
DRW4            LDA   HGRE+1          ;Get SIN Y-Component
                ADC   HGRDY           ;Add SIN Y-Component to Drawing Row
                STA   HGRE+1          ;Set SIN Y-Component
;                                     ;^[Save Fraction Part, No Integer Part]
                BCC   DRW5            ;BLT: Branch if No Carryover; Else, ...*
                JSR   LRUD2           ;* DRAW One Bit (w/ 90 Degree Rotation)
;                                     ;^[Same as XDRAW <- Compliments Color]
;              ---------------------- ;Next Iteration:
DRW5            DEX                   ;Reduce Drawing Scale Factor
                BNE   DRWLP3          ;LOOP if Still on Same SHAPE Item
                LDA   HGRDX+1         ;Get Next SHAPE Item
;                                     ;Go to Next 3-Bit Vector:
                LSR   A               ;Shift Right: 1st Bit Out
                LSR   A               ;Shift Right: 2nd Bit Out
                LSR   A               ;Shift Right: 3rd Bit Out
                BNE   DRWLP2          ;LOOP if More in this SHAPE Byte
                INC   HSHAPE          ;Advance to Next SHAPE Byte, Low
                BNE   DRW6            ;Branch Until Page Boundary Reached
                INC   HSHAPE+1        ;Advance to Next SHAPE Byte, High
DRW6            LDA   (HSHAPE,X)      ;Get Next Byte of SHAPE Definition
                BNE   DRWLP2          ;LOOP if SHAPE Definition <> 0
                RTS                   ;Else, Finished, Return to Caller

; ==============================================================================
; High-Resolution Graphics Mode (Hi-Res) Shape XDRAW Subroutine:
; ==============================================================================
; 
; ==============================================================================
; XDRAW0: Sets Hi-Res Screen Byte Pointer
; ==============================================================================
; XDRAW0                            ;Enter: (X,Y) = Shape Starting Address {L,H}
; ^(Never Called by Applesoft)      ;        (A)  = Rotation ($00-$3F)
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; XDRAW0      [No Drop-In]          ;Never Referenced [Can Never Happen]
; (Only Exception: User-Callable Entry Point; BASIC: CALL -2,467 or CALL 63,069;
;                  But Need to Set A,X & Y Registers 1st; How? POKES & Pg.3 S/R)
; ------------------------------------------------------------------------------
; 
XDRAW0          STX   HSHAPE          ;Set Hi-Res Screen Byte Pointer, Low
                STY   HSHAPE+1        ;Set Hi-Res Screen Byte Pointer, High
; 
; ------------------------------------------------------------------------------
; 
; ==============================================================================
; XDraw A Shape: Continues "XDRAW" Statement
; ==============================================================================
; XDRAW1  [Can Drop-In Too]         ;Enter: (X,Y) = Shape Starting Address {L,H}
;                                     ;        (A)  = Rotation ($00-$3F)
; ------------------------------------------------------------------------------
; Note: X-Coordinate = X-Position = Column; Y-Coordinate = Y-Position = Row
; ==============================================================================
; 
;                                     ;[Same as DRAW, but Compliments Color]
XDRAW1          TAX                   ;Save Rotation Angle [($00-$3F)=(0-63)]
;              ---------------------- ;Divide Rotation by 16 to Get Quadrant:
                LSR   A               ;Shift Right: (A)=(A/2);  NOW
                LSR   A               ;Shift Right: (A)=(A/2); (A/4)
                LSR   A               ;Shift Right: (A)=(A/2); (A/8)
                LSR   A               ;Shift Right: (A)=(A/2); (A/16)
                STA   HGRQUAD         ;Set HGR Drawing Quadrant
;                                     ;^(Dir: Up=0, Right=1, Down=2, Left=3)
;              ---------------------- ;Use Rotation Angle to Index Trig Table
;                                     ;^[to Get COS & SIN, (X,Y) Distances]:
                TXA                   ;Retrieve Rotation Angle [($00-$3F)=(0-63)]
                AND   #%00001111      ;AND w/ Rotation to Get Index (Low Nibble)
                TAX                   ;Set Positive Index into Trig Table for DX
                LDY   COSTBL,X        ;Get COS(90*X/16 Degrees)*$100-1, Low
                STY   HGRDX           ;Save COS in HGRDX, Drawing Column, Low
                EOR   #%00001111      ;Invert (Negate) Low Nibble Bits of Index
                TAX                   ;Set Negative Index into Trig Table for DY
                LDY   COSTBL+1,X      ;Get COS(90*X/16 Degrees)*$100-1, High
                INY                   ;Advance Value Got; Now have SIN, too
                STY   HGRDY           ;Save SIN in HGRDY, Drawing Row
;              ---------------------- ;Prepare to DRAW One Bit:
                LDY   HGRHORIZ        ;Get HGR Hrz.Index frm GBAS to Current Byte
                LDX   #0              ;Clear Index into Trig Table
                STX   HGRCLSN         ;Clear HGR Collision Counter
                LDA   (HSHAPE,X)      ;Get 1st Byte of SHAPE Definition
XDRWLP2         STA   HGRDX+1         ;Store SHAPE Byte in Drawing Column, High
                LDX   #$80            ;Get Initial Value for Fractional Vectors:
                STX   HGRE            ;Set .5 in COS X-Component
                STX   HGRE+1          ;Set .5 in SIN Y-Component
                LDX   HGRSCALE        ;Get Drawing Scale Factor
;              ---------------------- ;Advance COS X-Component:
XDRWLP3         LDA   HGRE            ;Get COS X-Component
                SEC                   ;Prepare for Add w/ Carry Set (Adds 1)
                ADC   HGRDX           ;Add COS X-Component to Drawing Column
                STA   HGRE            ;Set COS X-Component
;                                     ;^[Save Fraction Part, No Integer Part]
                BCC   XDRW4           ;BLT: Branch if No Carryover; Else, ...*
                JSR   LRUDX1          ;* XDRAW One Bit (w/o 90 Degree Rotation)
;                                     ;^[Same as DRAW, but Compliments Color]
;              ---------------------- ;Advance SIN Y-Component:
                CLC                   ;Prepare for Add w/ Carry Clear (Adds 0)
XDRW4           LDA   HGRE+1          ;Get SIN Y-Component
                ADC   HGRDY           ;Add SIN Y-Component to Drawing Row
                STA   HGRE+1          ;Set SIN Y-Component
;                                     ;^[Save Fraction Part, No Integer Part]
                BCC   XDRW5           ;BLT: Branch if No Carryover; Else, ...*
                JSR   LRUDX2          ;* XDRAW One Bit (w/ 90 Degree Rotation)
;                                     ;^[Same as DRAW, but Compliments Color]
;              ---------------------- ;Next Iteration:
XDRW5           DEX                   ;Reduce Drawing Scale Factor
                BNE   XDRWLP3         ;LOOP if Still on Same SHAPE Item
                LDA   HGRDX+1         ;Get Next SHAPE Item
;                                     ;Go to Next 3-Bit Vector:
                LSR   A               ;Shift Right: 1st Bit Out
                LSR   A               ;Shift Right: 2nd Bit Out
                LSR   A               ;Shift Right: 3rd Bit Out
                BNE   XDRWLP2         ;LOOP if More in this SHAPE Byte
                INC   HSHAPE          ;Advance to Next SHAPE Byte, Low
                BNE   XDRW6           ;Branch Until Page Boundary Reached
                INC   HSHAPE+1        ;Advance to Next SHAPE Byte, High
XDRW6           LDA   (HSHAPE,X)      ;Get Next Byte of SHAPE Definition
                BNE   XDRWLP2         ;LOOP if SHAPE Definition <> 0
                RTS                   ;Else, Finished, Return to Caller

; ==============================================================================
; Parsing Routines used by BASIC for Hi-Res Access:
; ==============================================================================
; 
; ==============================================================================
; HFNS Subroutine: Get Hi-Res Plotting Coordinates (0-279,0-191) from TXTPTR
;                  Leave Registers set for HPOSN: (X,Y) = X-Coordinate (Column)
;                                                  (A)  = Y-Coordinate (Row)
; ==============================================================================
; 
;              ---------------------- ;Evaluate Expression; Must be Numeric:
HFNS            JSR   FRMNUM          ;Get Value Specified as 16-Bit Integer
                JSR   GETADR          ;Convert FAC to a 16-bit Value in LINNUM
;              ---------------------- ;Get Column-Coord in (X,Y)={Low,High}:
                LDY   LINNUM+1        ;Get Horizontal-Column X-Coordinate, High
                LDX   LINNUM          ;Get Horizontal-Column X-Coordinate, Low
                CPY   #>HGRWIDE       ;< 280 Pixels: HGR Screens Width, High?
                BCC   HFNS1           ;BLT: Branch if in Range, < 280 Pixels
                BNE   GGERR           ;Branch if Too Big (>=280); Throw IQ ERROR
                CPX   #<HGRWIDE       ;< 280 Pixels: HGR Screens Width, Low?
                BCS   GGERR           ;Branch if Too Big (>=280); Throw IQ ERROR
;                                     ;Else, in Range, < 280 Pixels ...
;              ---------------------- ;Stack Column-Coordinate:
HFNS1           TXA                   ;Get Horizontal-Column X-Coordinate, Low
                PHA                   ;Push Horizontal-Column X-Coordinate, Low
                TYA                   ;Get Horizontal-Column X-Coordinate, High
                PHA                   ;Push Horizontal-Column X-Coordinate, High
;              ---------------------- ;Get Row-Coordinate in Accumulator (A):
                LDA   #','            ;Require a Comma (at TXTPTR)
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
                JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                CPX   #HGRHIGH        ;< 192 Pixels: HGR Screens Height?
                BCS   GGERR           ;Branch if Too Big (>=192); Throw IQ ERROR
                STX   FAC             ;Save Vertical-Row Y-Coordinate in FAC
;              ---------------------- ;Retrieve Column & Row Coordinates:
                PLA                   ;Pull Horizontal-Column X-Coordinate, High
                TAY                   ;Set Horizontal-Column X-Coordinate, High
                PLA                   ;Pull Horizontal-Column X-Coordinate, Low
                TAX                   ;Set Horizontal-Column X-Coordinate, Low
                LDA   FAC             ;Set Vertical-Row Y-Coordinate from FAC
;              ---------------------- ;Finished (with Registers set for HPOSN):
                RTS                   ;Return to Caller

GGERR           JMP   BAS_GOERR       ;Go Print "?Illegal Quantity" Error Message

; ==============================================================================
; "HCOLOR=" Statement: Immediate & Deferred; Parameter: HCOLOR = Aexpr; (0~7)
; ==============================================================================
; Sets High-Resolution Graphics Color; Color Names & Associated Values:
; +------------+-------------+---------------------------+---------------------+
; |  0 Blackl  |  4 Black2  _/  1 Green (depends on TV)  |  5 (depends on TV)  |
; |  3 Whitel  |  7 White2   \  2 Blue  (depends on TV)  |  6 (depends on TV)  |
; +------------+-------------+---------------------------+---------------------+
; A High-Resolution Dot plotted with HCOLOR=3 (White) will be Blue if the 
; X-Coordinate of the Dot is Even, Green if the X-Coordinate is Odd, and White
; only if both (X,Y) & (X+1,Y) are plotted; This is due to the way home TVs work
; [the Technology of the Time (late 1970s)--JPD]
; ==============================================================================
; 
HCOLOR          JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                CPX   #$08            ;Value must be 0~7
                BCS   GGERR           ;Branch if Too Big (>=8); Throw IQ ERROR
                LDA   COLORTBL,X      ;Get Color Pattern from Table
                STA   HGRCOLOR        ;Save Hi-Res Graphics Color
BAS_RTS28       RTS                   ;Return to Caller

; ==============================================================================
; High Resolution Graphics Colors Table
; ==============================================================================
; 
COLORTBL        DFB   %00000000       ;Black1
                DFB   %00101010       ;Green
                DFB   %01010101       ;Violet
                DFB   %01111111       ;White1
                DFB   %10000000       ;Black2
                DFB   %10101010       ;Orange
                DFB   %11010101       ;Cyan (Light-Blue)
                DFB   %11111111       ;White2

; ==============================================================================
; "HPLOT" Statement: Immediate & Deferred
; ==============================================================================
; Parameters: HPLOT Aexprl, Aexpr2 [{TO Aexpr3, Aexpr4}]
; -----------------------------------------------------------------------------
; HPLOT Plots a High-Resolution Dot, or a Line from the Last Dot Plotted, & may
; be Extended (Subject to Screen Limits & Character Instruction Limits)
; ==============================================================================
; 
HPLOT           CMP   #TOK_TO         ;Continue Plotting "TO" Requested?
                BEQ   HPLOT2          ;YES, Start from Current Location
                JSR   HFNS            ;NO, Get Starting Point of Line
                JSR   HPLOT0          ;Plot Point & Prep to Draw a Line from it
HPLOTLOOP       JSR   CHRGOT          ;Get Character at End of Expression
                CMP   #TOK_TO         ;Is a Line Specified?
                BNE   BAS_RTS28       ;NO, Exit: a Line is Not Specified
;                                     ;YES, Advance TXTPTR
;                                     ;(Why Not CHRGET? A: CMP Sets Carry)
HPLOT2          JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
                JSR   HFNS            ;Get Point Coordinates at End of Line
;                                     ;Prepare to Continue Plotting "TO" Line:
                STY   DSCTMP          ;Swap (Y) into (T)
                TAY                   ;Swap (A) into (Y)
                TXA                   ;Swap (X) into (A)
                LDX   DSCTMP          ;Swap (T) into (X)
                JSR   HGLIN           ;Plot Line
                JMP   HPLOTLOOP       ;LOOP Until No More "TO" Phrases

; ==============================================================================
; "ROT=" Statement: Immediate & Deferred; Parameter: ROT = Aexpr
; ==============================================================================
; Sets Angular Rotation for SHAPE to be Drawn by DRAW or XDRAW
; ==============================================================================
; 
ROT             JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                STX   HGRROT          ;Set Hi-Res Graphics Rotation Value
                RTS                   ;Return to Caller

; ==============================================================================
; "SCALE=" Statement: Immediate & Deferred; Parameter: SCALE = Aexpr
; ==============================================================================
; Sets SCALE Size for SHAPE to be Drawn by DRAW or XDRAW
; ==============================================================================
; 
SCALE           JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                STX   HGRSCALE        ;Set Hi-Res Graphics Drawing Scale Factor
                RTS                   ;Return to Caller

; ==============================================================================
; DRWPTR Subroutine: Prepares for DRAW & XDRAW:
; ==============================================================================
; 
; ----------------------------------- ;Find & Check SHAPE Number Specified:
DRWPTR          JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
;                                     ;Setup Pointer to SHAPE Table Start:
                LDA   HGRSHPTR        ;Get HGR SHAPE Pointer, Low
                STA   HSHAPE          ;Set SHAPE Table Start Pointer, Low
                LDA   HGRSHPTR+1      ;Get HGR SHAPE Pointer, High
                STA   HSHAPE+1        ;Set SHAPE Table Start Pointer, High
                TXA                   ;Get SHAPE Number Specified
;              ---------------------- ;Compare to Total No. of SHAPEs in Table:
                LDX   #0              ;Clear (Indexed Indirect) Addressing Index
                CMP   (HSHAPE,X)      ;Subtract Total Number of SHAPE Definitions
                BEQ   DRWPTR1         ;Branch if Both Numbers of SHAPEs are Equal
                BCS   GGERR           ;Else, Branch if Spec Too Big; Throw IQ ERR
; ----------------------------------- ;Else, Find Address of SHAPE in Table:
DRWPTR1         ASL   A               ;Double SHAPE Number Specified for Index
                BCC   DRWPTR2         ;Branch if SHAPE Number Specified < 128
                INC   HSHAPE+1        ;Advance SHAPE Table Start Pointer, High
;              ---------------------- ;Get Offset frm SHAPE Table Offsets Index:
                CLC                   ;Prepare for Add with Carry
DRWPTR2         TAY                   ;Get Index into SHAPE Table Offsets Index
                LDA   (HSHAPE),Y      ;Get SHAPE Offset, Low
                ADC   HSHAPE          ;Add SHAPE Table Start Pointer, Low
                TAX                   ;Save Low Address of SHAPE in Table
                INY                   ;INC Index into SHAPE Table Offsets Index
                LDA   (HSHAPE),Y      ;Get SHAPE Offset, High
                ADC   HGRSHPTR+1      ;Add HGR SHAPE Pointer, High
;              ---------------------- ;Save Address of SHAPE in Table:
                STA   HSHAPE+1        ;Set SHAPE Start Pointer, High
                STX   HSHAPE          ;Set SHAPE Start Pointer, Low
; ----------------------------------- ;Any More "AT" Position Coordinates?
                JSR   CHRGOT          ;Get Last Char/Token Got
                CMP   #TOK_AT         ;Is it an "AT" Phrase?
                BNE   DRWPTR3         ;Branch if Not: DRAW at Current Position
;              ---------------------- ;Else, Scan "AT" Position Coordinates:
                JSR   SYNCHR          ;If = Chr Got, Get Next; Else, Syntax Error
                JSR   HFNS            ;Get Column & Row to Start Drawing SHAPE
                JSR   HPOSN           ;Set Hi-Res Cursor at Position Coordinates
; ----------------------------------- ;DRAW at Current Position:
DRWPTR3         LDA   HGRROT          ;Get Rotation Value
                RTS                   ;Return to Caller

; ==============================================================================
; "DRAW" Statement: Immediate & Deferred;
;                   Parameters: DRAW Aexprl [AT Aexpr2, Aexpr3]
; ==============================================================================
; DRAWs a SHAPE (Aexprl)=(0~255) in High-Resolution Graphics at (X,Y)=(Aexpr2,
; Aexpr3)=(0~278,0~191) from a SHAPE Table previously loaded into Memeory using
; SHLOAD (from Tape) or BLOAD (from Disk), or typed in using Apple's F8 Monitor
; Program.
; ==============================================================================
; 
;                                     ;[Same as XDRAW, but it Compliments Color]
DRAW            JSR   DRWPTR          ;Prepare for DRAW|XDRAW
                JMP   DRAW1           ;Go DRAW 1 Shape

; ==============================================================================
; "XDRAW" Statement: Immediate & Deferred;
;                    Parameters: XDRAW Aexprl [AT Aexpr2, Aexpr3]
; ==============================================================================
; Provides a way to Erase SHAPEs previously Drawn: XDRAWing a SHAPE at the same
; Location, Rotation, & Scale previously Drawn will Erase it without Erasing its
; Background; Same as DRAW, except Color used to XDRAW SHAPE is Complement of
; Color already existing at each Point plotted; Pairs of Complementary Colors
; are: Black & White; Cyan (or Light-Blue) & Green; and Violet & Orange
; ==============================================================================
; 
;                                     ;[Same as DRAW, but Compliments Color]
XDRAW           JSR   DRWPTR          ;Prepare for DRAW|XDRAW
                JMP   XDRAW1          ;Go XDRAW 1 Shape

; ==============================================================================
; "SHLOAD" Command Statement: Immediate & Deferred; No Parameters or Options
; ==============================================================================
; Reads/Loads a SHAPE Table from Cassette Tape to a Position just below HIMEM,
; which is then moved to just below the SHAPE Table LOADed
; ==============================================================================
; 
; ----------------------------------- ;Prepare to Load Shape Table from Tape:
;              ---------------------- ;Prepare to Read 2 Bytes into LINNUM:
SHLOAD          LDA   #0              ;Clear Accumulator
                STA   A1H             ;Clear Monitor General Purpose A1-Reg, High
                STA   A2H             ;Clear Monitor General Purpose A2-Reg, High
                LDY   #LINNUM         ;Get ZP Address of LINNUM
                STY   A1L             ;Set Monitor General Purpose A1-Reg, Low
                INY                   ;Get ZP Address of LINNUM+1
                STY   A2L             ;Set Monitor General Purpose A2-Reg, Low
;              ---------------------- ;Read Length into LINNUM:
                JSR   MON_READ        ;Go Read 2 Bytes of Data from Tape
;              ---------------------- ;Prepare to Read LINNUM Bytes, Starting at
; 
;                                     ;(HIMEM)-(LINNUM) & Ending at (HIMEM)-1:
                CLC                   ;Prepare to Subtract w/ Borrow [A-Data-!C]
                LDA   MEMSIZ          ;Get Top End of String Space (HIMEM), Low
                TAX                   ;Set (X)=[String Space End (HIMEM), Low]
                DEX                   ;(X)=[(HIMEM)-1] Forming End Pointer, Low
                STX   A2L             ;Set Monitor General Purpose A2-Reg, Low
                SBC   LINNUM          ;[(HIMEM)-(LINNUM)] Forming Start Ptr, Low
                PHA                   ;Push Start Pointer, Low
                LDA   MEMSIZ+1        ;Get Top End of String Space (HIMEM), High
                TAY                   ;Set (Y)=[String Space End (HIMEM), High]
                INX                   ;Set (X)=[String Space End (HIMEM), Low]
                BNE   SHLOAD1         ;Branch if Not at Page Boundary
                DEY                   ;(Y)=[(HIMEM)-1] Forming End Pointer, High
SHLOAD1         STY   A2H             ;Set Monitor General Purpose A2-Reg, High
                SBC   LINNUM+1        ;[(HIMEM)-(LINNUM)] Forming Start Ptr, High
                CMP   STREND+1        ;Subtract End of Vars & Ptrs Storage, High
;                                     ;^[AKA: Bottom/Start of Free Space]
                BCC   SHLOAD2         ;Branch if SHLOAD would clobber Vars & Ptrs
                BNE   SHLOAD3         ;Branch if SHLOAD has sufficient Free Space
SHLOAD2         JMP   MEMERR          ;Throw an "?Out Of Memory" Error

; ----------------------------------- ;Load Shape Table from Tape:
;              ---------------------- ;(A)=[(HIMEM)-(LINNUM)] Start Ptr, High:
SHLOAD3         STA   MEMSIZ+1        ;Set Top End of String Space (HIMEM), High
                STA   FRETOP+1        ;Set FreSpcEnd/StringStorageStart Ptr, High
                STA   A1H             ;Set Monitor General Purpose A1-Reg, High
                STA   HGRSHPTR+1      ;Set Hi-Res Graphics Shape Pointer, High
                PLA                   ;Pull [(HIMEM)-(LINNUM)] Start Pointer, Low
                STA   HGRSHPTR        ;Set Hi-Res Graphics Shape Pointer, Low
                STA   MEMSIZ          ;Set Top End of String Space (HIMEM), Low
                STA   FRETOP          ;Set FreSpcEnd/StringStorageStart Ptr, Low
                STA   A1L             ;Set Monitor General Purpose A1-Reg, Low
                JSR   RD2BIT          ;Read Two Bits, Tape Transitions; Find Edge
                LDA   #3              ;Create Short Delay for Intermediate Header
                JMP   MON_READ2       ;Go Read Shape Table into (A1-Reg)

; 
; ==============================================================================
; Non-Graphics Subroutines:
; ==============================================================================
; 
; ==============================================================================
; Tape Array STORE & RECALL Routines: 
; ==============================================================================
; 
; ==============================================================================
; Called by STORE & RECALL: 
; Point Tape Array Data Pointers at First Value in Specified Array
; ==============================================================================
; NOTE: (ARYPTR) = (HIGHDS)
; ------------------------------------------------------------------------------
;       (ARYPTR) = Applesoft Array Pointer
;       (HIGHDS) = Highest Destination Adrs +1
; ==============================================================================
; 
; ----------------------------------- ;Compute Offset to Next Variable:
TAPEPTR         CLC                   ;Prepare for Add with Carry
                LDA   LOWTR           ;Get Specified Array Variable Pointer, Low
                ADC   LINNUM          ;Add Array Size, Low
                STA   A2L             ;Set Monitor General Purpose A2-Reg, Low
                LDA   LOWTR+1         ;Get Specified Array Variable Pointer, High
                ADC   LINNUM+1        ;Add Array Size, High
                STA   A2H             ;Set Monitor General Purpose A2-Reg, High
;                                     ;A2 Now has Offset to Next Variable
; ----------------------------------- ;Get Address of 1st Value in Array:
                LDY   #4              ;Point to Number of Array Dimensions
;                                     ;^[Data within Array Variable Pointer]
                LDA   (LOWTR),Y       ;Get Number of Array Dimensions
                JSR   GETARY2         ;Compute Address of 1st Value in Array
;                                     ;ARYPTR Now has Adrs of 1st Value in Array
                LDA   ARYPTR          ;Get Array Pointer, Low
                STA   A1L             ;Set Monitor General Purpose A1-Reg, Low
                LDA   ARYPTR+1        ;Get Array Pointer, High
                STA   A1H             ;Set Monitor General Purpose A1-Reg, High
;                                     ;A1 Now has Address of 1st Value in Array
                RTS                   ;Return to Caller

; ==============================================================================
; Called by STORE & RECALL: Points LOWTR at Array Specified if Found
; ==============================================================================
; 
;                                     ;Get an Array Pointer:
GETARYPTR       LDA   #$40            ;Prepare to Flag "Called from GETARYPTR"
                STA   SUBFLG          ;Set Subscript Flag ($00=Allowed, $80=NOT)
                JSR   PTRGET          ;Locate Variable: Returns Address
;                                     ; in VARPTR & [(A,Y)={Low,High}]
                LDA   #$00            ;Prepare to Allow Subscripts
                STA   SUBFLG          ;Set Subscript Flag ($00=Allowed, $80=NOT)
;                                     ;Prepare to Read/Write a 3-Byte Header 
;                                     ;from/to a Cassette Tape (Audio I/O):
                JMP   VARTIO          ;Point A1/A2 at LINNUM/TEMPPT ZP-Pointers

; ==============================================================================
; "HTAB" Statement: Immediate & Deferred; Parameter: HTAB Aexprl
; ==============================================================================
; Moves the Cursor to the Column Position Specified (Aexprl), on the Current
; Screen Line, Relative to the Left Margin of the Text Window, but Independent
; of the Line Width
; ==============================================================================
; 
;                                     ;Get Column Position Specified:
HTAB            JSR   GETBYT          ;Convert Expression to a Byte in X-Reg
                DEX                   ;Reduce Column Position Specified (-1)
                TXA                   ;Get Text Screen Position (0~255)
; <<< If WNDLFT <> (0), HTAB can Print Outside of Screen, within Program! >>>
HTABLOOP        CMP   #BASL           ;Is it More or Less than Text Screen Width?
                BCC   HTABEXIT        ;BLT: Branch if it is < 1 Screen Width
                SBC   #BASL           ;Else, Subtract 1 Screen Width & Add a Line
                PHA                   ;Push Reduced HTAB Value
                JSR   CRDO            ;Print a Carriage <Return> Character
                PLA                   ;Pull Reduced HTAB Value
                JMP   HTABLOOP        ;LOOP Until it is < 1 Screen Width

HTABEXIT        STA   CH              ;Set Cursor Horizontal Displacement
                RTS                   ;Return to Caller

; ==============================================================================
; Someone's initials?  K?  R?  W?  Richard Weiland?
; ==============================================================================
; IIRC, I read, or heard somewhere, long ago, that this was a plea inserted by
; one of the authors because he had cancer, meaning: "Kill Ric Weiland!" 
; 
; RIP: Richard W. "Ric" Weiland (April 21, 1953 - June 24, 2006)
; 
; But, it is not in any of these . . .
; 
; References: 
; 
; Applesoft BASIC <https://en.wikipedia.org/wiki/Applesoft_BASIC>
; Ric Weiland <https://en.wikipedia.org/wiki/Ric_Weiland>    <--[Most likely!]
; Steve Wozniak <https://en.wikipedia.org/wiki/Steve_Wozniak>
; Randy Wigginton <https://en.wikipedia.org/wiki/Randy_Wigginton>
; ==============================================================================
KRW             ASC   ^"KRW"          ;Someone's initials?  K?  R?  W?

; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; ==============================================================================
; Applesoft - End of all Parts
; ==============================================================================
; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
; 
; <---[$F8 Page Boundary]
; 
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; ==============================================================================
; ROM Space ($F800-$FFFF): ROM Socket $F8 on a real Apple II Plus. 
; ==============================================================================
; ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
; 
; ==============================================================================
; ORIGIN  EQU $F800 ;Old Monitor ROM or New Autostart Monitor ROM Start Address.
;                   ;Or, Language Card Additional ROM/RAM: 
;                   ;When Language Card {ROM/RAM} is Deselected, {RAM/ROM} on
;                   ;Card is Active, {respectively}.
; ==============================================================================
; 
; 
; ==============================================================================
; New Monitor ROM (Modified AutoStart Image):
; ==============================================================================
; Apple II Monitor II by Steve Wozniak.  Modified Nov 1978 by John A
; Copyright 1978 by Apple Computer, Inc.  All Rights Reserved. 
; ==============================================================================
; 
; ==============================================================================
; Monitor Low Resolution Graphics Plotting Routines:
; ==============================================================================
; 
; ----------------------------------- ;Plot a Point on Lo-Res Screen:
;                                     ;[Enter with (A)=Row; (Y)=Column]
MON_PLOT        LSR   A               ;(A)=(Y-Coordinate/2)
                PHP                   ;Push Status (P-Reg); Save Carry (LSB)
                JSR   GBASCALC        ;Calculate Base Address in GBASL,H
                PLP                   ;Pull Status (P-Reg); Retrieve Carry (LSB)
                LDA   #%00001111      ;Mask $0F if Even
                BCC   RTMASK          ;Branch if LSB (in Carry) is a Zero
                ADC   #%11100000      ;Mask $F0 if Odd; (Adds 1 with Carry Set)
;                                     ;^[($0F+$01)+($E0) = ($10)+($E0) = ($F0)]
RTMASK          STA   MASK            ;Store AND Mask (for High/Low Nibble)
; 
; ----------------------------------- ;Plot a Square Point on Lo-Res Screen:
;                                     ;[I/O: (GBASL,H & MASK)=Row; (Y)=Column]
PLOT1           LDA   (GBASL),Y       ;Get Data
                EOR   HMASK           ;XOR with Color; [Set HMASK 1st!]
                AND   MASK            ;AND with Nibble Mask
                EOR   (GBASL),Y       ;XOR with Data
                STA   (GBASL),Y       ;Set Data
                RTS                   ;Return to Caller

; ----------------------------------- ;Draw Horizontal Line on Lo-Res Screen:
;                                     ;[Enter with (A)=Row; (Y)~(H2)=Column
; Ends]
HLINE           JSR   MON_PLOT        ;Plot Square
; 
; ----------------------------------- ;Draw Horizontal Line on Lo-Res Screen:
;                                     ;[(GBASL,H & MASK)=Row
;                                     ; (Y)~(H2)=Column Ends]
HLINE1          CPY   H2              ;Done?
                BCS   MON_RTS1        ;YES, Return to Caller
                INY                   ;NO, Advance Index (X-Coordinate)
                JSR   PLOT1           ;Plot Next Square
                BCC   HLINE1          ;Loop; Always Taken
; 
; ----------------------------------- ;Draw Vertical Line on Lo-Res Screen:
; LOOP                                ;[(A+1+Carry)~(V2)=Row Ends; (Y)=Column]
VLINEZ          ADC   #1              ;(A)=[Next Row (Y-Coordinate)]
; 
; ----------------------------------- ;Draw Vertical Line on Lo-Res Screen:
;                                     ;[Enter w/ (A)~(V2)=Row Ends; (Y)=Column]
VLINE           PHA                   ;Push Next Row 
                JSR   MON_PLOT        ;Plot Square
                PLA                   ;Pull Next Row
;              vvv ------------------ ;"Apple II Monitors Peeled" Entry Point:
;              vvv                    ;[(A+1)~(V2)=Row Ends; (Y)=Column]
VLINE2          CMP   V2              ;Done?
                BCC   VLINEZ          ;NO, LOOP
MON_RTS1        RTS                   ;Return to Caller

; ----------------------------------- ;Clear Full (48 Lines on) Lo-Res Screen:
CLRSCR          LDY   #47             ;Maximize Y for Full Screen
                BNE   CLRSCR2         ;Always Taken

; ----------------------------------- ;Clear Top (40 Lines on) Lo-Res Screen:
CLRTOP          LDY   #39             ;Maximize Y for Top Screen
; 
; ----------------------------------- ;Clear Partial Lo-Res Screen:
;                                     ;^[(0~Y) Lines, 40 Columns]
CLRSCR2         STY   V2              ;Store as Bottom Coordinate for VLINE Calls
;              vvv ------------------ ;"Apple II Monitors Peeled" Entry Point:
;              vvv                    ;^[(0~V2) Lines, 40 Columns]
CLRSCR4         LDY   #39             ;Rightmost X-Coordinate (Column)
; 
; ----------------------------------- ;Clear Partial Lo-Res Screen:
;                                     ;^[(0~V2) Lines, (0~Y) Columns]
CLRSCR3         LDA   #0              ;Top Coordinate for VLINE Calls
                STA   HMASK           ;Clear Color (to Black)
;              vvv ---------------- ;"Apple II Monitors Peeled" Entry Point:
;              vvv                  ;Clear Color to whatever HMASK is upon entry
;              vvv                  ;^[(A) Must be Preset to Zero]
CLRSCR5         JSR   VLINE           ;Draw VLINE
                DEY                   ;Next Leftmost X-Coordinate
                BPL   CLRSCR3         ;Loop Until Done
                RTS                   ;Return to Caller

; ==============================================================================
; Calculate Graphics Base Address (BASH,BASL) for Left End of Screen Line Number
; (Not Lo-Res GR Line Number) in A-Reg [Range: (0~23)=($00~$17)=(%00000~%10111)]
; ==============================================================================
; GBASCALC [to set Graphics Base Address (GBASH,GBASL)] is almost identical to
;  BASCALC [to set Text Line Base Address (BASH,BASL)]
; ---------------------------vv-------------------------vv----------vv----vv----
; F847: 48 4A 29 03 09 04 85 27 68 29 18 90 02 69 7F 85 26 0A 0A 05 26 85 26 60
; FBC1: 48 4A 29 03 09 04 85 29 68 29 18 90 02 69 7F 85 28 0A 0A 05 28 85 28 60
; ------------------------------------------------------------------------------
; Note: Indexed Addressing of the Base Address ZP Pointers would allow S/R's 
; to be combined into one S/R with one or two different Entry Points to preset 
; which task is being processed (e.g., GBASL,X & GBASH,X & X=0 or X=2)
; ------------------------------------------------------------------------------
;     GBASL    EQU     $26            ;Graphics Base Address, Low
;     GBASH    EQU     $27            ;Graphics Base Address, High
;     BASL     EQU     $28            ;Text Base Address, Low
;     BASH     EQU     $29            ;Text Base Address, High
; ==============================================================================
; 
; ----------------------------------- ;Set Graphics Base Address (GBASH,GBASL):
;                                     ;^[RAM Address of Plotting Line Specified]
GBASCALC        PHA                   ;Push (A)=(GR_Line/2)=[(GBASL) for Input]
;                                     ;^[...(A)=(Text Screen Line # {0~23})]
;                                     ;^[...(A)=((Lo-Res Graphics Line #)/2)]
;                                     ;^[GBASH=ABCDEFGH; GBASL=IJKLMNOP]
;              ---------------------- ;Set Graphics Base Address, High (GBASH):
                LSR   A               ;Set (A)=(GR_Line/4) [GBASH=0ABCDEFG; C=H]
                AND   #%00000011      ;Generate GBASH=000000FG
                ORA   #%00000100      ;Generate GBASH=000001FG
                STA   GBASH           ;Set Graphics Base Address, High (GBASH)
;              ---------------------- ;Set Graphics Base Address, Low  (GBASL):
                PLA                   ;Pull (A)=(GBASL=IJKLMNOP)
                AND   #%00011000      ;Generate GBASL=000LM000
                BCC   GBCALC          ;Skip Next Op if Carry is Clear (C=H=0)
                ADC   #%01111111      ;Generate GBASL=I00LM000 (C=H=1: Adds 1)
;                                     ;^[%00011000 + (%01111111 + 1)= %10011000]
;                                     ;^[%00011000 + (%10000000)    = %10011000]
GBCALC          STA   GBASL           ;Set Graphics Base Address, Low  (GBASL)
;                                     ;       ^[GBASL=(000LM000 | I00LM000)]
                ASL   A               ;Generate GBASL=(00LM0000 = 00LM0000; C=I)
                ASL   A               ;Generate GBASL=(0LM00000 = 0LM00000; C=0)
                ORA   GBASL           ;Generate GBASL=(0LMLM000 | ILMLM000)
                STA   GBASL           ;Set Graphics Base Address, Low  (GBASL)
;              ---------------------- ;Now (GBASH,GBASL)=[%0000,01FG,ILML,M000]
; 
;                                     ;------------+---------+---------+
;                                     ; Lo-Res GR Line Base Addresses: |
;                                     ;------------+---------+---------+
;                                     ;            |  GBASH  |  GBASL  |
;                                     ;------------+---------+---------+
;                                     ;  Top 3rd of GR Screen:         |
;                                     ;------------+---------+---------+
;                                     ;$400, 1024, %0000,0100,0000,0000;
;                                     ;$480, 1152, %0000,0100,1000,0000;
;                                     ;$500, 1280, %0000,0101,0000,0000;
;                                     ;$580, 1408, %0000,0101,1000,0000;
;                                     ;$600, 1536, %0000,0110,0000,0000;
;                                     ;$680, 1664, %0000,0110,1000,0000;
;                                     ;$700, 1792, %0000,0111,0000,0000;
;                                     ;$780, 1920, %0000,0111,1000,0000;
;                                     ;------------+---------+---------+
;                                     ;  Middle 3rd of GR Screen:      |
;                                     ;------------+---------+---------+
;                                     ;$428, 1064, %0000,0100,0010,1000;
;                                     ;$4A8, 1192, %0000,0101,1010,1000;
;                                     ;$528, 1320, %0000,0101,0010,1000;
;                                     ;$5A8, 1448, %0000,0100,1010,1000;
;                                     ;$628, 1576, %0000,0110,0010,1000;
;                                     ;$6A8, 1704, %0000,0110,1010,1000;
;                                     ;$728, 1832, %0000,0111,0010,1000;
;                                     ;$7A8, 1960, %0000,0111,1010,1000;
;                                     ;------------+---------+---------+
;                                     ;  Bottom 3rd of GR Screen:      |
;                                     ;------------+---------+---------+
;                                     ;$450, 1104, %0000,0100,0101,0000;
;                                     ;$4D0, 1232, %0000,0100,1101,0000;
;                                     ;$550, 1360, %0000,0101,0101,0000;
;                                     ;$5D0, 1488, %0000,0101,1101,0000;
;                                     ;$650, 1616, %0000,0110,0101,0000;
;                                     ;$6D0, 1744, %0000,0110,1101,0000;
;                                     ;$750, 1872, %0000,0111,0101,0000;
;                                     ;$7D0, 2000, %0000,0111,1101,0000;
;                                     ;------------+---------+---------+
;                                     ;  GBASH,L:  %0000,01FG,ILML,M000;
;                                     ;------------+---------+---------+
; 
; ----------------------------------- ;Returns: GBASH=000001FG; GBASL=ILMLM000
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; NEXTCOLOR is Not in the New Monitor listing; NXTCOL is the Label here in the
; Old Monitor listing, but it is used elsewhere in this listing; (See below)
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Next Color: Increment Plotting Color by 3
NEXTCOLOR       LDA   HMASK           ;Get Graphics On-the-Fly Color Bit Mask
                CLC                   ;Prepare for Add with Carry
                ADC   #3              ;Advance Plotting Color to Color+3
; ----------------------------------- ;Set Plotting Color to (A)=(0~16,0~16):
SETCOL          AND   #%00001111      ;Discard High Nibble & Keep Low Nibble
;                                     ;^[Math'ly: Sets Color = 17*A Mod 16]
                STA   HMASK           ;Set Graphics On-the-Fly Color Bit Mask
; --<Undocumented User Entry Point>-- ;Shift Low Nibble to High Nibble:
NIBLOHI         ASL   A               ;Make Both Nibbles of Plotting Color Equal
                ASL   A               ;Shift Low Nibble to High Nibble
                ASL   A               ;(%####,0000 <-- <-- <-- <-- %0000,####)
                ASL   A               ;Now High Nibble is what Low Nibble was
                ORA   HMASK           ;OR with Graphics On-the-Fly Color Bit Mask
;                                     ;(%####,0000 OR %0000,#### = %####,####)
                STA   HMASK           ;Set Graphics On-the-Fly Color Bit Mask
                RTS                   ;Return to Caller

; ==============================================================================
; Miniassembler/Disassembler Instruction Display Subroutines
; ==============================================================================
; For an explanation about how this works (sort of), see:
; A 6502 Disassembler from Apple, Dr. Dobbs Journal, 09/76; 
; FTP://Public.Asimov.Net/Pub/Apple_II/Documentation/Programming/6502Assembly/65
; 02%20Disassembler%20-%201976.PDF
; ==============================================================================
; 
; ----------------------------------- ;Get 4-bit Color at Column,Row Coord's:
;                                     ;[Enter with (A)=Row; (Y)=Column]
SCRN            LSR   A               ;(A)=(Y-Coordinate/2)
                PHP                   ;Push Status (P-Reg); Save Carry (LSB)
                JSR   GBASCALC        ;Calculate Base Address in GBASL,H
                LDA   (GBASL),Y       ;Get Colors Byte at Column,Row Coordinates
                PLP                   ;Pull Status (P-Reg); Retrieve Carry (LSB)
;                                     ;Get Right or Left Half-Byte on Carry; 
;                                     ;AKA: Low or High Nibble, Respectively:
;                                     ;[SCRN2--Used by Mini-/Dis-Assembler]
SCRN2           BCC   RTMSKZ          ;If Even, use Low Nibble
; --<Undocumented User Entry Point>-- ;Shift High Nibble to Low Nibble:
NIBHILO         LSR   A               ;If Odd, use High Nibble
                LSR   A               ;Shift High Nibble
                LSR   A               ;... to Low Nibble
                LSR   A               ;Now Low Nibble is what High Nibble was
RTMSKZ          AND   #%00001111      ;Mask 4-Bit Color at Column,Row Coordinates
                RTS                   ;Return to Caller

; ==============================================================================
; Disassembler Instruction Display Subroutine: Prints Program Counter, followed
; by a Blank; Gets an OpCode; Then Generates FORMAT & LENGTH Bytes: 
; ==============================================================================
; 
; ----------------------------------- ;Display Instruction Line Address:
INSDS1          LDX   PCL             ;Get Program Counter, Low
                LDY   PCH             ;Get Program Counter, High
                JSR   PRYX2           ;Print Program Counter [(Y,X)={High,Low}]
;                                     ;Followed by a Dash
                JSR   PRBLNK          ;Followed by a Blank (3 Spaces)
; ----------------------------------- ;Get OpCode, Instruction FORMAT & LENGTH,
;                                     ;& Index into Mnemonic Table:
                LDA   (PCL,X)         ;Get OpCode
INSDS2          TAY                   ;Save OpCode
                LSR   A               ;Even/Odd Test: Put LSB (Bit 0) into (C)
GET816LEN       BCC   IEVEN           ;Branch if OpCode is (=%#######0) Even
;                                     ;^[OpCode Before Shifting & Rotatng Right]
;              ---------------------- ;Else, OpCode is (=%#######1) Odd
;                                     ;^[OpCode Before Shifting & Rotatng Right]
;                                     ;& Now (C=1) & (A)=(%0#######):
                ROR   A               ;Bit 1 Test: Put (C=1) in MSB & LSB in (C)
                BCS   ERR             ;Branch if OpCode is (=%######11) Invalid
;                                     ;^[OpCode Before Shifting & Rotatng Right]
;              ---------------------- ;Else, OpCode is (=%######01) Odd
;                                     ;^[OpCode Before Shifting & Rotatng Right]
;                                     ;& Now (C=0) & (A)=(%10######):
                CMP   #%10100010      ;Is OpCode a NOP?  (%10001001=$89=137):(?)
;                                     ;^[OpCode Before Shifting & Rotatng Right]
;                                     ;================= FMT1,X ================
;                                     ;(?) =         %10001001=$89=137
;                                     ;LSR =         %01000100=$44=68  ->(C=1)
;                                     ;ROR = (C=1)-> %10100010=$A2=162 ->(C=0)
;                                     ;================= FMT2,X ================
;                                     ;NOP =         %11101010=$EA=234
;                                     ;LSR =         %01110101=$75=117 ->(C=0)
;                                     ;ROR = (C=0)-> %00111010=$3A=58  ->(C=1)
;                                     ;Relative <- = %10011101=$9D=157 ->(C=0)
;                                     ;=========================================
                BEQ   ERR             ;Branch if OpCode is Invalid (=$89)
;              ---------------------- ;Else, OpCode is (=%######01) Odd & Valid
;                                     ;& Now (C=?) & (A)=(%10######):
                AND   #%10000111      ;Mask Bits: Keep Sign & 3 LSBs
;                                     ;& Discard the Rest [(A)=(%10000###)]
IEVEN           LSR   A               ;Put LSB into Carry for Left/Right Test
;                                     ;Also Sets (A)=(A/2) for Absolute,X-Index:
                TAX                   ;Set Absolute,X-Index [(X=A)=(%0#######)]
;                                     ;^[For Odd OpCodes: (X=A)=(%010000##)=
;                                     ;{(%01000000=$40=64)~(%01000011=$43=67)}]
                LDA   FMT1,X          ;Get Instruction Display Format Index Byte
;                                     ;^[See also (below): FMT1 NOTE]
                JSR   SCRN2           ;Get Right or Left Nibble Based on Carry
                BNE   GETFMT          ;Branch if Low Nibble <> 0: OpCode is Valid
ERR             LDY   #$80            ;Else, Substitute $80 for Invalid OpCodes
                LDA   #0              ;Clear Accumulator
GETFMT          TAX                   ;Set Absolute,X-Index
                LDA   FMT2,X          ;Get Instruction Display Print Format Byte
;                                     ;^[See also (below): FMT1 NOTE]
                STA   FORMAT          ;Save for Address Field Formatting
                AND   #%00000011      ;Mask to Get 2-Bit LENGTH (OpCodeBytes-1:
;                                     ; 0=1 Byte, 1=2 Byte, 2=3 Byte)
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;  *** [The following section is different in the Apple IIE Autostart ROM] ***
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
                STA   LENGTH          ;Save Length (Number of OpCode Bytes -1)
; 
; ==============================================================================
; Form an Index into the Mnemonic Table from an OpCode: (A)=[(OpCode)-->(Index)]
; ==============================================================================
;     OpCode -> Index   for OpCd-Form; Example OpCodes & Exceptions
; -- -------- --------- --- ---------- -----------------------------------------
; 1) 1XXX1010->00101XXX  ~  %1###1010; $8A,$9A,$AA,$BA,$CA,$DA,$EA,$FA.
; 2) XXXYYY01->00111XXX  ~  %######01; Not $#3~$#4; $#1,$#5,$#9,$#D.
; 3) XXXYYY10->00110XXX  ~  %######10; Not $#0~$#1; $#2,$#6,$#A,$#E.
; 4) XXXYY100->00100XXX  ~  %#####100; Not $#0~$#3; $#4,$#C.
; 5) XXXXX000->000XXXXX  ~  %#####000; Not $#1~$#7; $#0,$#8.
; -- -------- --------- --- ---------- -----------------------------------------
;    ^^^^^^^^ Bits: X's, 0's, & 1's are Shifted Right; Y's are Discarded. 
;             #'s are Bits: 0 or 1; or Hexadecimal Numbers: 0~9,A~F
; ==============================================================================
; 
                TYA                   ;Get Saved {Valid or Invalid ($80)} OpCode
                AND   #%10001111      ;Mask for 6502 Bit Mapping Test (%1###1010)
                TAX                   ;Save Masked Byte for Test
                TYA                   ;Get Saved OpCode Again
                LDY   #3              ;Set Loop Counter
                CPX   #%10001010      ;Is Masked Byte for an OpCode=(%1###1010)?
;                                     ;                   ^[1 in Chart above]^
                BEQ   MNNDX3          ;YES, Form an Index into the Mnemonic Table
;                                     ;NO, Masked Byte's for OpCode<>(%1###1010)
;                                     ;                  ^[2~5 in Chart above]^
MNNDX1          LSR   A               ;Even/Odd Test: Put LSB into (C)
;              ---------------------- ;Shift until LSB was Odd or (Y) = 0:
                BCC   MNNDX3          ;Branch if LSB was Even; Else:
;              ---------------------- ;LSB was Odd, Discard & Set Bits:
                LSR   A               ;Put Next LSB into Carry (C) [Discarded]
MNNDX2          LSR   A               ;Put Next LSB into Carry (C) [Discarded]
                ORA   #%00100000      ;Set Current Bit 5
                DEY                   ;Reduce Loop Counter
                BNE   MNNDX2          ;Loop until Y=0
                INY                   ;Advance to Compensate for Next Reduction 
;              ---------------------- ;LSB was Even, Check Next:
MNNDX3          DEY                   ;Reduce Loop Counter
                BNE   MNNDX1          ;Loop until Y=0; Else:
;              ---------------------- ;Now: (A) = Index into the Mnemonic Table;
;                                     ;     (X) = Masked OpCode; & (Y) = 0
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
                DS    3,$FF           ;Filler

; ==============================================================================
; Disassemble & Print Instruction at Program Counter
; ==============================================================================
; 
INSTDSP         JSR   INSDS1          ;Display Instruction Line Address &
;                                     ;Get Instruction FORMAT & LENGTH, & MTI:
                PHA                   ;Push/Save Index into Mnemonic Table ^
;              ---------------------- ;Print (1-3) OpCode Bytes [as Hex: "## "]
;                                     ;(in a 12 Char Field, Ending w/ Spaces)
;                                     ;=[4 Fields of 3 Characters each]:
PRNTOP          LDA   (PCL),Y         ;Get Byte at (Program Counter),Y
                JSR   PRBYTE          ;Print (A) as Two-Digit Hex Number
                LDX   #1              ;Prepare to Print One Space
PRNTBL          JSR   PRBL2           ;Print a Blank [(X) Spaces]
                CPY   LENGTH          ;Subtract (Number of OpCode Bytes -1)
                INY                   ;Advance OpCode Bytes Counter
                BCC   PRNTOP          ;BLT: Loop if Byte Count < LENGTH (^)
;                                     ;End 12 Char Field w/ Spaces; =[4*3]:
                LDX   #3              ;Get Blank Char Count (for No OpCode Byte)
;                                     ;^[Also used below for Mnemonic Chars]
                CPY   #4              ;Ending with (Y) Blanks of (X) Spaces each
                BCC   PRNTBL          ;BLT: Loop if OpCode Bytes Counter < 4
;              ---------------------- ;Fetch 3-Char Mnemonic (Packed In 2-Bytes)
                PLA                   ;Pull/Retrieve Index into Mnemonic Table
                TAY                   ;Set Indirect Addressing Index
                LDA   MNEML,Y         ;Get 1st Packed Byte of Mnemonic
                STA   LMNEM           ;Set Left  (ZP) Byte of Mnemonic
                LDA   MNEMR,Y         ;Get 2nd Packed Byte of Mnemonic
                STA   RMNEM           ;Set Right (ZP) Byte of Mnemonic
; 
; ------------------------------------------------------------------------------
; Note about NXTCOL here & there: NXTCOL is the Label used here in the New
; Monitor listing; NXTCOL was used elsewhere in the Old Monitor listing (See
; NEXTCOLOR above); PRMN1 was the Label used here in the Old Monitor listing.
; ------------------------------------------------------------------------------
; 
NXTCOL          LDA   #0              ;PRMN1: Clear Accumulator
                LDY   #5              ;Set to Shift 5 Bits into (A)
;                     ;[(%###CHAR1)<--(%CHAR1,CHA ~ %R2,CHAR3#)=(MNEML,MNEMR)]
; ------------------------------------------------------------------------------
; These are the Two Packed Bytes of the Mnemonics: There are 3 Packed Chars per
; 2 Byte Mnemonic [5 Bits/Char: (%CHAR1,CHA ~ %R2,CHAR3#) & a Trailing Bit];
; Each Mnemonic Character is a 5 Bit Number + High ASCII "?" [=(5 Bit #)+($BF)]
; ------------------------------------------------------------------------------
PRMN2           ASL   RMNEM           ;Shift Left 5 Bits of
                ROL   LMNEM           ;Packed Mnemonic Characters [^^^]
                ROL   A               ;into the Accumulator (Clears Carry)
                DEY                   ;Reduce Bit Counter
                BNE   PRMN2           ;Branch Until Shifted All 5 Bits
; <---[Page Boundary] (in the middle of the DWord above)
                ADC   #'?' | $80      ;Add Offset to make Char High ASCII (>="?")
                JSR   COUT            ;Output 1 Character of Mnemonic
                DEX                   ;Reduce Mnemonic Character Counter
                BNE   NXTCOL          ;Loop Until 3 Packed Mnemonic Chars Printed
                JSR   PRBLNK          ;Print a Blank [(3) Spaces]
                LDY   LENGTH          ;Get LENGTH (Number of OpCode Bytes -1)
                LDX   #6              ;Count for 6 Format Bits
PRADR1          CPX   #3              ;3 Packed Mnemonic Chars Printed?
                BEQ   PRADR5          ;YES, Branch if X=3: Do Address Field
; ----------------------------------- ;Else, Do Address Field Formatting,
;                                     ;Print Addressing Field CHARS 1 & 2:
PRADR2          ASL   FORMAT          ;Shift Addressing Field Format MSB->(C)
                BCC   PRADR3          ;Branch if Shifted MSB is Zero; Else:
;                                     ;Address Printout CHAR1 Bytes: ",),#($"
                LDA   CHAR1-1,X       ;[-1 OK Here] Get Address Printout Byte
                JSR   COUT            ;Print Addressing CHAR1 Byte
;                                     ;Address Printout CHAR2 Bytes: "Y0X$$0"
                LDA   CHAR2-1,X       ;[-1 OK Here] Get Address Printout Byte
                BEQ   PRADR3          ;Branch if CHAR2 is a Zero (0)
                JSR   COUT            ;Else, Print Addressing CHAR2 Byte
PRADR3          DEX                   ;Reduce Format Bit Count
                BNE   PRADR1          ;Loop Until 6 Format Bits Counted
                RTS                   ;Else, Done, Return to Caller

; ----------------------------------- ;Do Addressing Field (Not a Branch):
PRADR4          DEY                   ;Reduce (Number of OpCode Bytes -1) Count
                BMI   PRADR2          ;Loop if All Instruction Bytes Processed
                JSR   PRBYTE          ;Else, Print (A) as Two-Digit Hex Number
;                                     ;^[Jumps to (CSW); Does NOT Return Here!]
; 
; ----------------------------------- ;Do Addressing Field (Entry Point):
PRADR5          LDA   FORMAT          ;Get Addressing Field Format
                CMP   #$E8            ;Subtract $E8 [(A)-Data -> NZC]
;                                     ;^[FORMAT for Relative = $9D = %10011101; 
;                                     ;FORMAT for Rel ASL *3 = $E8 = %11101000]
                LDA   (PCL),Y         ;Get Byte at (Program Counter),Y
                BCC   PRADR4          ;Branch if Addressing Mode is Not Relative
; ----------------------------------- ;Handle Relative Addressing Mode Special,
;                                     ;for BCC|BCS|BEQ|BMI|BNE|BPL|BVC|BVS,
;                                     ;Print Branch Target, Not Offset Value:
RELADR          JSR   PCADJ3          ;Add (A+C) to Instruction Address (PCL,H)
;                                     ;Set Target=1+[(PCL,H)+(Offset)+1]->(A,Y):
                TAX                   ;Get (Target Address -1), Low
                INX                   ;Add 1 to (Target Address -1), Low
                BNE   PRNTYX          ;Branch if Not Crossing Page Boundary
                INY                   ;Else, Add 1 to (Target Address -1), High
; ----------------------------------- ;Output Target Address of Branch
;                                     ;& Return to Caller:
PRNTYX          TYA                   ;Get Target Address, High
PRNTAX          JSR   PRBYTE          ;Print A-Reg as Two-Digit Hex Number
PRNTX           TXA                   ;Get Target Address, Low
                JMP   PRBYTE          ;Print A-Reg as Two-Digit Hex Number

; ------------------------------------------------------------------------------
; Print Blank Spaces Subroutine:
; ------------------------------------------------------------------------------
; 
PRBLNK          LDX   #3              ;Print a Blank [(3) Spaces]
PRBL2           LDA   #' ' | $80      ;Print a Blank [(X) Spaces]
;                                     ;Print (A) Char + Blank [(X) Spaces]:
PRBL3           JSR   COUT            ;Print (A) to Output Device
                DEX                   ;Reduce Character Count
                BNE   PRBL2           ;LOOP Until All Characters are Done
                RTS                   ;Return to Caller

; ------------------------------------------------------------------------------
; Add (A+C) to Instruction Address (PCL,H) Subroutines:
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Add Length+1 to Instruction Adrs (PCL,H):
PCADJ           SEC                   ;Prepare for Add with Carry Set (Adds 1)
; ----------------------------------- ;Add Length+(C) to Instr Adrs (PCL,H):
PCADJ2          LDA   LENGTH          ;Get LENGTH (Number of OpCode Bytes -1)
;                                     ;... ^[0=1-Byte, 1=2-Bytes, 2=3-Bytes]
; ----------------------------------- ;Add (A+C) to Instruction Address (PCL,H):
PCADJ3          LDY   PCH             ;Get Instruction Address, High
;                                     ;Test Relative Branch Displacement Sign:
                TAX                   ;Get Offset to Target Address
                BPL   PCADJ4          ;Branch if Offset to Target is Positive
                DEY                   ;Else, Extend Negative Target Offset
PCADJ4          ADC   PCL             ;Add Offset to Instruction Address, Low 
                BCC   MON_RTS2        ;Branch if No Carryover (or Page Crossed)
                INY                   ;Else, Add 1 to Instruction Address, High
MON_RTS2        RTS                   ;Return to Caller

; ==============================================================================
; Miniassembler/Disassembler Instruction Display Tables
; ==============================================================================
; 
; ============================= | ==============================================
;       FMT1 Index Bytes:       | Format Index Byte: XXXXXXY0 Instructions
; ========================v====-+-===v=====================^====================
; [*] Use: Left Nibble if Y=1   | If Y=1 then Left Half Byte   |    68 Bytes/2 |
;         Right Nibble if Y=0   | If Y=0 then Right Half Byte  | +  68 Bytes/2 |
;    [For: 14 Print Formats]    | [(X)=(Index into Table)]     | = 136 Nibbles |
; ------------------------------------------------------------------------------
; [*] These are opposite of what the Old Monitor listing shows in A2 Ref Manual!
; ==============================================================================
;                                   FMT1 NOTE
; ==============================================================================
; Used to get an Index into the next table to get FORMAT & LENGTH frm an OpCode;
; Noticeable Patterns: Alternating groups of 4 Defined Bytes (4 DFB lines);
; Nibble Comments are adapted from OpCodes(*) & the following table's Comments;
; The Nibble (sequence number) for an Even Operation Code (Instruction) is:
;     Nibble=(OpCode/2)+1-(2*Y): where Y is Bit 1 of the OpCode = (0 or 1);
;     OpCode=(Nibble-1+(2*Y))*2: " " " " (Ditto) " " " ";  <-[The way back!];
; The Nibble (sequence number) for an Odd OpCode is limited to the last group of
; eight nibbles [(X)=(64~67)]; Undefined Operations: ??? [All are still NOP's];
; (*) See a "6502 Hex to Instruction Conversion Chart" [& maybe: "UnDocumented
; 6502 OpCodes" by Nick Westgate (for Undefined Operations: ???)]
; ==============================================================================
; 
; ----------------------------- | ----------------------------------------------
;                               |   Nibble  Op  Address Mode | Bytes | Examples
; ----------------------------- | ----------------------------\-----/-----------
FMT1            DFB   $04             ;$00: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$01: BRK Implied        | 1 | {Empty}
                DFB   $20             ;$02: ASL Zero-Page [ZP] | 2 | $NN
;                                     ;$03: ??? Error/Unknown  | 1 | {Empty}
                DFB   $54             ;$04: ASL Accumulator    | 1 | {Empty}
;                                     ;$05: PHP Implied        | 1 | {Empty}
                DFB   $30             ;$06: ASL Absolute       | 3 | $NNNN
;                                     ;$07: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $0D             ;$08: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$09: BPL Relative       | 2 | $NN
                DFB   $80             ;$0A: ASL Zero-Page,X    | 2 | $NN,X
;                                     ;$0B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$0C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$0D: CLC Implied        | 1 | {Empty}
                DFB   $90             ;$0E: ASL Absolute,X     | 3 | $NNNN,X
;                                     ;$0F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $03             ;$10: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$11: JSR Absolute       | 3 | $NNNN
                DFB   $22             ;$12: ROL Zero-Page [ZP] | 2 | $NN
;                                     ;$13: BIT Zero-Page [ZP] | 2 | $NN
                DFB   $54             ;$14: ROL Accumulator    | 1 | {Empty}
;                                     ;$15: PLP Implied        | 1 | {Empty}
                DFB   $33             ;$16: ROL Absolute       | 3 | $NNNN
;                                     ;$17: BIT Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$18: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$19: BMI Relative       | 2 | $NN
                DFB   $80             ;$1A: ROL Zero-Page,X    | 2 | $NN,X
;                                     ;$1B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$1C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$1D: SEC Implied        | 1 | {Empty}
                DFB   $90             ;$1E: ROL Absolute,X     | 3 | $NNNN,X
;                                     ;$1F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $04             ;$20: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$21: RTI Implied        | 1 | {Empty}
                DFB   $20             ;$22: LSR Zero-Page [ZP] | 2 | $NN
;                                     ;$23: ??? Error/Unknown  | 1 | {Empty}
                DFB   $54             ;$24: LSR Accumulator    | 1 | {Empty}
;                                     ;$25: PHA Implied        | 1 | {Empty}
                DFB   $33             ;$26: LSR Absolute       | 3 | $NNNN
;                                     ;$27: JMP Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$28: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$29: BVC Relative       | 2 | $NN
                DFB   $80             ;$2A: LSR Zero-Page,X    | 2 | $NN,X
;                                     ;$2B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$2C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$2D: CLI Implied        | 1 | {Empty}
                DFB   $90             ;$2E: LSR Absolute,X     | 3 | $NNNN,X
;                                     ;$2F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $04             ;$30: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$31: RTS Implied        | 1 | {Empty}
                DFB   $20             ;$32: ROR Zero-Page [ZP] | 2 | $NN
;                                     ;$33: ??? Error/Unknown  | 1 | {Empty}
                DFB   $54             ;$34: ROR Accumulator    | 1 | {Empty}
;                                     ;$35: PLA Implied        | 1 | {Empty}
                DFB   $3B             ;$36: ROR Absolute       | 3 | $NNNN
;                                     ;$37: JMP (Abs.Indirect) | 3 | ($NNNN)
; ------------------------------------------------------------------------------
                DFB   $0D             ;$38: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$39: BVS Relative       | 2 | $NN
                DFB   $80             ;$3A: ROR Zero-Page,X    | 2 | $NN,X
;                                     ;$3B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$3C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$3D: SEI Implied        | 1 | {Empty}
                DFB   $90             ;$3E: ROR Absolute,X     | 3 | $NNNN,X
;                                     ;$3F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $00             ;$40: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$41: ??? Error/Unknown  | 1 | {Empty}
                DFB   $22             ;$42: STX Zero-Page [ZP] | 2 | $NN
;                                     ;$43: STY Zero-Page [ZP] | 2 | $NN
                DFB   $44             ;$44: TYA Implied        | 1 | {Empty}
;                                     ;$45: DEY Implied        | 1 | {Empty}
                DFB   $33             ;$46: STX Absolute       | 3 | $NNNN
;                                     ;$47: STY Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$48: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$49: BCC Relative       | 2 | $NN
                DFB   $C8             ;$4A: STX Zero-Page,Y    | 2 | $NN,Y
;                                     ;$4B: STY Zero-Page,X    | 2 | $NN,X
                DFB   $44             ;$4C: TXS Implied        | 1 | {Empty}
;                                     ;$4D: TYA Implied        | 1 | {Empty}
                DFB   $00             ;$4E: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$4F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $11             ;$50: LDX Immediate      | 2 | #$NN
;                                     ;$51: LDY Immediate      | 2 | #$NN
                DFB   $22             ;$52: LDX Zero-Page [ZP] | 2 | $NN
;                                     ;$53: LDY Zero-Page [ZP] | 2 | $NN
                DFB   $44             ;$54: TAX Implied        | 1 | {Empty}
;                                     ;$55: TAY Implied        | 1 | {Empty}
                DFB   $33             ;$56: LDX Absolute       | 3 | $NNNN
;                                     ;$57: LDY Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$58: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$59: BCS Relative       | 2 | $NN
                DFB   $C8             ;$5A: LDX Zero-Page,Y    | 2 | $NN,Y
;                                     ;$5B: LDY Zero-Page,X    | 2 | $NN,X
                DFB   $44             ;$5C: TSX Implied        | 1 | {Empty}
;                                     ;$5D: CLV Implied        | 1 | {Empty}
                DFB   $A9             ;$5E: LDX Absolute,Y     | 3 | $NNNN,Y
;                                     ;$5F: LDY Absolute,X     | 3 | $NNNN,X
; ------------------------------------------------------------------------------
                DFB   $01             ;$60: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$61: CPY Immediate      | 2 | #$NN
                DFB   $22             ;$62: DEC Zero-Page [ZP] | 2 | $NN
;                                     ;$63: CPY Zero-Page [ZP] | 2 | $NN
                DFB   $44             ;$64: DEX Implied        | 1 | {Empty}
;                                     ;$65: INY Implied        | 1 | {Empty}
                DFB   $33             ;$66: DEC Absolute       | 3 | $NNNN
;                                     ;$67: CPY Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$68: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$69: BNE Relative       | 2 | $NN
                DFB   $80             ;$6A: DEC Zero-Page,X    | 2 | $NN,X
;                                     ;$6B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$6C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$6D: CLD Implied        | 1 | {Empty}
                DFB   $90             ;$6E: DEC Absolute,X     | 3 | $NNNN,X
;                                     ;$6F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
                DFB   $01             ;$70: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$71: CPX Immediate      | 2 | #$NN
                DFB   $22             ;$72: INC Zero-Page [ZP] | 2 | $NN
;                                     ;$73: CPX Zero-Page [ZP] | 2 | $NN
                DFB   $44             ;$74: NOP Implied        | 1 | {Empty}
;                                     ;$75: INX Implied        | 1 | {Empty}
                DFB   $33             ;$76: INC Absolute       | 3 | $NNNN
;                                     ;$77: CPX Absolute       | 3 | $NNNN
; ------------------------------------------------------------------------------
                DFB   $0D             ;$78: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$79: BEQ Relative       | 2 | $NN
                DFB   $80             ;$7A: INC Zero-Page,X    | 2 | $NN,X
;                                     ;$7B: ??? Error/Unknown  | 1 | {Empty}
                DFB   $04             ;$7C: ??? Error/Unknown  | 1 | {Empty}
;                                     ;$7D: SED Implied        | 1 | {Empty}
                DFB   $90             ;$7E: INC Absolute,X     | 3 | $NNNN,X
;                                     ;$7F: ??? Error/Unknown  | 1 | {Empty}
; ------------------------------------------------------------------------------
; Last 8 for Odd OpCode Mnemonics *** [ORA, AND EOR, ADC, STA, LDA, CMP, & SBC]:
; ------------------------------------------------------------------------------
                DFB   $26             ;$80: *** Zero-Page [ZP] | 2 | $NN
;                                     ;      ^ $(Even)5:Zero-Page
;                                     ;$81: *** (Zero-Page,X)  | 2 | ($NN,X)
;                                     ;      ^ $(Even)1 [(Indexed-Indirect)]
                DFB   $31             ;$82: *** Absolute       | 3 | $NNNN
;                                     ;      ^ $(Even)D
;                                     ;$83: *** Immediate      | 2 | #$NN
;                                     ;      ^ $(Even)9  [No STA Immediate!]
                DFB   $87             ;$84: *** Zero-Page,X    | 2 | $NN,X
;                                     ;      ^ $(Odd)5
;                                     ;$85: *** (Zero-Page),Y  | 2 | ($NN),Y
;                                     ;      ^ $(Odd)1  [(Indirect)-Indexed]
                DFB   $9A             ;$86: *** Absolute,X     | 3 | $NNNN,X
;                                     ;      ^ $(Odd)D
;                                     ;$87: *** Absolute,Y     | 3 | $NNNN,Y
;                                     ;      ^ $(Odd)9
; ------------------------------------------------------------------------------
; 
; ============================= | ==============================================
;     FMT2 Index Bytes (*):     | Print Format Index Byte $ZZXXXY01 Instructions
; ============================= | ==============================================
;   [(X)=(Index into Table)]    |      Address Mode | Bytes | Notes & Examples
; ----------------------------- | -------------------\-----/--------------------
FMT2            DFB   %00000000       ;Error/Unknown  | 1 | {MT}[All are NOP's]
                DFB   %00100001       ;Immediate      | 2 | #$NN
                DFB   %10000001       ;Zero-Page [ZP] | 2 | $NN
                DFB   %10000010       ;Absolute       | 3 | $NNNN
                DFB   %00000000       ;Implied        | 1 | {Empty} [& $EA=NOP]
                DFB   %00000000       ;Accumulator    | 1 | {Empty}
                DFB   %01011001       ;(Zero-Page,X)  | 2 | ($NN,X) [NDXD-NDRCT]
                DFB   %01001101       ;(Zero-Page),Y  | 2 | ($NN),Y [NDRCT-NDXD]
                DFB   %10010001       ;Zero-Page,X    | 2 | $NN,X
                DFB   %10010010       ;Absolute,X     | 3 | $NNNN,X
                DFB   %10000110       ;Absolute,Y     | 3 | $NNNN,Y
                DFB   %01001010       ;(Indirect)  *1 | 3 | JMP (Absolute)
                DFB   %10000101       ;Zero-Page,Y *2 | 2 | LDX ZP,Y & STX ZP,Y
                DFB   %10011101       ;Relative       | 2 | $NN
; ----------------------------- | ----------------------------------------------
; (*) Bytes will be Saved for   | Only those Noted: *1=One Op; *2=Two Ops
;     Address Field Formatting -> Mask Gets 2-Bit LENGTH: FMT2,X AND #%00000011
; [See also (above): FMT1 NOTE] | (OpCodeBytes-1: 0=1 Byte, 1=2 Byte, 2=3 Byte)
; ============================= | ==============================================
; 
; ============================= | ==============================================
;     Address Printout          | Apple II Reference Manual Listings:
;     CHAR1 Bytes: ",),#($"     | New Monitor <> Old Monitor: ASC ",),#($"
; ============================= | ==============================================
; 
CHAR1           DFB   ',' | $80       ;ASCII ","
                DFB   ')' | $80       ;ASCII ")"
                DFB   ',' | $80       ;ASCII ","
                DFB   '#' | $80       ;ASCII "#"
                DFB   '(' | $80       ;ASCII "("
                DFB   '$' | $80       ;ASCII "$"
; 
; ============================= | ==============================================
;     Address Printout          | Apple II Reference Manual Listings:
;     CHAR2 Bytes: "Y0X$$0"     | New Monitor = Old Monitor: "Y",0,"X$$",0
; ============================= | ==============================================
CHAR2           DFB   'Y' | $80       ;ASCII "Y"
                DFB   $00             ;VALUE "0"
                DFB   'X' | $80       ;ASCII "X"
                DFB   '$' | $80       ;ASCII "$"
                DFB   '$' | $80       ;ASCII "$"
                DFB   $00             ;VALUE "0"
; 
; ============================= | ==============================================
;      Mnemonic Forms:          | MNEML & MNEMR Instruction Formats
;       (A) XXXXX000            |
;       (B) XXXYY100            | [(X)=(Index into Table)]
;       (C) 1XXX1010            |
;       (D) XXXYYY10            |
;       (E) XXXYYY01            |
; ============================= | ==============================================
;      Mnemonic Left Bytes      | MNEML Instruction Formats (64)
; ============================= | ==============================================
; 
; ------------------------------------------------------------------------------
; These are the 1st Packed Bytes of the Mnemonics: There are 3 Packed Chars per
; 2 Byte Mnemonic [5 Bits/Char: (%CHAR1,CHA ~ %R2,CHAR3#) & a Trailing Bit];
; Each Mnemonic Character is a 5 Bit Number + High ASCII "?" [=(5 Bit #)+($BF)]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;(A)-Format Instructions (32)
;                                     ; |  vvv---------[MNEML+MNEMR]--------
;                                     ; |   v    CHAR1     CHAR2     CHAR3
;                                     ;--- ---  --------  --------  --------
MNEML           DFB   %00011100       ;(A) BRK: %00011=B; %10011=R; %01100=K
                DFB   %10001010       ;(A) PHP: %10001=P; %01001=H; %10001=P
                DFB   %00011100       ;(A) BPL: %00011=B; %10001=P; %01101=L
                DFB   %00100011       ;(A) CLC: %00100=C; %01101=L; %00100=C
                DFB   %01011101       ;(A) JSR: %01011=J; %10100=S; %10011=R
                DFB   %10001011       ;(A) PLP: %10001=P; %01101=L; %10001=P
                DFB   %00011011       ;(A) BMI: %00011=B; %01110=M; %01010=I
                DFB   %10100001       ;(A) SEC: %10100=S; %00110=E; %00100=C
                DFB   %10011101       ;(A) RTI: %10011=R; %10101=T; %01010=I
                DFB   %10001010       ;(A) PHA: %10001=P; %01001=H; %00010=A
                DFB   %00011101       ;(A) BVC: %00011=B; %10111=V; %00100=C
                DFB   %00100011       ;(A) CLI: %00100=C; %01101=L; %01010=I
                DFB   %10011101       ;(A) RTS: %10011=R; %10101=T; %10100=S
                DFB   %10001011       ;(A) PLA: %10001=P; %01101=L; %00010=A
                DFB   %00011101       ;(A) BVS: %00011=B; %10111=V; %10100=S
                DFB   %10100001       ;(A) SEI: %10100=S; %00110=E; %01010=I
                DFB   %00000000       ;(A) ???: %00000=?; %00000=?; %00000=?
                DFB   %00101001       ;(A) DEY: %00101=D; %00110=E; %11010=Y
                DFB   %00011001       ;(A) BCC: %00011=B; %00100=C; %00100=C
                DFB   %10101110       ;(A) TYA: %10101=T; %11010=Y; %00010=A
                DFB   %01101001       ;(A) LDY: %01101=L; %00101=D; %11010=Y
                DFB   %10101000       ;(A) TAY: %10101=T; %00010=A; %11010=Y
                DFB   %00011001       ;(A) BCS: %00011=B; %00100=C; %10100=S
                DFB   %00100011       ;(A) CLV: %00100=C; %01101=L; %10111=V
                DFB   %00100100       ;(A) CPY: %00100=C; %10001=P; %11010=Y
                DFB   %01010011       ;(A) INY: %01010=I; %01111=N; %11010=Y
                DFB   %00011011       ;(A) BNE: %00011=B; %01111=N; %00110=E
                DFB   %00100011       ;(A) CLD: %00100=C; %01101=L; %00101=D
                DFB   %00100100       ;(A) CPX: %00100=C; %10001=P; %11001=X
                DFB   %01010011       ;(A) INX: %01010=I; %01111=N; %11001=X
                DFB   %00011001       ;(A) BEQ: %00011=B; %00110=E; %10010=Q
                DFB   %10100001       ;(A) SED: %10100=S; %00110=E; %00101=D
; ----------------------------------- ;(B)-Format Instructions (8)
                DFB   %00000000       ;(B) ???: %00000=?; %00000=?; %00000=?
                DFB   %00011010       ;(B) BIT: %00011=B; %01010=I; %10101=T
                DFB   %01011011       ;(B) JMP: %01011=J; %01110=M; %10001=P
                DFB   %01011011       ;(B) JMP: %01011=J; %01110=M; %10001=P
                DFB   %10100101       ;(B) STY: %10100=S; %10101=T; %11010=Y
                DFB   %01101001       ;(B) LDY: %01101=L; %00101=D; %11010=Y
                DFB   %00100100       ;(B) CPY: %00100=C; %10001=P; %11010=Y
                DFB   %00100100       ;(B) CPX: %00100=C; %10001=P; %11001=X
; ----------------------------------- ;(C)-Format Instructions (8)
                DFB   %10101110       ;(C) TXA: %10101=T; %11001=X; %00010=A
                DFB   %10101110       ;(C) TXS: %10101=T; %11001=X; %10100=S
                DFB   %10101000       ;(C) TAX: %10101=T; %00010=A; %11001=X
                DFB   %10101101       ;(C) TSX: %10101=T; %10100=S; %11001=X
                DFB   %00101001       ;(C) DEX: %00101=D; %00110=E; %11001=X
                DFB   %00000000       ;(C) ???: %00000=?; %00000=?; %00000=?
                DFB   %01111100       ;(C) NOP: %01111=N; %10000=O; %10001=P
                DFB   %00000000       ;(C) ???: %00000=?; %00000=?; %00000=?
; ----------------------------------- ;(D)-Format Instructions (8)
                DFB   %00010101       ;(D) ASL: %00010=A; %10100=S; %01101=L
                DFB   %10011100       ;(D) ROL: %10011=R; %10000=O; %01101=L
                DFB   %01101101       ;(D) LSR: %01101=L; %10100=S; %10011=R
                DFB   %10011100       ;(D) ROR: %10011=R; %10000=O; %10011=R
                DFB   %10100101       ;(D) STX: %10100=S; %10101=T; %11001=X
                DFB   %01101001       ;(D) LDX: %01101=L; %00101=D; %11001=X
                DFB   %00101001       ;(D) DEC: %00101=D; %00110=E; %00100=C
                DFB   %01010011       ;(D) INC: %01010=I; %01111=N; %00100=C
; ----------------------------------- ;(E)-Format Instructions (8)
                DFB   %10000100       ;(E) ORA: %10000=O; %10011=R; %00010=A
                DFB   %00010011       ;(E) AND: %00010=A; %01111=N; %00101=D
                DFB   %00110100       ;(E) EOR: %00110=E; %10000=O; %10011=R
                DFB   %00010001       ;(E) ADC: %00010=A; %00101=D; %00100=C
                DFB   %10100101       ;(E) STA: %10100=S; %10101=T; %00010=A
                DFB   %01101001       ;(E) LDA: %01101=L; %00101=D; %00010=A
                DFB   %00100011       ;(E) CMP: %00100=C; %01110=M; %10001=P
                DFB   %10100000       ;(E) SBC: %10100=S; %00011=B; %00100=C
; 
; <---[Page Boundary]
; 
; ============================= | ==============================================
;     Mnemonic Right Bytes      | MNEMR Instruction Formats (64)
; ============================= | ==============================================
; 
; ------------------------------------------------------------------------------
; These are the 2nd Packed Bytes of the Mnemonics: There are 3 Packed Chars per
; 2 Byte Mnemonic [5 Bits/Char: (%CHAR1,CHA ~ %R2,CHAR3#) & a Trailing Bit];
; Each Mnemonic Character is a 5 Bit Number + High ASCII "?" [=(5 Bit #)+($BF)]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;(A)-Format Instructions (32)
;                                     ; |  vvv---------[MNEML+MNEMR]--------
;                                     ; |   v    CHAR1     CHAR2     CHAR3
;                                     ;--- ---  --------  --------  --------
MNEMR           DFB   %11011000       ;(A) BRK: %00011=B; %10011=R; %01100=K
                DFB   %01100010       ;(A) PHP: %10001=P; %01001=H; %10001=P
                DFB   %01011010       ;(A) BPL: %00011=B; %10001=P; %01101=L
                DFB   %01001000       ;(A) CLC: %00100=C; %01101=L; %00100=C
                DFB   %00100110       ;(A) JSR: %01011=J; %10100=S; %10011=R
                DFB   %01100010       ;(A) PLP: %10001=P; %01101=L; %10001=P
                DFB   %10010100       ;(A) BMI: %00011=B; %01110=M; %01010=I
                DFB   %10001000       ;(A) SEC: %10100=S; %00110=E; %00100=C
                DFB   %01010100       ;(A) RTI: %10011=R; %10101=T; %01010=I
                DFB   %01000100       ;(A) PHA: %10001=P; %01001=H; %00010=A
                DFB   %11001000       ;(A) BVC: %00011=B; %10111=V; %00100=C
                DFB   %01010100       ;(A) CLI: %00100=C; %01101=L; %01010=I
                DFB   %01101000       ;(A) RTS: %10011=R; %10101=T; %10100=S
                DFB   %01000100       ;(A) PLA: %10001=P; %01101=L; %00010=A
                DFB   %11101000       ;(A) BVS: %00011=B; %10111=V; %10100=S
                DFB   %10010100       ;(A) SEI: %10100=S; %00110=E; %01010=I
                DFB   %00000000       ;(A) ???: %00000=?; %00000=?; %00000=?
                DFB   %10110100       ;(A) DEY: %00101=D; %00110=E; %11010=Y
                DFB   %00001000       ;(A) BCC: %00011=B; %00100=C; %00100=C
                DFB   %10000100       ;(A) TYA: %10101=T; %11010=Y; %00010=A
                DFB   %01110100       ;(A) LDY: %01101=L; %00101=D; %11010=Y
                DFB   %10110100       ;(A) TAY: %10101=T; %00010=A; %11010=Y
                DFB   %00101000       ;(A) BCS: %00011=B; %00100=C; %10100=S
                DFB   %01101110       ;(A) CLV: %00100=C; %01101=L; %10111=V
                DFB   %01110100       ;(A) CPY: %00100=C; %10001=P; %11010=Y
                DFB   %11110100       ;(A) INY: %01010=I; %01111=N; %11010=Y
                DFB   %11001100       ;(A) BNE: %00011=B; %01111=N; %00110=E
                DFB   %01001010       ;(A) CLD: %00100=C; %01101=L; %00101=D
                DFB   %01110010       ;(A) CPX: %00100=C; %10001=P; %11001=X
                DFB   %11110010       ;(A) INX: %01010=I; %01111=N; %11001=X
                DFB   %10100100       ;(A) BEQ: %00011=B; %00110=E; %10010=Q
                DFB   %10001010       ;(A) SED: %10100=S; %00110=E; %00101=D
; ----------------------------------- ;(B)-Format Instructions (8)
                DFB   %00000000       ;(B) ???: %00000=?; %00000=?; %00000=?
                DFB   %10101010       ;(B) BIT: %00011=B; %01010=I; %10101=T
                DFB   %10100010       ;(B) JMP: %01011=J; %01110=M; %10001=P
                DFB   %10100010       ;(B) JMP: %01011=J; %01110=M; %10001=P
                DFB   %01110100       ;(B) STY: %10100=S; %10101=T; %11010=Y
                DFB   %01110100       ;(B) LDY: %01101=L; %00101=D; %11010=Y
                DFB   %01110100       ;(B) CPY: %00100=C; %10001=P; %11010=Y
                DFB   %01110010       ;(B) CPX: %00100=C; %10001=P; %11001=X
; ----------------------------------- ;(C)-Format Instructions (8)
                DFB   %01000100       ;(C) TXA: %10101=T; %11001=X; %00010=A
                DFB   %01101000       ;(C) TXS: %10101=T; %11001=X; %10100=S
                DFB   %10110010       ;(C) TAX: %10101=T; %00010=A; %11001=X
                DFB   %00110010       ;(C) TSX: %10101=T; %10100=S; %11001=X
                DFB   %10110010       ;(C) DEX: %00101=D; %00110=E; %11001=X
                DFB   %00000000       ;(C) ???: %00000=?; %00000=?; %00000=?
                DFB   %00100010       ;(C) NOP: %01111=N; %10000=O; %10001=P
                DFB   %00000000       ;(C) ???: %00000=?; %00000=?; %00000=?
; ----------------------------------- ;(D)-Format Instructions (8)
                DFB   %00011010       ;(D) ASL: %00010=A; %10100=S; %01101=L
                DFB   %00011010       ;(D) ROL: %10011=R; %10000=O; %01101=L
                DFB   %00100110       ;(D) LSR: %01101=L; %10100=S; %10011=R
                DFB   %00100110       ;(D) ROR: %10011=R; %10000=O; %10011=R
                DFB   %01110010       ;(D) STX: %10100=S; %10101=T; %11001=X
                DFB   %01110010       ;(D) LDX: %01101=L; %00101=D; %11001=X
                DFB   %10001000       ;(D) DEC: %00101=D; %00110=E; %00100=C
                DFB   %11001000       ;(D) INC: %01010=I; %01111=N; %00100=C
; ----------------------------------- ;(E)-Format Instructions (8)
                DFB   %11000100       ;(E) ORA: %10000=O; %10011=R; %00010=A
                DFB   %11001010       ;(E) AND: %00010=A; %01111=N; %00101=D
                DFB   %00100110       ;(E) EOR: %00110=E; %10000=O; %10011=R
                DFB   %01001000       ;(E) ADC: %00010=A; %00101=D; %00100=C
                DFB   %01000100       ;(E) STA: %10100=S; %10101=T; %00010=A
                DFB   %01000100       ;(E) LDA: %01101=L; %00101=D; %00010=A
                DFB   %10100010       ;(E) CMP: %00100=C; %01110=M; %10001=P
                DFB   %11001000       ;(E) SBC: %10100=S; %00011=B; %00100=C

; ==============================================================================
; End of Miniassembler/Disassembler Instruction Display Tables
; ==============================================================================
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Start of Section (FA40-FA61): Moved Here from FA86-FAA4 in Old Monitor ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; IRQ/BRK Handler:
; ==============================================================================
; In this ROM Image, IRQ NEVER HAPPENS!...because OLDRST Vector ($FF59) is used:
; ------------------------------------------------------------------------------
; What Should & Should Not Be:            <-[From end of this ROM Image listing]
; ------------------------------------------------------------------------------
; FFFE: 40 FA  DW     IRQ             ;IRQ Vector    ($FA40) IS Right; 
; FFFE: 59 FF  DW     OLDRST          ;OLDRST Vector ($FF59) IS Wrong! << BUG >>
; ------------------------------------------------------------------------------
;        <<< BUG can be fixed in (Apple II Plus) Emulator ROM images! >>>
; ==============================================================================
; 
; ----------------------------------- ;IRQ Handler
IRQ             STA   ACC             ;Save (A) in Accumulator Safe
;                                     ;^[Destroys General Purpose A5-Reg, High]
                PLA                   ;Pull Processor Status from Top of STACK
                PHA                   ;Restore STACK Top: Push Processor Status
                ASL   A               ;Shift Break Flag (Bit 4)
                ASL   A               ;over into the
                ASL   A               ;Negative Flag (Bit 7)
                BMI   BREAK           ;Branch if Break Flag (Bit 4) was Set
                JMP   (IRQADDR)       ;Else, Go to (User Routine Vector) in RAM

; ----------------------------------- ;BRK Handler
BREAK           PLP                   ;Retrieve Processor Status
                JSR   SAV1            ;Save All 6502 Registers
;                                     ;Including Program Counter:
;                                     ;<<< BUG: SAV1 Does Not Save A-Reg! >>>
                PLA                   ;Pull Program Counter, Low
                STA   PCL             ;Save in Program Counter Safe, Low
                PLA                   ;Pull Program Counter, High
                STA   PCH             ;Save in Program Counter Safe, High
                JMP   (BRKV)          ;BRKV is Set to OLDBRK by Disk Bootup

; ----------------------------------- ;OLD BRK Handler
OLDBRK          JSR   INSDS1          ;New Monitor <> Old Monitor "XBRK"
                JSR   RGDSP1          ;Print User Program Counter & Registers
                JMP   MON             ;Go to Monitor

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; End of Section (FA40-FA61): Moved Here from FA86-FAA4 in Old Monitor ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Start of Section (FA62-FAD6): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Autostart [New Monitor] "RESET"; <> [("OLDRST")=(Old Monitor "RESET")]
; ==============================================================================
; 
RESET           CLD                   ;Do this 1st this time;
;                                     ;"OLDRST" does NOT do it!
                JSR   SETNORM         ;Set Normal Video Mode & ...
                JSR   INIT            ;Init Keyboard & Screen as I/O Devices
                JSR   SETVID          ;Reset CSW Output Vector to COUT1 <--+/
                JSR   SETKBD          ;Reset KSW Input Vector to KEYIN <--+/
; ------------------------------------------------------------------------------
; WARNING: Annunciator Terminology is/was Counter Intuitive!
; These New Mnemocics/Labels are NOT!
; ------------------------------------------------------------------------------
;                                     ;Initialize Annunciator Outputs:
INITAN          LDA   AN0OFF          ; Turn OFF: AN0
                LDA   AN1OFF          ; Turn OFF: AN1
                LDA   AN2ON           ; Turn  ON: AN2
                LDA   AN3ON           ; Turn  ON: AN3
; ------------------------------------------------------------------------------
                LDA   CLRROM          ;Tell slots to disable their extension ROM
                BIT   KBDSTRB         ;Clear KBD Strobe (KBD<128)
NEWMON          CLD                   ;[As opposed to the Old MON @ $FF65]
                JSR   BELL            ;BELL Causes Delay if Key Bounces
                LDA   SOFTEV+1        ;Soft Entry (Warm Start) Vector, High
                EOR   #$A5            ;PWREDUP must equal [(SOFTEV+1)EOR #$A5]
                CMP   PWREDUP         ;Power-Up Reset CHKSUM
                BNE   PWRUP           ;Not Equal, so in a Power-Up Reset cycle
                LDA   SOFTEV          ;Equal, so has Cold Start been done yet?
                BNE   NOFIX           ;Cold Start done, so don't reset SOFTEV
                LDA   #>BASIC2        ;Soft/Warm/Ctrl-C Entry Point, High
;                                     ;^(Do Not Reinitialize BASIC)
                CMP   SOFTEV+1        ;Soft Entry (Warm Start) Vector
                BNE   NOFIX           ;Cold Start done, so don't reset SOFTEV
FIXSEV          LDY   #<BASIC2        ;Soft/Warm/Ctrl-C Entry Point, Low
;                                     ;^(Do Not Reinitialize BASIC)
                STY   SOFTEV          ;Set Adrs of Reset Handler to Warm Start
;                                     ;^(next time)
                JMP   BASIC           ;Cold Start BASIC (Reinitialize)

NOFIX           JMP   (SOFTEV)        ;Go to Soft Entry (Warm Start) Address

; ==============================================================================
; Power-Up Reset
; ==============================================================================
; 
PWRUP           JSR   APPLEII         ;Display "Apple ]["
;                                     ;centered on top line of Screen
; 
; ------------------------------------------------------------------------------
; Set Page 3 Vectors:
; ------------------------------------------------------------------------------
;  Set New BRK Vector (BRKV) to OLDBRK ($FA59);
;  Set Soft Entry Vector (SOFTEV) to Cold Start BASIC Vector ($E000);
;  Set Powered-Up Flag (PWREDUP) to $45 = (SOFTEV+1) EOR #$A5.
; ------------------------------------------------------------------------------
; 
SETPG3          LDX   #5              ;Number of bytes to copy
SETPLP          LDA   PWRCON-1,X      ;Get Page 3 Vectors
                STA   GOBRKV,X        ;Set Page 3 Vectors
                DEX
                BNE   SETPLP          ;Loop until X=0
; 
; ------------------------------------------------------------------------------
; Find Disk Drive Controller Slot
; ------------------------------------------------------------------------------
; 
                LDA   #$C8            ;Load High Slot (7) Page Address ($C7) + 1
                STX   LOC0            ;Set Poiter, Low; X=0
                STA   LOC1            ;Set Poiter, High; (for JMP @ $FAD2 below)
SLOOP           LDY   #$07            ;Y is Byte Pointer
                DEC   LOC1            ;Decrement Slot Page Address
                LDA   LOC1            ;Get Slot Page Address for comparison
                CMP   #$C0            ;Down to last Slot yet?
                BEQ   FIXSEV          ;YES, it can't be a disk; Cold Start BASIC
                STA   MSLOT           ;NO, Save current Slot Page Address
NXTBYT          LDA   (LOC0),Y        ;Fetch a Slot Byte
                CMP   DISKID-1,Y      ;Is it a Disk?
                BNE   SLOOP           ;NO, so next Slot down
                DEY                   ;Skip over $FF bytes; See DISKID below
                DEY                   ;YES, so check next byte ...
                BPL   NXTBYT          ;Until 4 checked
                JMP   (LOC0)          ;Go there

; ------------------------------------------------------------------------------
MON_NOP1        NOP                   ;Fill
MON_NOP2        NOP                   ;Fuller ;-)
; ------------------------------------------------------------------------------
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; End of Section (FA62-FAD6): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Display User Register Contents with Labels
; ==============================================================================
; ACC          EQU    $45           ;A-Reg Safe (Accumulator) [Destroys A5H!]
; XREG         EQU    $46           ;X-Reg Safe (Index Register X)
; YREG         EQU    $47           ;Y-Reg Safe (Index Register Y)
; STATUS       EQU    $48           ;P-Reg Safe (Status Register)
; SPNT         EQU    $49           ;S-Reg Safe (Stack Pointer)
; ==============================================================================
; 
; REGDSP Must ORG $FAD7 for New Monitor to remain equal to Old Mmonitor ROM
REGDSP          JSR   CROUT           ;Print Carriage Return (Ctrl-M) Character
RGDSP1          LDA   #ACC            ;A-Reg Safe (Accumulator)
                STA   A3L             ;Save ACC/A5H-Reg Address in A3-Reg
                LDA   #>ACC           ;ACC/A5H-Reg is a Zero Page Address
                STA   A3H             ;Monitor General Purpose A3-Reg, High
;                                     ;[A3-Reg ($40-$41)]=[(ACC)=($0045)]**
                LDX   #$FB            ;Load Index (-5)
RDSP1           LDA   #' ' | $80      ;Print a Space character
                JSR   COUT            ;Print A-Reg to Output Device
                LDA   RTBL-251,X      ;^"AXYPS"; 6502 Registers (Letter-Names)
;                                     ;^(X)=[($FB=251={-5})~($FF=255={-1})]
;                                     ;^[RTBL-251]=[MNEMR+30]
                JSR   COUT            ;Print A-Reg to Output Device
                LDA   #'=' | $80      ;Print an Equal-Sign character
                JSR   COUT            ;Print A-Reg to Output Device
                LDA   SAVE6502,X      ;6502 Registers Safe (Save Locations)+5
;                                     ;^(X)=[($FB=251={-5})~($FF=255={-1})]
                JSR   PRBYTE          ;Print A-Reg as Two-Digit Hex Number
                INX                   ;Count UP
                BMI   RDSP1           ;Loop until all 5 6502 Reg's are displayed
                RTS                   ;**; Return to Caller

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Start of Section (FAFD-FB18): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Power-Up Reset Data
; ==============================================================================
; 
PWRCON          DW    OLDBRK          ;To Set New BRK Vector (BRKV)
                DW    BASIC           ;To Set Soft Entry Vector (SOFTEV)
; <---[Page Boundary] (in the middle of the DWord above)
                DFB   $45             ;To Set Powered-Up Flag
;                                     ;^(PWREDUP)=(SOFTEV+1)EOR(#$A5)
; 
; ==============================================================================
; Disk Drive Controller ID-Bytes; For Slot (7 To 0) Scan [SLOOP/NXTBYT above]
; ==============================================================================
; 
DISKID          DFB   $20             ;20/00/03/3C is controller signature (**)
                DFB   $FF             ;$FFs are Skipped over; See NXTBYT above
                DFB   $00             ;** See DISK2ROM..MKDCTBL @ $C600..$C606
                DFB   $FF             ;$FF bytes are substitutes for OpCodes
                DFB   $03             ;that would otherwise make this data into
                DFB   $FF             ;functional code identical to the first 7
                DFB   $3C             ;bytes of code on the disk drive control-
;                                     ;ler, which would not be good!
; 
; ==============================================================================
; Title to be displayed, centered on top line of Screen
; ==============================================================================
; 
TITLE           ASC   ^"APPLE ]["     ;High ASCII "APPLE ]["
; 
; ==============================================================================
; Cursor Keys Translation Table
; ==============================================================================
; 
XLTBL           DFB   'D' | $80       ;High ASCII ($C4 = 196) "D"
                DFB   'B' | $80       ;High ASCII ($C2 = 194) "B"
                DFB   'A' | $80       ;High ASCII ($C1 = 193) "A"
                DFB   DELETE          ;High ASCII ($FF = 255) "Delete"
                DFB   'C' | $80       ;High ASCII ($C3 = 195) "C"
                DFB   DELETE          ;High ASCII ($FF = 255) "Delete"
                DFB   DELETE          ;High ASCII ($FF = 255) "Delete"
                DFB   DELETE          ;High ASCII ($FF = 255) "Delete"
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; End of Section (FAFD-FB18): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; 6502 Registers (Letter-Names)
; ==============================================================================
; 
; RTBL Must ORG $FB19 for New Monitor to remain equal to Old Mmonitor ROM
RTBL            DFB   'A' | $80       ;6502 Accumulator Register
                DFB   'X' | $80       ;6502 X-Index Register
                DFB   'Y' | $80       ;6502 Y-Index Register
                DFB   'P' | $80       ;6502 Processor Status Register
                DFB   'S' | $80       ;6502 Stack Pointer Register

; ==============================================================================
; Read Paddle (X-Reg), Return Time-Count in (Y-Reg)
; ==============================================================================
; 
PREAD           LDA   PTRIG           ;~($C07X)[R/W]; Trigger/Reset All Paddles
PREAD4          LDY   #0              ;Initialize Time-Counter
                NOP                   ;Compensate for First Time-Count: Do zip
                NOP                   ;for (2 NOPs)*(2 cycles/NOP)=4 cycles
PREAD2          LDA   PADDL0,X        ;Read Paddle (X-Reg)
                BPL   MON_RTS2D       ;Timed-Out if (A) is positive [0<=(A)<128]
                INY                   ;Count UP (Y) every 12 microseconds
                BNE   PREAD2          ;Exit at (Y=0) for a Max Count of 255
                DEY                   ;*: Return Last Time-Count in (Y)
MON_RTS2D       RTS                   ;* [Time=~(Y)*12us]; Return to Caller

; ==============================================================================
; Initialize Video Screen for Text Mode
; ==============================================================================
; 
INIT            LDA   #0              ;Clear Acc for Screen Initialization:
                STA   STATUS          ;Save Status Register in P-Reg Safe
TEXT01          LDA   LORES           ;Reset HiRes Mode to LoRes/Text Mode
TEXT02          LDA   TXTPAGE1        ;Display Text Page1; R/W Main V-RAM
SETTXT          LDA   TXTSET          ;Set Screen to Text Mode
                LDA   #0              ;Clear Accumulator (Again)
                BEQ   SETWND          ;Always Taken

; ==============================================================================
; Initialize Video Screen for Mixed Graphics & Text Mode
; ==============================================================================
; 
SETGR           LDA   TXTCLR          ;Set Screen to Graphics Mode
                LDA   MIXSET          ;Set Mixed Graphics & Text Mode
                JSR   CLRTOP          ;Clear Top (40 Lines on) Lo-Res Screen
                LDA   #20             ;Normal Mixed Graphics & Text Window Top
SETWND          STA   WNDTOP          ;Set Top of Scroll Window
                LDA   #0              ;Normal Lo-Res/Text Window Left
                STA   WNDLFT          ;Set Left Column of Scroll Window
SETWND2         LDA   #40             ;Normal Lo-Res/Text Window Width
                STA   WNDWDTH         ;Set Width of Scroll Window
                LDA   #24             ;Normal Lo-Res/Text Window Bottom
                STA   WNDBTM          ;Set Bottom of Scroll Window
                LDA   #23             ;Normal Text Window Bottom Line Number
TABV            STA   CV              ;Place Cursor at Line (A) & Column (CH) 
                JMP   MON_VTAB        ;TAB to ROW specified in (A)

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Start of Section (FB60-FBC0): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Display TITLE ("Apple ][") centered on top line of Screen
; ==============================================================================
; 
APPLEII         JSR   HOME            ;Clear Text Display & Home Cursor
                LDY   #8              ;Prepare to Display 8 Title Characters
STITLE          LDA   TITLE-1,Y       ;Get a Title Character to Display
                STA   LINE1+14,Y      ;Put a Title Character in Display Memory
                DEY                   ;Reduce Loop Character Counter
                BNE   STITLE          ;Loop until all Title Characters Displayed
                RTS                   ;Return to Caller

; ==============================================================================
; Set Power-Up Reset CHKSUM [(SOFTEV+1)EOR #$A5]       [Done differently above!]
; ==============================================================================
; 
; ------------------------------------------------------------------------------
; SETPWRC     [No Drop-In]          ;Never Referenced [Can Never Happen]
; (Only Exception: User-Callable Entry Point; BASIC: CALL -1,169 or CALL 64,367
; ------------------------------------------------------------------------------
; 
SETPWRC         LDA   SOFTEV+1        ;Get Soft Entry (Warm Start) Vector, High
                EOR   #$A5            ;Compute: [(SOFTEV+1)EOR #$A5]
                STA   PWREDUP         ;Power-Up Reset CHKSUM
                RTS                   ;Return to Caller

; ==============================================================================
; Pause: Check for a Computer Operator Pause Request; if Requested, Pause until
; another Key is Pressed; then continue on, unless Stop (Ctrl-C) is Requested!
; ==============================================================================
; 
VIDWAIT         CMP   #RTNH           ;Is (A)=(Carriage Return)?
                BNE   NOWAIT          ;NO, Do Not Wait
                LDY   KBD             ;YES, Has a Key been Pressed?
                BPL   NOWAIT          ;NO, Do Not Wait
                CPY   #CTRLSH         ;YES, was it a Ctrl+S Character?
                BNE   NOWAIT          ;NO, Do Not Wait
                BIT   KBDSTRB         ;YES, Clear KBD Strobe (Make KBD<128)
KBDWAIT         LDY   KBD             ;Wait until next Key to Resume
                BPL   KBDWAIT         ;Loop, Wait for Keypress
                CPY   #CTRLCH         ;Key Pressed, was it a Ctrl+C Character?
                BEQ   NOWAIT          ;YES, Do Not Wait
                BIT   KBDSTRB         ;NO, Clear KBD Strobe (Make KBD<128)
NOWAIT          JMP   VIDOUT          ;& Do as Before

; ==============================================================================
; Escape Character Handlers:
; ==============================================================================
; 
; ----------------------------------- ;Old Escape Character Handler:
ESCOLD          SEC                   ;Prepare for Add with Carry Set (Adds 1)
                JMP   ESC1            ;Handle Escape Character

; ----------------------------------- ;New Escape Character Handler:
ESCNOW          TAY                   ;Use Character as Index
                LDA   XLTBASE,Y       ;Translate (I|J|K|M) to (C|B|A|D)
;              >>>--> XLTBL EQU $FB11 ;^[XLTBL=(Cursor Keys Translation Table)]
;                                     ;^[XLTBASE=XLTBL-("I"=$C9=201)=$FA48]
                JSR   ESCOLD          ;Do Cursor Motion
                JSR   RDKEY           ;& Get in (A) & Make Cursor Char Flash
ESCNEW          CMP   #'N' | $80      ;Was it an "N" Character?
                BCS   ESCOLD          ;YES, "N" or Greater, Do it
                CMP   #'I' | $80      ;Was it an "I" Character?
                BCC   ESCOLD          ;YES, "I" or Less, Do it
                CMP   #'L' | $80      ;Was it an "L" Character?
                BEQ   ESCOLD          ;YES, Do it
                BNE   ESCNOW          ;Loop: Handle New Character; Always Taken

; ==============================================================================
; NOP Free Space [that can be changed in (Apple II Plus) Emulator ROM images]:
; ==============================================================================
; 
VERSION         DFB   $EA             ;14 NOP Bytes . . .
                DFB   $EA
                DFB   $EA             ;This space could be used
                DFB   $EA             ;by anyone if this were in
                DFB   $EA             ;LC RAM instead of MB ROM!
                DFB   $EA
                DFB   $EA             ;This space (FBB3-FBBE) is used
                DFB   $EA             ;in the Apple IIE Autostart ROM
                DFB   $EA
                DFB   $EA
                DFB   $EA
                DFB   $EA
ZIDBYTE2        DFB   $EA             ;(Not Used Yet)
ZIDBYTE         DFB   $EA             ;(Not Used Yet)

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; End of Section (FB60-FBC0): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Calculate Text Base Address (BASH,BASL) for Left End of Screen Line Number
; (Not Window Line Number) in A-Reg [# Range: (0~23)=($00~$17)=(%00000~%10111)]
; ==============================================================================
;  BASCALC [to set Text Line Base Address (BASH,BASL)] is almost identical to 
; GBASCALC [to set Graphics Base Address (GBASH,GBASL)]
; ---------------------------vv-------------------------vv----------vv----vv----
; F847: 48 4A 29 03 09 04 85 27 68 29 18 90 02 69 7F 85 26 0A 0A 05 26 85 26 60
; FBC1: 48 4A 29 03 09 04 85 29 68 29 18 90 02 69 7F 85 28 0A 0A 05 28 85 28 60
; ------------------------------------------------------------------------------
; Note: Indexed Addressing of the Base Address ZP Pointers would allow S/R's 
; to be combined into one S/R with one or two different Entry Points to preset 
; which task is being processed (e.g., GBASL,X & GBASH,X & X=0 or X=2)
; ------------------------------------------------------------------------------
;     GBASL    EQU     $26            ;Graphics Base Address, Low
;     GBASH    EQU     $27            ;Graphics Base Address, High
;     BASL     EQU     $28            ;Text Base Address, Low
;     BASH     EQU     $29            ;Text Base Address, High
; ==============================================================================
; 
; BASCALC Must ORG $FBC1 for New Monitor to remain equal to Old Mmonitor ROM
; 
; ----------------------------------- ;Set Line Base Address (BASH,BASL):
;                                     ;^[RAM Address of Text Line Specified]
BASCALC         PHA                   ;Push Line Number Specified [%000ABCDE]
;              ---------------------- ;Compute Text Base Address, High (BASH):
                LSR   A               ;Shift %000ABCDE->%0000ABCD & %E->(C)**
;                                     ;[Shifts BASH->{%E->(C)**}->BASL, below]
                AND   #%00000011      ;Generate %000000CD
                ORA   #%00000100      ;Generate %000001CD
                STA   BASH            ;Set Text Base Address, High [Pages 4~7]
;              ---------------------- ;Compute Text Base Address, Low (BASL):
                PLA                   ;Pull Line Number Specified [%000ABCDE]
                AND   #%00011000      ;Generate %000AB000
                BCC   BASCALC2        ;Branch if %E->(C=0)**; Skip Next (Add):
                ADC   #$7F            ;Else, Add [$7F+(C=1)=$80]->[%100AB000]**
;                                     ;[Shifts BASH->{%E->(C=1)**}->BASL]
;                     --------------- ;Generate: %E00AB000->%EABAB000:
BASCALC2        STA   BASL            ;Set Text Base Address, Low [%E00AB000]
                ASL   A               ;[(A)=(A*2)]: Generate %00AB0000
                ASL   A               ;[(A)=(A*2)]: Generate %0AB00000
                ORA   BASL            ;Generate %EABAB000=[%0AB00000|%E00AB000]
                STA   BASL            ;Set Text Base Address, Low [%EABAB000]
;                                     ;^[(0~$78)=(0~120)|($80~$F8)=(128~248)]
;                                     ;^[Off Screen Holes: $78~$7F & $F8~$FF]
;              ---------------------- ;Now (BASH,BASL)=[%0000,01CD,EABA,B000]
; 
;                                     ;------------+---------+---------+
;                                     ; Screen Line Base Addresses:    |
;                                     ;------------+---------+---------+
;                                     ;            |  BASH   |  BASL   |
;                                     ;------------+---------+---------+
;                                     ;  Top 3rd of Text Screen:       |
;                                     ;------------+---------+---------+
;                                     ;$400, 1024, %0000,0100,0000,0000;
;                                     ;$480, 1152, %0000,0100,1000,0000;
;                                     ;$500, 1280, %0000,0101,0000,0000;
;                                     ;$580, 1408, %0000,0101,1000,0000;
;                                     ;$600, 1536, %0000,0110,0000,0000;
;                                     ;$680, 1664, %0000,0110,1000,0000;
;                                     ;$700, 1792, %0000,0111,0000,0000;
;                                     ;$780, 1920, %0000,0111,1000,0000;
;                                     ;------------+---------+---------+
;                                     ;  Middle 3rd of Text Screen:    |
;                                     ;------------+---------+---------+
;                                     ;$428, 1064, %0000,0100,0010,1000;
;                                     ;$4A8, 1192, %0000,0101,1010,1000;
;                                     ;$528, 1320, %0000,0101,0010,1000;
;                                     ;$5A8, 1448, %0000,0100,1010,1000;
;                                     ;$628, 1576, %0000,0110,0010,1000;
;                                     ;$6A8, 1704, %0000,0110,1010,1000;
;                                     ;$728, 1832, %0000,0111,0010,1000;
;                                     ;$7A8, 1960, %0000,0111,1010,1000;
;                                     ;------------+---------+---------+
;                                     ;  Bottom 3rd of Text Screen:    |
;                                     ;------------+---------+---------+
;                                     ;$450, 1104, %0000,0100,0101,0000;
;                                     ;$4D0, 1232, %0000,0100,1101,0000;
;                                     ;$550, 1360, %0000,0101,0101,0000;
;                                     ;$5D0, 1488, %0000,0101,1101,0000;
;                                     ;$650, 1616, %0000,0110,0101,0000;
;                                     ;$6D0, 1744, %0000,0110,1101,0000;
;                                     ;$750, 1872, %0000,0111,0101,0000;
;                                     ;$7D0, 2000, %0000,0111,1101,0000;
;                                     ;------------+---------+---------+
;                                     ;  BASH,L:   %0000,01CD,EABA,B000;
;                                     ;------------+---------+---------+
; 
; ----------------------------------- ;Returns: BASH=000001CD; BASL=EABAB000
                RTS                   ;Return to Caller

; ==============================================================================
; Sound Bell                   [(*) BELLA & BELLB are Undocumented Entry Points]
; ==============================================================================
; 
; ----------------------------------- ;Assure Sound Bell Character:
BELL1           CMP   #BELL_H         ;Is (A) a Bell (Cntrl-G) Character?
                BNE   MON_RTS2B       ;NO, Return to Caller
; 
; (*) ------------------------------- ;Sound Bell regardless of Output Device:
BELLA           LDA   #64             ;Delay .01 Second
                JSR   MON_WAIT        ;Delay (26+27*Acc+5*(Acc*Acc))/2 Cycles
; 
; (*) ------------------------------- ;Sound Bell without first WAIT:
BELLB           LDY   #192            ;Toggle Speaker at 1 Khz for .1 Second
; 
;              ---------------------- ;Sound Bell Loop:
BELL2           LDA   #12             ;Toggle Speaker at 1 Khz for (Y) Time
                JSR   MON_WAIT        ;Delay (26+27*Acc+5*(Acc*Acc))/2 Cycles
                LDA   SPKR            ;Toggle Speaker Output
                DEY                   ;Reduce Loop Counter
                BNE   BELL2           ;Loop Until Done
MON_RTS2B       RTS                   ;Return to Caller

; ==============================================================================
; Output A-Reg as Text (Place Character in Screen Memory):
; ==============================================================================
; 
STORADV         LDY   CH              ;Set Y-Index to Cursor Horizontal (CH)
                STA   (BASL),Y        ;Put Char (A) in (Base Adrs) Line at (CH)
ADVANCE         INC   CH              ;Advance Cursor Horizontal (Move Right)
                LDA   CH              ;Get Cursor Horizontal
                CMP   WNDWDTH         ;Is Cursor Horizontal past Window Width?
                BCS   CARRETURN       ;YES, Return Cursor (CR) to Next Line
MON_RTS3        RTS                   ;NO, Return to Caller

; ==============================================================================
; Output A-Reg as Text (Place in Screen Memory) or Process Control Character:
; ==============================================================================
; 
VIDOUT          CMP   #' ' | $80      ;Is (A) a Control Character [$80~$9F]?
                BCS   STORADV         ;BGE: NO, Output Char (A) as Text 
; <---[Page Boundary] (in the middle of the DWord above)
                TAY                   ;YES; Is Ctrl-Char an Inverse Video Char?
                BPL   STORADV         ;YES, Output Inverse Video Character
                CMP   #RTNH           ;NO; Is Ctrl-Char a Carriage Return (CR)?
                BEQ   CARRETURN       ;YES, Return Cursor (CR) to Next Line
                CMP   #LFH            ;NO; Is Ctrl-Char a Line Feed?
                BEQ   LINEFEED        ;If YES, Go Do a Line Feed
                CMP   #BSH            ;NO; Is Ctrl-Char a Back Space (Ctrl-H)?
                BNE   BELL1           ;NO; Go Check if it is a BELL (Ctrl-G)?
; ----------------------------------- ;YES, Char (A) is a Back Space (Ctrl-H)
BACKSPACE       DEC   CH              ;Reduce Cursor Horizontal
                BPL   MON_RTS3        ;If Positive, Return to Caller; Else:
;              ---------------------- ;Move to Rightmost Screen Column:
                LDA   WNDWDTH         ;Get Width of Scroll Window
                STA   CH              ;Set Cursor Horizontal (CH=WNDWDTH)
                DEC   CH              ;Reduce Cursor Horizontal (CH=CH-1)
;              ---------------------- ;Move Up (at Rightmost Screen Column):
CURSORUP        LDA   WNDTOP          ;Get Top of Scroll Window
                CMP   CV              ;Is Cursor Vertical (CV) at Top of Window?
                BCS   MON_RTS4        ;If at Top Line, Return to Caller
                DEC   CV              ;Else, Reduce Cursor Vertical (CV=CV-1)
; ----------------------------------- ;TAB to ROW specified in A-Reg:
MON_VTAB        LDA   CV              ;Get Cursor Vertical
VTABZ           JSR   BASCALC         ;Generate Base Address
                ADC   WNDLFT          ;Add Left Column of Scroll Window
                STA   BASL            ;Set Base Address, Low
;                                     ;^[There shouldn't be any Carryover!]
MON_RTS4        RTS                   ;Return to Caller

; ==============================================================================
; Escape Character Handler:
; ==============================================================================
; 
; ------------------------------------; Handle Escape Character
ESC1            EOR   #'@' | $80      ;Is Char (A)=("@")?
                BEQ   HOME            ;Branch if Esc+@, Do Home & Clear
;                                     ;^[("@"=$C0)XOR("@"=$C0)=(0)**]
                ADC   #$FD            ;Is Char (A)=("A"|"B")?  [Adds (C=1)]
                BCC   ADVANCE         ;Branch if Esc+A, Advance
;                                     ;^[("@"=$C0)XOR("A"=$C1)=(1) ->
;                                     ; (1)+($FD)+(C=1)=($FF)=(-1) ->(C=0)**]
                BEQ   BACKSPACE       ;Branch if Esc+B, Backspace
;                                     ;^[("@"=$C0)XOR("B"=$C2)=(2) ->
;                                     ; (2)+($FD)+(C=1)=(0)**]
                ADC   #$FD            ;Is Char (A)=("C"|"D")?  [Adds (C=1)]
                BCC   LINEFEED        ;Branch if Esc+C, Down
;                                     ;^[("@"=$C0)XOR("C"=$C3)=(3) ->
;                                     ; (3)+($FD)+(C=1)=(1) ->(C=1)->
;                                     ; (1)+($FD)+(C=1)=($FF)=(-1) ->(C=0)**]
                BEQ   CURSORUP        ;Branch if Esc+D, Up
;                                     ;^[("@"=$C0)XOR("D"=$C4)=(4) ->
;                                     ; (4)+($FD)+(C=1)=(2) ->(C=1)->
;                                     ; (2)+($FD)+(C=1)=(0)**]
                ADC   #$FD            ;Is Char (A)=("E"|"F")?  [Adds (C=1)]
                BCC   CLREOL          ;Branch if Esc+E, Clear to End of Line
;                                     ;^[("@"=$C0)XOR("E"=$C5)=(5) ->
;                                     ; (5)+($FD)+(C=1)=(3) ->(C=1)->
;                                     ; (3)+($FD)+(C=1)=(1) ->(C=1)->
;                                     ; (1)+($FD)+(C=1)=($FF)=(-1) ->(C=0)**]
                BNE   MON_RTS4        ;Branch if Not Esc+F, Return to Caller
;                                     ;^[("@"=$C0)XOR("F"=$C6)=(6) ->
;                                     ; (6)+($FD)+(C=1)=(4) ->(C=1)->
;                                     ; (4)+($FD)+(C=1)=(2) ->(C=1)->
;                                     ; (2)+($FD)+(C=1)=(0)**]
; ----------------------------------- ;Else, Esc+F, Clear to End of Page
;                                     ;[Unused, User-Callable Entry Point]:
CLREOP          LDY   CH              ;Get Cursor Horizontal (CH)
                LDA   CV              ;Get Cursor  Vertical  (CV)
; ----------------------------------- ;Clear to End of Page Loop
;                                     ;[User-Callable Entry Point]:
CLEOP1          PHA                   ;Push Current Line (Save on STACK)
                JSR   VTABZ           ;Set Base Address (Updates BASL)
                JSR   CLREOLZ         ;Clear to End of Line (EOL) & Set Carry
                LDY   #0              ;Clear from Line Left End (CH=0) for Rest
                PLA                   ;Pull Current Line (Retrieve from STACK)
                ADC   #0              ;Advance Current Line  [Adds (C=1)]
                CMP   WNDBTM          ;Cleared to Bottom of Window?
                BCC   CLEOP1          ;NO, Keep Clearing Lines
                BCS   MON_VTAB        ;YES, Tab to Current Line; Always Taken

; ==============================================================================
; "HOME" Statement: Immediate & Deferred; No Parameters
; ==============================================================================
; Moves Cursor to Upper Left Screen Position within Scrolling Window & Clears
; all Text within Window; Same as "CALL -936" & "ESC @ RETURN"
; ==============================================================================
; 
; ----------------------------------- ;Initialize Cursor Vertical & Horizontal:
HOME            LDA   WNDTOP          ;Get Top of Scroll Window
                STA   CV              ;Set Cursor  Vertical  (CV)
                LDY   #0              ;Clear Y-Index Register
                STY   CH              ;Clear Cursor Horizontal (CH)
                BEQ   CLEOP1          ;Clear to End of Page; Always Taken

; ==============================================================================
; Return Cursor [Printer/Typewriter Carriage Return] (CR) to Start of Next Line:
; ==============================================================================
; Forget about Printer/Typewriter Carriage Returns; this is more about the
; Apple II Cursor (on Screen) than it is about those old mechanical devices! 
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Return Cursor (CR) to Start of Next Line:
CARRETURN       LDA   #0              ;Clear Accumulator
                STA   CH              ;Clear Cursor Horizontal to Start of Line
; ----------------------------------- ;Down (Esc+C/Ctrl+J), Do a Line Feed:
LINEFEED        INC   CV              ;Advance Cursor Verical  to Next Line
                LDA   CV              ;Get Cursor Verical [Now Line # (0~23)]
                CMP   WNDBTM          ;Is Cursor Vertical Off Screen (CV>23)?
                BCC   VTABZ           ;NO, Set Base Address (Updates BASL)
                DEC   CV              ;YES, Reduce Cursor Vertical to Bottom
; ----------------------------------- ;Scroll Window Up (Line by Line)
;                                     ;[Unused, User-Callable Entry Point]:
SCROLL          LDA   WNDTOP          ;Start at Top of Scroll Window
                PHA                   ;Push Scroll Window Top (Save on STACK)
                JSR   VTABZ           ;Set Base Address (Updates BASL)
; ----------------------------------- ;Scrolling Loop:
;                     --------------- ;Save Current Line Base Address;
;                                     ;Copy Base Address [(BASL,H)->(BAS2L,H)]:
SCRL1           LDA   BASL            ;Get Base Address (1), Low
                STA   BAS2L           ;Set Base Address Two, Low
                LDA   BASH            ;Get Base Address (1), High
                STA   BAS2H           ;Set Base Address Two, High
;                     --------------- ;Initialize Y-Index Register to 
;                                     ;Rightmost Column of Scrolling Window:
                LDY   WNDWDTH         ;Get Window Width
                DEY                   ;Reduce to Rightmost Scroll Window Column
;                     --------------- ;Check if at Bottom of Scrolling Window:
                PLA                   ;Pull Scroll Window Top (Retrieve STACK)
                ADC   #1              ;Advance Scroll Window Top (Now Line #)
                CMP   WNDBTM          ;Reached Bottom of Scroll Window, Done?
                BCS   SCRL3           ;BGE [Exit Loop]: YES, Go Finish Up
                PHA                   ;NO, Push Scroll Window Top (Now Line #)
                JSR   VTABZ           ;Set Base Address (Updates BASL)
;              ---------------------- ;Move Characters (A) Up One Line (Loop):
SCRL2           LDA   (BASL),Y        ;Get Character (on Now Line #) to Move Up
                STA   (BAS2L),Y       ;Move Up: Set Character (on Now Line # -1)
                DEY                   ;Reduce Column [Going from Right to Left]
                BPL   SCRL2           ;Move Up: Next Characater
;              ---------------------- ;Done with Chacracters on this Line
                BMI   SCRL1           ;Scroll Up: Next Line; Always Taken

; ----------------------------------- ;Scroll Window Up (Line by Line) Done;
;                                     ;Fininsh Up; Clear Bottom Line of Window:
SCRL3           LDY   #0              ;Clear (Indirect Addressing),Y-Index for:
                JSR   CLREOLZ         ;Clear to End of Line & Set Carry
                BCS   MON_VTAB        ;Always Taken
; 
; ==============================================================================
; (Esc+E): Clear from Cursor [(BASL),(CH|Y)] to End of Line [(BASL),(WNDWDTH)]:
; ==============================================================================
; 
; ----------------------------------- ;Clear from Cursor [(BASL),(CH)] to EOL:
CLREOL          LDY   CH              ;Get Cursor Horizontal Position
; ----------------------------------- ;Clear from Cursor [(BASL),(Y)] to EOL:
CLREOLZ         LDA   #' ' | $80      ;Get a Blank/Space Character to Fill with
; ----------------------------------- ;Chr Fill from Cursor [(BASL),(Y)] to EOL
;                                     ;Loop [& User-Callable Entry Point]:
CLEOL2          STA   (BASL),Y        ;Set Char (A) at Line (BASL), Column (Y)
                INY                   ;Advance Column Counter
                CPY   WNDWDTH         ;Has End of Line been reached?
                BCC   CLEOL2          ;BLT [Loop]: NO, Continue Filling Line
                RTS                   ;YES, Done Filling; Return to Caller

; ==============================================================================
; Mon Wait Subroutine: [This is a Simple Algorithm for a Quadratic Equation!]
; ==============================================================================
; Wait Time is from Call (JSR MON_WAIT) to End of Return to Caller (End of RTS);
; Wait Time in Microseconds at the Non-Accelerated Speed of an Apple II Plus is:
;   [Time]=[Delay (5*(Acc*Acc)+27*Acc+26)/2 Cycles]*[1.023 Microseconds/Cycle]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Delay (26+27*Acc+5*(Acc*Acc))/2 Cycles
;                                     ;v--[Cycles/Operation]
;                                     ;6: For "JSR MON_WAIT" to get here!
MON_WAIT        SEC                   ;2: Prepare to Subtract w/o Borrow
MON_WAIT2       PHA                   ;3: Push Accumulator (Save on STACK)
MON_WAIT3       SBC   #1              ;2: Subtract w/o Borrow [A-Data-!C]
                BNE   MON_WAIT3       ;2+ Loop Until (A=0) [5 cycles/iteration]
;                                     ;   ^[4 cycles/iteration when (A=0)]
                PLA                   ;4: Pull Accumulator (Retrieve from STACK)
                SBC   #1              ;2: Subtract w/o Borrow [A-Data-!C]
                BNE   MON_WAIT2       ;2+ Loop Until (A=0) [~5*(A)+12 cycles/it]
;                                     ;   ^[~5*(A)+11 cycles/it when (A=0)]
                RTS                   ;6: Return to Caller

; ==============================================================================
; Next A4 & Next A1: Monitor General Purpose (16 Bit) Accumulator Registers
; ==============================================================================
; 
NXTA4           INC   A4L             ;Increment General Purpose A4-Reg, Low
                BNE   NXTA1           ;Branch if Not yet up to Next Page
                INC   A4H             ;Increment General Purpose A4-Reg, High
;              ---------------------- ;Has A1 Reached A2?
NXTA1           LDA   A1L             ;Get General Purpose A1-Reg, Low
                CMP   A2L             ;Subtract: (A)=(A1L-A2L)
                LDA   A1H             ;Get General Purpose A1-Reg, High
                SBC   A2H             ;Subtract: (A)=(A1H-A2H)
                INC   A1L             ;Increment General Purpose A1-Reg, Low
                BNE   MON_RTS4B       ;Branch if Not yet up to Next Page
                INC   A1H             ;Increment General Purpose A1-Reg, High
;              ---------------------- ;Caller should Check if A1 Has Reached A2:
MON_RTS4B       RTS                   ;Return to Caller

; ==============================================================================
; Internal Cassette Tape Write (Output) & Read (Input) Routines: HEADER, WRBIT,
; RDBYTE, RD2BIT, RDBIT, WRBYTE (See: "Apple II Monitors Peeled" pgs.81~84)
; ==============================================================================
; 
; ==============================================================================
; Cassette Tape Record Synchronization Header Subroutine:
; ==============================================================================
; Writes Synchronization Monotone to Audio-Out: The first part of every Tape
; Record is a 10 sec 770 hz (1300 usec/cycle) header tone (See TN/TIL# 495~496)
; ------------------------------------------------------------------------------
; (A)=[Synchronization Header Length (0.2~40 sec)]; (X)=[Audio Half-Cycle Toggle
; Count (Clear at Entry)]; (Y)=(Loop Duration Count); Writing to Tape/Audio-Out:
; (C)=[Clear for a Zero-Bit, or Set for a One-Bit (Set at Entry)]
; ------------------------------------------------------------------------------
; Write [(A)*256] 'Long-1' Half-Cycles (650 usec each); Then, Write a 'Short-0'
; Sync Bit, 2 Half-Cycles (200+250=450 usec/{1 cycle}); Normal (Not Short/Long)
; Half-Cycle Durations are 250 usec for a Zero-Bit & 500 usec for a One-Bit
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Write Tape Synchronization Monotone:
HEADER          LDY   #75             ;Get Time Count for Zero-Bit Delay Loop
;                                     ;^[For 'Long-1' (650 usec) Half-Cycles]
                JSR   ZERODLY         ;Write a Half-Cycle [Returns (Y=44)]
                BNE   HEADER          ;Branch Until Done <-[when (X=0)]
                ADC   #254            ;Decrement (A) {Add w/ Carry [A+Data+C]}
;                                     ;^[Add to Subtract: {C=1}+{$FE=(-2)}=(-1)]
                BCS   HEADER          ;BGE: Branch Until Done <-[when (A=C=0)]
;              ---------------------- ;Finish with Sync Bit:
                LDY   #33             ;Get Time Count for Zero-Bit Delay Loop
;                                     ;^[For Sync Bit (200 usec) Half-Cycle]
; ----------------------------------- ;Write a Bit (2 Half-Cycles) to Tape:
WRBIT           JSR   ZERODLY         ;Write a Half-Cycle [Returns (Y=44)]
                INY                   ;Advance Time Count [Now (Y=Y+1=45)]
                INY                   ;Advance Time Count [Now (Y=Y+2=46)]
;                                     ;^[For Normal (250 usec) Half-Cycle]
;              ---------------------- ;Zero-Bit Delay Loop: Write a Half-Cycle
ZERODLY         DEY                   ;Reduce Time Count for Zero-Bit Delay Loop
                BNE   ZERODLY         ;Loop Until Delay Period is Done <-(Y=0)
                BCC   WRTAPE          ;Branch if Doing a Zero-Bit
;                                     ;Else, Do a One-Bit, Add more Delay:
                LDY   #50             ;Get Time Count for One-Bit Delay Loop
;                                     ;^[For Normal (250+250 usec) Half-Cycle]
;              ---------------------- ;One-Bit Delay Loop: Write a Half-Cycle
ONEDLY          DEY                   ;Reduce Time Count for One-Bit Delay Loop
                BNE   ONEDLY          ;Loop Until Delay Period is Done <-(Y=0)
;              ---------------------- ;Write (One Half-Cycle Only) to Tape:
WRTAPE          LDY   TAPEOUT         ;Toggle Audio Data Output [(Y)=(Unkown!)]
                LDY   #44             ;Return (Y=44) .. [Now (Y)=(Known Value)]
;                                     ;^[Adds Time to 2nd WRBIT Zero-Bit Delay]
                DEX                   ;Reduce (X) Audio Half-Cycle Toggle Count
                RTS                   ;Return to Caller; [Final (A=$FF):{A2RM}]

; ==============================================================================
; Read Byte Subroutine: Reads a Byte (8 Bits) from a Cassette Tape Record
; ==============================================================================
; The Duration between 2 Voltage Transitions from Tape determines whether a Bit
; is a Zero-Bit or a One-Bit; (Y) is used to Count this Period of Time; If it
; has Time to go Negative, the Duration is Longer, representing a One-Bit; If it
; does not go Negative, the Duration is Shorter, representing a Zero-Bit; Carry
; (C) is Set or Cleared, respectively, based on (Y), & Used to Rotate the Bit
; into the Accumulator (A); After 8 Bits, (A) represents a Byte Read from Tape
; ------------------------------------------------------------------------------
; 
RDBYTE          LDX   #8              ;Prepare to Read a Byte (8 Bits) from Tape
RDBYT2          PHA                   ;Push Accumulator (Save on STACK)
                JSR   RD2BIT          ;Read Two Transitions (Find Edge)
                PLA                   ;Pull Accumulator (Retrieve from STACK)
                ROL   A               ;Next Bit; Shift Carry into (A) Low Bit
;                                     ;& Discard Old (A) High Bit into Carry
                LDY   #$3A            ;Count for RD2BIT/RDBIT Sampling (58~0)
                DEX                   ;Reduce Bit Count
                BNE   RDBYT2          ;Loop Until Done <-(X=0)
                RTS                   ;Return to Caller

; ==============================================================================
; Read Bits Subroutines: Read Voltage Transitions (2 or 1) from a Tape Record
; ==============================================================================
;                         [See RDBYTE Description above]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Read 2 Transitions from Tape Record:
RD2BIT          JSR   RDBIT           ;Read 1st of Two Voltage Transitions
; ----------------------------------- ;Read 1 Transition from Tape Record:
RDBIT           DEY                   ;Reduce (Y) Until Voltage Transitions
                LDA   TAPEIN          ;Read Cassette Tape Data Input
; <---[Page Boundary] (in the middle of the DWord above)
                EOR   LASTIN          ;XOR with Last Input Voltage Detected
;                                     ;<<< LASTIN Unkown 1st time through! >>>
                BPL   RDBIT           ;Loop Until a Voltage Change is Detected
                EOR   LASTIN          ;XOR with Last Input Voltage Detected
                STA   LASTIN          ;Reset Last Input Voltage Detected
                CPY   #$80            ;Set Carry on (Y):(58~0) becoming Negative
                RTS                   ;Return to Caller

; ==============================================================================
; End Of Internal Cassette Tape Write (Output) & Read (Input) Routines
; ==============================================================================
; 
; 
; ==============================================================================
; Keyboard Character Input, Line Building, & Input Display Routines
; ==============================================================================
; Keyboard Input & Screen Output, Division Of Labor:
; ------------------------------------------------------------------------------
; Routines supporting Keyboard Input are designed to echo Keyboard Input to User
; Output (through COUT) to the Display Screen Scroll Window at the Current
; Cursor Position, & store the Characters Entered into the Keyboard Input Buffer
; ($0200~$02FF) for the convenience of the Calling Program, which may Position
; the Cursor anywhere (on Screen), before Calling the Keyboard Input Routines;
; on Entry of a Carriage Return from the Keyboard, the Keyboard Input Routines
; will Return back to the Calling Program, with the Character Count (plus one)
; in X-Reg & a Carriage Return in the Input Buffer as a Terminator; the Calling
; Program need not look within the Display Screen to Determine what was Entered;
; the X-Reg begins with a Zero, so if Five Characters are Entered, the X-Reg
; will reflect Four, although the Actual Value Returned will be Five--because
; the X-Reg is Incremented for the Carriage Return as well--[so X-Reg as the
; Character Count is actually accurate at plus one--as if (1) it started at One
; instead of Zero & (2) it is Not Counting the Carriage Return!].
; ==============================================================================
; 
; 
; ==============================================================================
; Read Key Subroutine: Makes Current Char Flash; & Puts it in (A) & (CH) in (Y)
; ==============================================================================
; RDKEY is the same as RDCHAR except that it bypasses Escape Key support--
; [because RDCHAR Calls RDKEY 1st, before doing the "ESC" Key Test!]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Get in (A) & Make Cursor Character Flash:
RDKEY           LDY   CH              ;Get Cursor Horizontal
                LDA   (BASL),Y        ;Get Char at (BASL,H) Line & Column (Y=CH)
RDKEY0          PHA                   ;Push/Save Current Character at Cursor
                AND   #%00111111      ;Truncate Character to 6 Lower Bits
                ORA   #%01000000      ;Set Bit 6 of Character to Make it Flash
                STA   (BASL),Y        ;Set Char at (BASL,H) Line & Column (Y=CH)
                PLA                   ;Pull/Retrieve Current Character at Cursor
;                                     ;Key Switch (KSW) Input Hook ...
RDKEY1          JMP   (KSWL)          ;Returns to Caller of RDKEY

; ==============================================================================
; KEYIN gets the Next Key Input from the Keyboard; 
; KEYIN is usually the Target of the Key Switch (KSW) Character Input Hook
; ==============================================================================
; 
; ----------------------------------- ;Get Key Press @ Keyboard Input Register:
KEYIN           INC   RNDL            ;Advance Keyin Random Counter Value, Low
                BNE   KEYIN2          ;Branch if High Advance Not Needed Yet
                INC   RNDH            ;Advance Keyin Random Counter Value, High
KEYIN2          BIT   KBD             ;Check Keyboard Input Reg for a Key Press
                BPL   KEYIN           ;Branch if No Key has been Pressed
                STA   (BASL),Y        ;Store (A) at (BASL,H) Line & Column (Y)
                LDA   KBD             ;Read Keyboard Input Reg; Get Key Pressed
                BIT   KBDSTRB         ;Clear KBD Strobe (KBD<128) for Next Key
                RTS                   ;Return to Caller

; ==============================================================================
; Escape Character Handler:
; ==============================================================================
; 
ESC             JSR   RDKEY           ;Get in (A) & Make Cursor Character Flash
                JSR   ESCNEW          ;Handle Escape Character [Doesn't Return!]
; 
; ==============================================================================
; Read Character Subroutine: Read a Character into (A)
; ==============================================================================
; 
RDCHAR          JSR   RDKEY           ;Get in (A) & Make Cursor Character Flash
                CMP   #ESCH           ;Is it The Escape Character?
                BEQ   ESC             ;YES, Handle The Escape Character
                RTS                   ;NO, Return to Caller

; ==============================================================================
; NOTCR: Character Input is NOT a Carriage Return; 
;        So, send it as Non Inverse Character to COUT
; ==============================================================================
; Receives control w/ Character of Interest in Input Buffer at ($0200,X)
; ------------------------------------------------------------------------------
; 
NOTCR           LDA   INVFLG          ;Get Current Setting of INVFLG (Text-Mask)
;                                     ;^[Normal=$FF, Flash=$7F, Inv=$3F]
                PHA                   ;Push/Save Setting of INVFLG
                LDA   #$FF            ;Get Normal-Text Text-Mask Value
                STA   INVFLG          ;Set Invers Flag/Mask to Normal-Text Value
                LDA   INBUFF,X        ;Get Character of Interest as Normal-Text
                JSR   COUT            ;Print Char of Interest as Normal-Text
                PLA                   ;Pull/Retrieve Prior Setting of INVFLG
                STA   INVFLG          ;Restore Current Setting of INVFLG
; --<Undocumented User Entry Point>-- ;Backspace or Cancel Check: 
NOTCR5          LDA   INBUFF,X        ;Get Character of Interest as was before
                CMP   #BSH            ;Is it a Ctrl-H: Backspace?
                BEQ   BCKSPC          ;Branch if it's a Backspace
                CMP   #CTRLXH         ;Is it a Ctrl-X: Cancelation?
                BEQ   CANCEL          ;Branch if it's a Cancelation
; --<Undocumented User Entry Point>-- ;Margin Check:
NOTCR4          CPX   #248            ;Is Character Pointer Near End of INBUFF?
; --<Undocumented User Entry Point>-- ;Wait for Next Char or a Carriage Return:
NOTCR3          BCC   NOTCR1          ;Branch if Not Near End of INBUFF
; --<Undocumented User Entry Point>-- ;Sound Warning Bell & Wait (as above):
NOTCR2          JSR   BELL            ;Else, Sound Bell, Warn: Near INBUFF End
NOTCR1          INX                   ;Advance to Next Character of Interest
                BNE   NXTCHAR         ;Branch if Not at Input Buffer End ($0300)
CANCEL          LDA   #'\' | $80      ;Terminate Input w/ Backslash [Ctrl+X|EOL]
                JSR   COUT            ;Print the Terminal Backslash [)-:RIP:-(]
GETLNZ          JSR   CROUT           ;Print Carriage Return (Ctrl-M) Character
; ----------------------------------- ;Get Input with Prompt Entry Point:
GETLN           LDA   PROMPT          ;Get Command Prompt Character
GETLN0          JSR   COUT            ;Print Command Prompt Character
; ----------------------------------- ;Get Input without Prompt Entry Point:
;                                     ;Init Input Index & it will Reduce to 0:
GETLN1          LDX   #1              ;Point to Start of Input Buffer +1
BCKSPC          TXA                   ;Get Current Ptr to Character of Interest
                BEQ   GETLNZ          ;Branch if Char Ptr is at INBUFF Zero|End
                DEX                   ;Else, Retreat to Prior Char of Interest
NXTCHAR         JSR   RDCHAR          ;Read Current Cursor Character into (A)
                CMP   #PICK           ;Is it a Right-Arrow [Ctrl-U (NAK)]?
                BNE   CAPTST          ;Branch if NOT Right-Arrow [Ctrl-U (NAK)]
;                                     ;Else, Use Screen Char under Right-Arrow:
                LDA   (BASL),Y        ;Get Char at (BASL,H) Line & Column (Y)
CAPTST          CMP   #'`' | $80      ;What is the Upper/Lower Case of Char (A)?
                BCC   ADDINP          ;BLT: Branch if Uppercase
                AND   #%11011111      ;Else, GE: Change Lowercase to Uppercase
ADDINP          STA   INBUFF,X        ;Set it in Input Line (to Uppercase)
                CMP   #RTNH           ;Is it a Carriage Return (Ctrl-M) Char?
                BNE   NOTCR           ;Branch if Not a Carriage Return (Ctrl-M)
CROUT1          JSR   CLREOL          ;Else, it's a CR, Clear to End of Line
; 
; ==============================================================================
; Print Carriage Return: Display Screen Scroll Window Output Routine
; ==============================================================================
; 
CROUT           LDA   #RTNH           ;Get a Carriage Return (Ctrl-M) Character
                BNE   COUT            ;Print (A) to Output Device; Always Taken

; ==============================================================================
; End Of Keyboard Character Input, Line Building, & Input Display Routines
; ==============================================================================
; 
; ==============================================================================
; Memory Dump Routines:
; ==============================================================================
; 
; ==============================================================================
; Print Memory Address: 
; ==============================================================================
; Print Carriage Return & Monitor General Purpose A1-Reg or Progrram Counter as
; 16-Bit Integer [(Y,X)={High,Low}] in Hexadecimal
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Print Monitor General Purpose A1-Reg:
PRA1            LDY   A1H             ;Get General Purpose A1-Reg, High
                LDX   A1L             ;Get General Purpose A1-Reg, Low
; ----------------------------------- ;Print Carriage Return & 16-Bit Integer:
PRYX2           JSR   CROUT           ;Print Carriage Return (Ctrl-M) Character
; --<Undocumented User Entry Point>-- ;Sound Warning Bell & Wait (as above):
PRYX3           JSR   PRNTYX          ;Print 16-Bit Integer [(Y,X)={High,Low}]
                LDY   #0              ;Clear Y-Index Register
                LDA   #'-' | $80      ;Get a Dash
                JMP   COUT            ;Print the Dash

; ==============================================================================
; Examine Eight Routine: Prints <= 8 Sequential Memory Locations Per Line in Hex
; ==============================================================================
; 
; ----------------------------------- ;[Y-Reg Must Be Zero on Entry]
XAM8            LDA   A1L             ;Get Monitor General Purpose A1-Reg, Low
                ORA   #%00000111      ;Get [(A1)OR(#7)]->[(A1)MOD(8 Bytes)]
                STA   A2L             ;Set Monitor General Purpose A2-Reg, Low
                LDA   A1H             ;Get Monitor General Purpose A1-Reg, High
                STA   A2H             ;Set Monitor General Purpose A2-Reg, High
; ----------------------------------- ;Modulus Check [(Adrs)MOD(8 Bytes)=(0)?]:
MOD8CHK         LDA   A1L             ;Get Monitor General Purpose A1-Reg, Low
                AND   #%00000111      ;[(A1)&(#7)]->[(A1)MOD(8 Bytes)] = Zero?
                BNE   DATAOUT         ;Branch if NOT at 1st of Mem Mod 8 Bytes
; ** Main Memory Dump Entry Point **  ;Examine Memory from (A1L,H) to (A2L,H):
XAM             JSR   PRA1            ;Else, Print Memory Address & a Dash, 1st
; ----------------------------------- ;Print Output Data to Output Device:
DATAOUT         LDA   #' ' | $80      ;Get a Space Char to Print (between parts)
                JSR   COUT            ;Print A-Reg to Output Device
                LDA   (A1L),Y         ;Get a Memory Byte (1 of <= 8 in Sequence)
                JSR   PRBYTE          ;Print A-Reg as Two-Digit Hex Number
                JSR   NXTA1           ;Increment A1 & Compare to A2
                BCC   MOD8CHK         ;BLT: Branch if (A1) has NOT Reached (A2)
                RTS                   ;Return to Caller

; ==============================================================================
; "Is Monitor Mode: Examine, Add (Plus), or Subtract (Minus)?" (XAMPM) Routine: 
; ==============================================================================
; For Mode Commands: Address Range Delimiter ("."); Add ("+"); or Subtract ("-")
; [Command Characters are converted to Command Tokens during the Input Process!]
; ------------------------------------------------------------------------------
; 
XAMPM           LSR   A               ;Shift (A*):LSB into Carry Flag
                BCC   XAM             ;Branch if [A*:Bit 0 was 0]; Do XAM
;                                     ;^[Examine Memory from (A1L,H) to (A2L,H)]
                LSR   A               ;Shift LSB into Carry Flag (Discarded)
                LSR   A               ;Shift LSB into Carry Flag
                LDA   A2L             ;Get Monitor General Purpose A2-Reg, Low
                BCC   ADD             ;Branch if [A*:Bit 2 was 0]; Do ADD (Plus)
;                                     ;Else [A*:Bit 2 was 1] Do SUBTRACT (Minus)
                EOR   #%11111111      ;Negate (A) <-[from (A2L)]
ADD             ADC   A1L             ;(A) = (A1L) + [{+|-}(A)<-(A2L)] + (C=1)
                PHA                   ;Push Result
                LDA   #'=' | $80      ;Print "=", then Result:
                JSR   COUT            ;Print (A) to Output Device
                PLA                   ;Pull Result
; 
; ==============================================================================
; Print A-Reg as Two-Digit Hex Number:
; ==============================================================================
; 
PRBYTE          PHA                   ;Push Accumulator (A); Save on STACK
                LSR   A               ;Shift High Nibble
                LSR   A               ;... to Low Nibble
                LSR   A               ;These 4 Shifts also Clear High Nibble
                LSR   A               ;Now Low Nibble is what High Nibble was
                JSR   PRHEXZ          ;Print Hi-Digit in Lo-Nibble as Hex Number
                PLA                   ;Pull Accumulator (A); Retrieve from STACK
; <User Entry Point (Label Not Used)> ;Print Low Nibble as Hex Number [0~9,A~F]:
PRHEX           AND   #%00001111      ;Mask Off High Nibble & Keep Low Nibble
PRHEXZ          ORA   #'0' | $80      ;Assure Byte is Hex Number Chr [0~9 & A~F]
                CMP   #':' | $80      ;Assure Byte is Dec Number Chr [0~9]<(":")
                BCC   COUT            ;Print # Now if Dec Number Chr [0~9]<(":")
                ADC   #6              ;Else Assure Letter [A~F]>=[(":")+6+(C=1)]
; 
; ==============================================================================
; Display Screen Scroll Window Output Routines:
; ==============================================================================
; 
; ==============================================================================
; Character Output Routine: Jump (Indirectly via Vector) to User Output Routine
; ==============================================================================
; 
COUT            JMP   (CSWL)          ;Print Accumulator (A) to Output Device

; ==============================================================================
; End of Memory Dump Routines
; ==============================================================================
; 
; ==============================================================================
; Character Output Routines:
; ==============================================================================
; COUT1 is usually the Target of the "Character Switch (CSW)" Output Hook/Vector
; ------------------------------------------------------------------------------
; COUT1: Write Byte in A-Reg to Display Screen at Current Cursor Position
;        [(CV),(CH)] using Inverse Flag Mask & supporting Cursor Move:
; ------------------------------------------------------------------------------
; COUTZ: Write Byte in A-Reg to Display Screen at Current Cursor Position
;        [(CV),(CH)] supporting Cursor Move but NOT using Inverse Flag Mask:
; ------------------------------------------------------------------------------
; 
COUT1           CMP   #' ' | $80      ;Is Char (A) a Ctrl-Char or Printable?
                BCC   COUTZ           ;BLT: Don't Output Ctrl Chars as Inverse
                AND   INVFLG          ;Text Mask (Normal=$FF|Flash=$7F|Inv=$3F)
COUTZ           STY   YSAV1           ;Save Y-Reg
                PHA                   ;Push/Save A-Reg
                JSR   VIDWAIT         ;Go Check for Pause (Ctrl-S)
; --<Undocumented User Entry Point>-- ;Restore A-Reg & Y-Reg (frm STACK & YSAV1)
COUTA           PLA                   ;Pull/Retrieve A-Reg
                LDY   YSAV1           ;Retrieve Y-Reg
                RTS                   ;Return to Caller

; ==============================================================================
; End of Display Screen Scroll Window Output Routines
; ==============================================================================
; 
; <---[Page Boundary]
; 
; ==============================================================================
; Monitor Command Handlers: $FE is the High/Page Address of All Monitor Command
; Handlers Referenced via the Monitor Command Subroutine Address Table (@ $FFE3)
; ==============================================================================
; 
; ==============================================================================
; More Memory Dump Routines:
; ==============================================================================
; 
; ==============================================================================
; Monitor (& Miniassembler) "Blank" Command Handlers:
; ==============================================================================
; 
; ----------------------------------- ;Handle Carriage Return as a Blank:
BL1             DEC   YSAV            ;Reduce Monitor Command Processing Value
                BEQ   XAM8            ;Branch if MCPV is Zero; Do Memory Dump
; ----------------------------------- ;Monitor Blank Space Command Handler;
;                                     ;Referenced via Subroutine Address Table:
BLANK           DEX                   ;Reduce X-Index Register Value
                BNE   SETMDZ          ;Branch if (X<>0); Save Token as Mode
                CMP   #':' | $80      ;Are we in Data-Store/Fill-Memory Mode?
                BNE   XAMPM           ;NO, Do: "Examine|Add|Subtract Mode?"
                STA   MODE            ;YES, Save ":" Token as Mode
                LDA   A2L             ;Get Monitor General Purpose A2-Reg, Low
                STA   (A3L),Y         ;Set (A3-Reg),Y
                INC   A3L             ;Up Monitor General Purpose A3-Reg, Low
                BNE   MON_RTS5        ;Branch if No Carryover, yet
                INC   A3H             ;Up Monitor General Purpose A3-Reg, High
MON_RTS5        RTS                   ;Return to Caller

; ==============================================================================
; Monitor Mode Commands Handler:
; ==============================================================================
; Subtract ("-"), Add ("+"), Fill Memory (":"), or Address Range Delimiter (".")
; [Command Characters are converted to Command Tokens during the Input Process!]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Mode ("-"|"+"|":"|".") Commands Handler;
;                                     ;Referenced via Subroutine Address Table:
SETMODE         LDY   YSAV            ;Get Index for Monitor Command Processing
                LDA   INBUFF-1,Y      ;Get Command Token from Input Buffer
SETMDZ          STA   MODE            ;Save Command Token as Monitor Mode
; ----------------------------------- ;JSR here to determine where one is:
; <User Entry Point (Label Not Used)> ;[A JSR to an RTS STACKs Current Address]
IDROUTINE       RTS                   ;Return to Caller

; ==============================================================================
; End of More Memory Dump Routines:
; ==============================================================================
; 
; ==============================================================================
; Monitor "<" Move/Verify Delimiter
; ==============================================================================
; 
; ----------------------------------- ;Copy A2 (2 bytes) to A4 & A5;
;                                     ;Referenced via Subroutine Address Table:
LT              LDX   #1              ;Get Index to do High Bytes 1st
LT2             LDA   A2L,X           ;Get Monitor General Purpose A2-Reg, Hi/Lo
                STA   A4L,X           ;5et Monitor General Purpose A4-Reg, Hi/Lo
                STA   A5L,X           ;5et Monitor General Purpose A5-Reg, Hi/Lo
                DEX                   ;Reduce Index to do Low Bytes Last
                BPL   LT2             ;Loop Once to do Low Bytes Last
                RTS                   ;Then, Return to Caller

; ==============================================================================
; Monitor Move Memory ("M") Command Handler: *Adrs1<Adrs2.Adrs3M
; ==============================================================================
; 
; ----------------------------------- ;Copy/Move Bytes from (A1~A2),Y to (A4),Y;
;                                     ;Referenced via Subroutine Address Table:
MOVE            LDA   (A1L),Y         ;Get Byte at Source Address (A1)
                STA   (A4L),Y         ;Set Byte at Destination Address (A4)
                JSR   NXTA4           ;Increment General Purpose A4 & A1 Regs
                BCC   MOVE            ;BLT: Branch if A1 has NOT Reached A2
                RTS                   ;Return to Caller

; ==============================================================================
; Monitor Verify Memory ("V") Command Handler: *Adrs1<Adrs2.Adrs3V
; ==============================================================================
; 
; ----------------------------------- ;Verify Bytes from (A1~A2),Y with (A4),Y;
;                                     ;Referenced via Subroutine Address Table:
VFY             LDA   (A1L),Y         ;Get Byte at Source Address (A1)
                CMP   (A4L),Y         ;Compare Byte at Destination Address (A4)
                BEQ   VFYOK           ;Branch if Both are Identical; Do Next
; ----------------------------------- ;Else, Verify Failed:
                JSR   PRA1            ;Print Memory Address
                LDA   (A1L),Y         ;Get Byte at Source Address (A1)
                JSR   PRBYTE          ;Print A-Reg as Two-Digit Hex Number
                LDA   #' ' | $80      ;Get a Space Character
                JSR   COUT            ;Print Char (A) to Output Device
                LDA   #'(' | $80      ;Get an Opening Parenthesis
                JSR   COUT            ;Print Char (A) to Output Device
                LDA   (A4L),Y         ;Get Byte at Destination Address (A4)
                JSR   PRBYTE          ;Print A-Reg as Two-Digit Hex Number
                LDA   #')' | $80      ;Get an Closing Parenthesis
                JSR   COUT            ;Print Char (A) to Output Device
; ----------------------------------- ;Verify Succeeded; Do Next Byte:
VFYOK           JSR   NXTA4           ;Increment General Purpose A4 & A1 Regs
                BCC   VFY             ;BLT: Branch if A1 has NOT Reached A2
                RTS                   ;Return to Caller

; ==============================================================================
; Monitor List ("L") Command Handler: *AdrsL
; ==============================================================================
; Disassembles 20 Instructions per List ("L") Command [e.g., *AdrsLL; *LL; *LLL]
; If User Specified an Address, then (X) is Not Zero (0) & should be One (1)!
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Disassemble 20 Instruction Lines;
;                                     ;Referenced via Subroutine Address Table:
MON_LIST        JSR   A1PC            ;Copy A1 (2 bytes) to PC if Specified
                LDA   #20             ;Prepare to Disassemble 20 Lines
MON_LIST2       PHA                   ;Push Line Count
                JSR   INSTDSP         ;Disassemble & Print Instruction at PC
                JSR   PCADJ           ;Add (A+C) to Instruction Address (PCL,H)
                STA   PCL             ;Save Updated Program Counter, Low
                STY   PCH             ;Save Updated Program Counter, High
                PLA                   ;Pull Line Count
                SEC                   ;Prepare to Subtract w/o Borrow [A-Data-!C]
                SBC   #1              ;Reduce Line Count
                BNE   MON_LIST2       ;Loop Until Done: Disassembled 20 Lines
                RTS                   ;Return to Caller

; ==============================================================================
; Copy A1 (2 bytes) to PC if Specified (X=1):      [<<< or Bug: if (0>X>1)! >>>]
; ==============================================================================
; If User Specified an Address, then (X) is Not Zero (0) & should be One (1)!
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Copy A1 (2 bytes) to PC if Specified;
;                                     ;<<< (X) must be (0|1) upon Entry >>>:
A1PC            TXA                   ;Check Index to do High Bytes 1st
                BEQ   A1PCRTS         ;Return to Caller if (X) is Zero (<1)
;                                     ;<<< Catastrophic to A1~ if (0>X>1) >>>:
A1PCLP          LDA   A1L,X           ;Get Monitor General Purpose A1-Reg, Hi/Lo
                STA   PCL,X           ;5et Monitor General Purpose PC-Reg, Hi/Lo
                DEX                   ;Reduce Index to do Low Bytes Last
                BPL   A1PCLP          ;Loop Once to do Low Bytes Last
A1PCRTS         RTS                   ;Return to Caller

; ==============================================================================
; Monitor Set Inverse Video ("I") Command Handler: Black Chr on White Background
; ==============================================================================
; 
; ----------------------------------- ;Set Inverse Video;
;                                     ;Referenced via Subroutine Address Table:
SETINV          LDY   #$3F            ;Get Text Mask (Invese=$3F)
                BNE   SETIFLG         ;Always Taken

; ==============================================================================
; Monitor Set Normal Video ("N") Command Handler: White Chr on Black Background
; ==============================================================================
; 
; ----------------------------------- ;Set Normal Video;
;                                     ;Referenced via Subroutine Address Table:
SETNORM         LDY   #$FF            ;Get Text Mask (Normal=$FF)
; ----------------------------------- ;Set Inverse Flag (from Y-Reg):
SETIFLG         STY   INVFLG          ;Set Text Mask
;                                     ;^[Normal  = $FF = %11111111: N=%1 & V=%1]
;                                     ;^[Flash   = $7F = %01111111: N=%0 & V=%1]
;                                     ;^[Inverse = $3F = %00111111: N=%0 & V=%0]
                RTS                   ;Return to Caller

; ==============================================================================
; Reset "Key Switch (KSW)" Input Vector to KEYIN ($FD1B):
; ==============================================================================
; 
SETKBD          LDA   #>KSWL          ;Get Zero-Page Address of KSW, High (=0)
INPORT          STA   A2L             ;Set Monitor General Purpose A2-Reg, Low
; 
; ==============================================================================
; Monitor Set IN# Slot ("Ctrl+K") Command Handler: *<Slot# {0~7}><Ctrl+K>
; ==============================================================================
; 
; ----------------------------------- ;Set IN# Slot ("Ctrl-K"); 
;                                     ;Referenced via Subroutine Address Table:
MON_INPRT       LDX   #KSWL           ;Get Zero-Page Address of KSW, Low
                LDY   #<KEYIN         ;Get Address of KEYIN, Low
                BNE   IOPRT           ;Always Taken

; ==============================================================================
; Reset "Character Switch (CSW)" Output Vector to COUT1 ($FDF0):
; ==============================================================================
; 
SETVID          LDA   #>CSWL          ;Get Zero-Page Address of CSW, High (=0)
OUTPORT         STA   A2L             ;Set Monitor General Purpose A2-Reg, Low
; 
; ==============================================================================
; Monitor Set PR# Slot ("Ctrl+P") Command Handler: *<Slot# {0~7}><Ctrl+P>
; ==============================================================================
; 
; ----------------------------------- ;Set PR# Slot ("Ctrl+P");
;                                     ;Referenced via Subroutine Address Table:
OUTPRT          LDX   #CSWL           ;Get Zero-Page Address of CSW, Low
                LDY   #<COUT1         ;Get Address of COUT1, Low
; 
; ==============================================================================
; Set Input/Output Vector (Port/Slot):
; ==============================================================================
; 
IOPRT           LDA   A2L             ;Get Monitor General Purpose A2-Reg, Low
                AND   #%00001111      ;Clear High Nibble & Keep Low Nibble
                BEQ   IOPRT1          ;Branch if Result is Zero (Page/Slot)
                ORA   #>IOADR         ;Set to Slot I/O Addresses ($CS00), High
                LDY   #0              ;Clear Y-Index Register (Force Branch)
                BEQ   IOPRT2          ;Always Taken

IOPRT1          LDA   #CIOPG          ;Get Mon Char I/O S/R Vectors Page Adrs
;                                     ;^[KEYIN ($FD1B) & COUT1 ($FDF0) S/Rs]
; <*** A Great User Entry Point! ***> ;Set Any 2 Byte ZP Location Based on (X);
;                                     ;LOC0: Preset to JMP OpCode ($4C); (X=1):
IOPRT2          STY   LOC0,X          ;Set BASIC Soft/Warm/Ctrl-C Entry, Low
                STA   LOC1,X          ;Set BASIC Soft/Warm/Ctrl-C Entry, High
                RTS                   ;Return to Caller

; ==============================================================================
; 
MON_NOP3        NOP                   ;Fill
MON_NOP4        NOP                   ;Fuller ;-)
; 
; ==============================================================================
; Monitor Cold Start BASIC: ("Ctrl-B") Command Handler: *<Ctrl-B><Return>
; ==============================================================================
; Jump to [Integer/Applesoft] BASIC [Hard/Cold/Control-B Entry Point (With
; Complete Reinitialization)]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
XBASIC          JMP   BASIC           ;Cold Start BASIC ("Ctrl-B")

; 
; ==============================================================================
; Monitor Warm Start BASIC: ("Ctrl-C") Command Handler: *<Ctrl-C><Return>
; ==============================================================================
; Jump to [Integer/Applesoft] BASIC [Soft/Warm/Control-C Entry Point (Without
; Reinitialization of Symbol-Table, Variables or Data)]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
BASCONT         JMP   BASIC2          ;Warm Start BASIC ("Ctrl-C")

; ==============================================================================
; Monitor Execute a Program ("G") Command Handler: *AdrsG
; ==============================================================================
; Jumps to Address Specified in Program Counter (PC) with 6502 Registers
; Restored from Save Area
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
GO              JSR   A1PC            ;Copy A1 (2 bytes) to PC if Specified
;              ---------------------- ;<Undocumented User Entry Point>:
GO1             JSR   MON_RESTORE     ;Restore (P), (A), (X), & (Y) Registers
;              ---------------------- ;<Undocumented User Entry Point>:
GO2             JMP   (PCL)           ;Go to User Subroutine [(PCL,H)=($3A,$3B)]

; ==============================================================================
; Monitor Display Registers ("Ctrl-E") Command Handler: *<Ctrl-E>
; ==============================================================================
; Display Current Values of A-Reg, X-Reg, Y-Reg, P-Reg, & S-Reg
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
REGZ            JMP   REGDSP          ;Show (A), (X), (Y), (P), & (S) Registers

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Start of Section (FEC2-FEC9): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Monitor Trace "T" Command Handler: *AdrsT                      [NOT USED NOW!]
; ==============================================================================
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
TRACE_RTS       RTS                   ;TRACE is Gone; This RTS is Not Used!

                NOP                   ;TRACE is now like USR (via CHRTBL)*
; 
; ==============================================================================
; Monitor Step "S" Command Handler: *AdrsS                       [NOT USED NOW!]
; ==============================================================================
; 
STEPZ_RTS       RTS                   ;STEP is Gone; This RTS is Not Used!

; ----------------------------------- ;Referenced via Subroutine Address Table:
STEPZ_USR       NOP                   ;STEP is now like USR (via CHRTBL)*
                NOP                   ;Now, the STEP (S) Command is the
                NOP                   ;same as the User (Ctrl-Y) Command
                NOP                   ;Do Nothing Else
                NOP                   ;*This whole S/T code block isn't used now!
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; End of Section (FEC2-FEC9): New in Autostart [New Monitor] ROM
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Monitor User ("Ctrl-Y") Command Handler: *<Ctrl-Y>
; ==============================================================================
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
USR             JMP   USRADDR         ;JMP to Autostart User Vector ("Ctrl-Y")

; 
; ==============================================================================
; Monitor WRITE to Audio Cassette Tape ("W") Command Handler: *Adrs1.Adrs2W
; ==============================================================================
; Writes 10 second Header Monotone to Audio-Out, followed by a Synchronization
; Bit, then the contents of the memory specified, then a one byte CheckSum
; ------------------------------------------------------------------------------
; Enter with: (A1L,A1H)=($3C,$3D)=(Address of first Data Byte)
;             (A2L,A2H)=($3E,$3F)=(Address of  last Data Byte)
; ------------------------------------------------------------------------------
; [See "A2 Monitors Peeled" pgs.81~84, TN/TIL# 495~496, & RDBYTE Description ^^]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
MON_WRITE       LDA   #64             ;Prep to Write [(A)*256] Half-Cycles
;                                     ;^[For 'Long-1' (650 usec) Half-Cycles]
                JSR   HEADER          ;Write 10 second Header [10,649,600 usec]
;                                     ;^[A-Reg, X-Reg & Y-Reg are Altered!]
;              ---------------------- ;Write Memory Data to Cassette Tape Record
                LDY   #39             ;Set Half-Cycle Duration Counter
WR1             LDX   #0              ;Clear Indexed Indirect Addressing Index
                EOR   (A1L,X)         ;Get (A)=(A)XOR(A1L) [1st Time (A=$FF)]
                PHA                   ;Push XOR Result (Running CheckSum)
                LDA   (A1L,X)         ;Get a Memory Byte
                JSR   WRBYTE          ;Write 8 Bit Byte to Cassette Tape Record
                JSR   NXTA1           ;Increment A1 & Compare to A2
                LDY   #29             ;Set Half-Cycle Duration Counter
                PLA                   ;Pull XOR Result (Running CheckSum)
                BCC   WR1             ;BLT: Loop if A1 has NOT Reached A2
;              ---------------------- ;Write CheckSum to Cassette Tape Record
                LDY   #34             ;Set Half-Cycle Duration Counter
                JSR   WRBYTE          ;Write 8 Bit Byte to Cassette Tape Record
                BEQ   BELL            ;(X=0): Always Taken
; 
; ==============================================================================
; Internal Cassette Tape Write (Output) & Read (Input) Routines: HEADER, WRBIT,
; RDBYTE, RD2BIT, RDBIT, WRBYTE (See: "Apple II Monitors Peeled" pgs.81~84)
; ==============================================================================
; 
; ==============================================================================
; Write Byte Subroutine: Writes a Byte (8 Bits) to a Cassette Tape Record
; ==============================================================================
; <---["Feed Me!"--From the 1960 (J.Nickolson) Movie: "Little Shop of Horrors"]
;     [<Reminder>--Your Cassette Tape Recorder is hungry!  Feed it a Byte. ;-D]
; ------------------------------------------------------------------------------
; 
WRBYTE          LDX   #16             ;Get (X) Audio Half-Cycle Toggle Count
WRBYT2          ASL   A               ;Shift High Bit into Carry
                JSR   WRBIT           ;Write a Bit [Returns: (X=X-2)]
                BNE   WRBYT2          ;Branch Until Done <-[when (X=0)]
                RTS                   ;Return to Caller

; ==============================================================================
; 2nd End Of Internal Cassette Tape Write (Output) & Read (Input) Routines
; ==============================================================================
; 
; 
; ==============================================================================
; Monitor End Input ("Carriage Return") Command Handler: *<Some Input><Ctrl-M>
; ==============================================================================
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
CRMON           JSR   BL1             ;Handle Carriage Return as a Blank
                PLA                   ;Pull/Discard Return Address, Low
                PLA                   ;Pull/Discard Return Address, High
                BNE   MONZ            ;Restart Monitor ("*" Prompt) Silently
; 
; ==============================================================================
; Monitor READ from Audio Cassette Tape ("R") Command Handler: *Adrs1.Adrs2R
; ==============================================================================
; Reads Tape Records from Audio-in, placing the input into the memory range
; specified, then a one byte CheckSum
; ------------------------------------------------------------------------------
; Enter with: (A1L,A1H)=($3C,$3D)=(Address of first Data Byte)
;             (A2L,A2H)=($3E,$3F)=(Address of  last Data Byte)
; ------------------------------------------------------------------------------
; [See "A2 Monitors Peeled" pgs.81~84, TN/TIL# 495~496, & RDBYTE Description ^^]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Subroutine Address Table:
MON_READ        JSR   RD2BIT          ;Read Two Transitions (Find Edge)
; <---[Page Boundary]
                LDA   #22             ;Prep to Write [(A)*256] Half-Cycles
;                                     ;^[For 'Long-1' (650 usec) Half-Cycles]
; ----------------------------------- ;Entry Point to Read Shape Table
; <<< DANGEROUS if Accidentally Tape Recording instead of Playing Tape!  But,
; for a Program Tape, Accidentally Recording would be BAD all by itself! >>>:
MON_READ2       JSR   HEADER          ;Write used to Delay about 3.5 seconds
;                                     ;Writes 3.7 second Header [3,660,800 usec]
;                                     ;^[A-Reg, X-Reg & Y-Reg are Altered!]
                STA   CHKSUM          ;Initialize CheckSum (A=$FF):[A2RM]
                JSR   RD2BIT          ;Read Two Transitions (Find Edge)
;                                     ;Find 'Short-0' Sync Bit:
MON_RD2         LDY   #36             ;Set Half-Cycle Duration Counter
                JSR   RDBIT           ;Read 1 Transition from Tape Record
                BCS   MON_RD2         ;BGE: Loop Until 'Short-0' Sync Bit Found
                JSR   RDBIT           ;Skip Sync-Bit's 2nd Half-Cycle
                LDY   #59             ;Set Half-Cycle Duration Counter
MON_RD3         JSR   RDBYTE          ;Read 8 Bit Byte from Cassette Tape Record
                STA   (A1L,X)         ;Store Byte in Memory Range Specified
                EOR   CHKSUM          ;Compute New Running CheckSum
                STA   CHKSUM          ;Save New Running CheckSum
                JSR   NXTA1           ;Increment A1 & Compare to A2
                LDY   #53             ;Set Half-Cycle Duration Counter
                BCC   MON_RD3         ;BLT: Loop if A1 has NOT Reached A2
                JSR   RDBYTE          ;Read CheckSum Byte from Tape Record
                CMP   CHKSUM          ;Do the two CheckSums Match?
                BEQ   BELL            ;YES, Sound Bell & Return to Caller
; <User Entry Point (Label Not Used)> ;Print "ERR" & Bell to Outpud Device:
MON_RDERR       LDA   #'E' | $80      ;Get 1st Letter Char to Print
                JSR   COUT            ;Print A-Reg to Output Device
                LDA   #'R' | $80      ;Get 2nd & 3rd Letter Char to Print
                JSR   COUT            ;Print A-Reg to Output Device
                JSR   COUT            ;Print A-Reg to Output Device
BELL            LDA   #BELL_H         ;BELL causes delay if Key bounces
                JMP   COUT            ;Print A-Reg to Output Device

; ==============================================================================
; Restore (P), (A), (X), & (Y) Register Contents            [Used for Debugging]
; ==============================================================================
; 
MON_RESTORE     LDA   STATUS          ;Retrieve Status from P-Reg Safe
                PHA                   ;Push Status
                LDA   ACC             ;Retrieve A-Reg from Safe
                LDX   XREG            ;Retrieve X-Reg from Safe
                LDY   YREG            ;Retrieve Y-Reg from Safe
                PLP                   ;Pull Status
                RTS                   ;Return to Caller

; ==============================================================================
; Save All 6502 Registers, Including Program Counter [(PCL,H)=($3A,$3B)]:
; ==============================================================================
; 
; <User Entry Point (Label Not Used)> ;Save All Registers & Program Counter:
MON_SAVE        STA   ACC             ;Save A-Reg in Safe
; ----------------------------------- ;Save Registers on Break Entry Point:
;                                     ;<<< BUG: SAV1 Does Not Save A-Reg! >>>
SAV1            STX   XREG            ;Save X-Reg in Safe
                STY   YREG            ;Save Y-Reg in Safe
                PHP                   ;Push Status Register
                PLA                   ;Pull Status Value
                STA   STATUS          ;Save Status in P-Reg Safe
                TSX                   ;Get STACK Pointer
                STX   SPNT            ;Save STACK Pointer in Safe
                CLD                   ;Clear Decimal Flag; Sets Hex Mode
; ----------------------------------- ;JSR here to determine where one is:
;                                     ;[A JSR to an RTS STACKs Current Address]
IORTS           RTS                   ;Return to Caller

; ==============================================================================
; Old Reset Routine:
; ==============================================================================
; Monitor "Cold Start" Entry Point [Referenced via Reset Vector]: All Resets are
; Vectored here; Sets Normal Text Screen Mode & Initializes Keyboard & Screen as
; the I/O Devices
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Referenced via Interrupt Vector Table:
;                                     ;<< BUG: OLDRST Vector ($FF59) IS Wrong >>
OLDRST          JSR   SETNORM         ;Set Normal Video Mode
                JSR   INIT            ;Initialize Video Screen for Text Mode
                JSR   SETVID          ;Reset CSW Output Vector to COUT1 ($FDF0)
                JSR   SETKBD          ;Reset KSW Input Vector to KEYIN ($FD1B)
; 
; ==============================================================================
; Monitor "Warm Start" ("Loud Reset") Entry Point: Sets Hexadecimal Mode & Beeps
; ==============================================================================
; 
; ----------------------------------- ;Restart Monitor ("*" Prompt) Loudly:
MON             CLD                   ;Must Clear Decimal Flag; Sets Hex Mode
                JSR   BELL            ;Send BELL Char to Output Device
; 
; ==============================================================================
; Monitor "Warm Start" ("Silent Reset") Entry Point (from BASIC):
; ==============================================================================
; Sets Monitor "Star" ('*') Prompt & Reads a Line of User Input
; [See also, "The 3D0G (3-Dog-Night) Command Returns A User To Basic"]
; ------------------------------------------------------------------------------
; 
; ----------------------------------- ;Restart Monitor ("*" Prompt) Silently:
MONZ            LDA   #'*' | $80      ;Get Monitor Prompt Character ("*")
                STA   PROMPT          ;Set Monitor Prompt Character ("*")
                JSR   GETLNZ          ;Prompt User for Input; Read a Line
; <User Entry Point (Label Not Used)> ;Scan IDX [Input Buffer ($200..$2FF)?]:
SCANIDX         JSR   ZMODE           ;Clear Monitor Mode
; ----------------------------------- ;Process Monitor Commands; Get Next Item:
NXTITM          JSR   GETNUM          ;Get Non-Hex Char; (X=0) If No Hex Input
                STY   YSAV            ;Save (Y) for Monitor Command Processing
                LDY   #23             ;There are only 23 Monitor Commands
; ----------------------------------- ;Search Character Table (Loop)
;                                     ;^[Used to Decode Keyboard Input]:
CHRSRCH         DEY                   ;Reduce Monitor Command Search Counter
                BMI   MON             ;If Not Found, Go Restart Monitor Loudly
                CMP   CHRTBL,Y        ;Else, Find Command Char in Char Table
                BNE   CHRSRCH         ;Loop until Search Counter is Zero
                JSR   TOSUB           ;Cmd Found: Call Corresponding Subroutine
                LDY   YSAV            ;Save (Y) for Monitor Command Processing
                JMP   NXTITM          ;Go Process Next Monitor Command

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; <<< ZMODE is NOT HERE (above) at $FF7C!  ZMODE is actually at $FFC7!  The
; $FF7C address, as documented in Luebbert's "What's Where in The Apple", is
; incorrect.  He mistakenly transposed the last two hexadecimal digits of the
; real $FFC7 address to get $FF7C.  [Or, was it on purpose, to confuse the enemy
; during the cold war?  IIRC, Luebbert was a professor at Anapolis then.] >>>
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; 
; ==============================================================================
; Hexadecimal Digit Shifter:
; ==============================================================================
; Bit Map: <- (A2H)=(%ABCD,EFGH); <- (A2L)=(%IJKL,MNOP); <- (A)=(%QRST,UVWX) <-
; ------------------------------------------------------------------------------
; 
DIGIT           LDX   #3              ;Set Index to Shift 4 Bits (Hi<-Lo Bytes)
                ASL   A               ;Got Hex Digit, Shift it into A2:
                ASL   A               ;1st Shift (A) Low Nibble into High Nibble
                ASL   A               ;(4 ASL's Discard High Nibble Bits
                ASL   A               ;& Zero Low Nibble Bits); (A)=(%UVWX,0000)
NXTBIT          ASL   A               ;2nd Shift (A) High Nibble
                ROL   A2L             ;into (A2L) Low Nibble; (A2L)=(%MNOP,UVWX)
                ROL   A2H             ;& (A2L) High Nibble into (A2H) Low Nibble
;                                     ;(Discards A2H Hi Nib); (A2H)=(%EFGH,IJKL)
                DEX                   ;Reduce Shift Count
                BPL   NXTBIT          ;Branch Until All 4 Bits have been Shifted
;                                     ;^[Leaves (X)=($FF)=(-1) & (A=0)]
; ------------------------------------------------------------------------------
; Note: If (0<=X<=$80) upon entry, NXTBIT could shift up to 128 bits left
; through A2 but, only the last 16 bits would be retained!
; ------------------------------------------------------------------------------
; 
NXTBAS          LDA   MODE            ;Get Monitor Mode Flag [0 Mode = Mem Dump]
                BNE   NXTBS2          ;If Mode is Zero then Copy A2 to A1 & A3
                LDA   A2H,X           ;Get A2-Reg, Low then High
                STA   A1H,X           ;Set A1-Reg, Low then High
                STA   A3H,X           ;Set A3-Reg, Low then High
NXTBS2          INX                   ;Advance Indexed Adressing X-Index (-1~0)
                BEQ   NXTBAS          ;Branch if Lows Done; Do Highs
                BNE   NXTCHR          ;Else, Do Next Mon Cmd Char; Always Taken

; ==============================================================================
; Monitor Command Parser: Gets a Hexadecimal Digits from the Input Buffer
; ==============================================================================
; Get a Character from Input Buffer; If it is a Hexadecimal Digit, Branch to
; Digit; Else, Return to Caller
; ------------------------------------------------------------------------------
; 
GETNUM          LDX   #0              ;Clear X-Index; Prepare to Clear A2
                STX   A2L             ;Clear A2-Reg, Low
                STX   A2H             ;Clear A2-Reg, High
NXTCHR          LDA   INBUFF,Y        ;Get Next Char from Input Buffer
                INY                   ;Advance Input Buffer Char Pointer
                EOR   #'0' | $80      ;Is Char a Numeral >= 0?
                CMP   #10             ;Is Char a Numeral < 10?
                BCC   DIGIT           ;BLT: Branch if Hex/Dec Digit
                ADC   #$88            ;Is Char a Letter >=("A")? [Adds (C=1)]
;                                     ;[($88)+("A"=$C1)+(C=1)]=($14A)->(C=1)
                CMP   #$FA            ;Is Char a Letter <=("z") [A-Data->NZC]
;                                     ;[($4A)]-($FA="z")=($50)] [A<Data];
;                                     ; But (C=1) remains unchaged, so ...
                BCS   DIGIT           ;BGE: Branch if Hex Digit
                RTS                   ;Return to Caller

; 
; ==============================================================================
; Monitor Command Found; Push & Return to Corresponding Subroutine:
; ==============================================================================
; 
TOSUB           LDA   #>BL1           ;Get High Address of All Mon Cmd Handlers
;                                     ; Referenced via Subroutine Address Table
                PHA                   ;Push High-Order S/R Address
                LDA   SUBTBL,Y        ;Get Low Address from S/R Address Table
                PHA                   ;Push Low-Order S/R Address
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; This confirms the order of the return address pushed onto the stack during a
; subroutine call (JSR); the high-order subroutine address is pushed 1st and the
; low-order subroutine address is pushed 2nd (so, reverse order when pulling)
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                LDA   MODE            ;Get Old Mode
; ----------------------------------- ;Clear/Zero Monitor Mode:
ZMODE           LDY   #$00            ;Clear Y-Index Register
                STY   MODE            ;Clear Monitor Mode Flag
                RTS                   ;Go To S/R via Return to Caller

; ==============================================================================
; Character Table: Used to Decode Keyboard Input (23 Monitor Commands)
; ==============================================================================
; 
;              DFB    $NN = <-----> = ;F({[High ASCII of "Char"] XOR $B0}+$89)
;              ==========             ;=========================================
;              \V/    \V/             ;  Mon.Cmds  Subroutines  Actions
;              ---    ---             ;  --------   --------   -----------------
CHRTBL          DFB   $BC             ;F("Ctrl-C") ; BASCONT ; Warm Start BASIC
                DFB   $B2             ;F("Ctrl-Y") ; USR     ; JMP to User Vector
                DFB   $BE             ;F("Ctrl-E") ; REGZ    ; Display Registers
                DFB   $B2             ;F("T")      ; TRACE   ; CMD now like USR *
                DFB   $EF             ;F("V")      ; VFY     ; Verify Memory
                DFB   $C4             ;F("Ctrl-K") ; INPRT   ; Set IN# Slot
                DFB   $B2             ;F("S")      ; STEPZ   ; CMD now like USR *
                DFB   $A9             ;F("Ctrl-P") ; OUTPRT  ; Set PR# Slot
                DFB   $BB             ;F("Ctrl-B") ; XBASIC  ; Cold Start BASIC
                DFB   $A6             ;F("-")      ; SETMODE ; Subtract
                DFB   $A4             ;F("+")      ; SETMODE ; Add
                DFB   $06             ;F("M")      ; MOVE    ; Move Memory
                DFB   $95             ;F("<")      ; LT      ; MOVE/VFY Delimiter
                DFB   $07             ;F("N")      ; SETNORM ; Set Normal Video
                DFB   $02             ;F("I")      ; SETINV  ; Set Inverse Video
                DFB   $05             ;F("L")      ; LIST    ; Disassemble 20 Instrs
                DFB   $F0             ;F("W")      ; WRITE   ; Write to Audio Tape
                DFB   $00             ;F("G")      ; GO      ; Execute a Program
                DFB   $EB             ;F("R")      ; READ    ; Read from Audio Tape
                DFB   $93             ;F(":")      ; SETMODE ; Fill Memory
                DFB   $A7             ;F(".")      ; SETMODE ; Address Range Delimiter
                DFB   $C6             ;F("CR")     ; CRMON   ; End Input
                DFB   $99             ;F(" ")      ; BLANK   ; Space Character
; 
; ==============================================================================
; Subroutine Address Table: Used by TOSUB to Push onto Stack for RTS;
; Index Program Counter (PC) with Table Item for Subroutine Entry;
; Addresses: (Subroutine)-1; (MSB)=(#$FE); (LSB)=(Table Entry)+1
; ==============================================================================
; 
;              LSB    Subroutines     ;Mon.Cmds   Actions 
;              ---    -----------     ;--------   ---------------- 
SUBTBL          DFB   <BASCONT-1      ;"Ctrl-C" ; Warm Start BASIC
                DFB   <USR-1          ;"Ctrl-Y" ; JMP to User Vector
                DFB   <REGZ-1         ;"Ctrl-E" ; Display Registers
                DFB   <TRACE_RTS-1    ;"T"      ; TRACE: Now an 'RTS'; [TRACE_RTN]
; ------------------------------------------------------------------------------
; STEP & TRACE are now like USR (via CHRTBL): The way it is coded now, the Apple
; II Plus Autostart TRACE (T) Command is the same as the USER (Ctrl-Y) Command *
; ------------------------------------------------------------------------------
                DFB   <VFY-1          ;"V"      ; Verify Memory
                DFB   <MON_INPRT-1    ;"Ctrl-K" ; Set IN# Slot
                DFB   <STEPZ_USR-1    ;"S"      ; STEPZ: Now an 'RTS'; [STEPZ_RTN]
; ------------------------------------------------------------------------------
; <<< BUG! -- Should Be: DFB $C3, Not DFB $C4; for STEPZ-1 ($FEC4-1 = $FEC3) >>>
; ------------------------------------------------------------------------------
; Turns out that this is not really a BUG.  The way it is coded now, the Apple
; II Plus Autostart STEP (S) Command is the same as the USER (Ctrl-Y) Command *
; ------------------------------------------------------------------------------
                DFB   <OUTPRT-1       ;"Ctrl-P" ; Set PR# Slot
                DFB   <XBASIC-1       ;"Ctrl-B" ; Cold Start BASIC
                DFB   <SETMODE-1      ;"-"      ; Subtract
                DFB   <SETMODE-1      ;"+"      ; Add
                DFB   <MOVE-1         ;"M"      ; Move Memory
                DFB   <LT-1           ;"<"      ; MOVE/VFY Delimiter
                DFB   <SETNORM-1      ;"N"      ; Set Normal Video
                DFB   <SETINV-1       ;"I"      ; Set Inverse Video
                DFB   <MON_LIST-1     ;"L"      ; Disassemble 20 Instrs
                DFB   <MON_WRITE-1    ;"W"      ; Write to Audio Tape
                DFB   <GO-1           ;"G"      ; Execute a Program
                DFB   <MON_READ-1     ;"R"      ; Read from Audio Tape
                DFB   <SETMODE-1      ;":"      ; Fill Memory
                DFB   <SETMODE-1      ;"."      ; Address Range Delimiter
                DFB   <CRMON-1        ;"CR"     ; End Input
                DFB   <BLANK-1        ;" "      ; Space Character (BLANK)
; 
; ==============================================================================
; 6502 Interrupt Vector Table
; ==============================================================================
; 
                DW    NMI             ;NMI Vector
                DW    RESET           ;RESET Vector
; ==============================================================================
; WHAT THE FOLLOWING SHOULD & SHOULD NOT BE:
; ------------------------------------------------------------------------------
;              DW     IRQ             ;IRQ Vector    ($FA40) IS Right;
;              DW     OLDRST          ;OLDRST Vector ($FF59) IS Wrong! << BUG >>
; ------------------------------------------------------------------------------
;        <<< BUG can be fixed in (Apple II Plus) Emulator ROM images! >>>
; ==============================================================================
               DW    OLDRST          ;OLDRST Vector ($FF59) IS Wrong! << BUG >>
